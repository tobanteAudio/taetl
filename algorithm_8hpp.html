<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>taetl: etl/algorithm.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">taetl
   &#160;<span id="projectnumber">0.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_6adb7a8b31c129f1821662822662f63e.html">etl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">algorithm.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="cassert_8hpp_source.html">etl/cassert.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="cstddef_8hpp_source.html">etl/cstddef.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="functional_8hpp_source.html">etl/functional.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="iterator_8hpp_source.html">etl/iterator.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="type__traits_8hpp_source.html">etl/type_traits.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="algo__search_8hpp_source.html">etl/detail/algo_search.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="algo__swap_8hpp_source.html">etl/detail/algo_swap.hpp</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for algorithm.hpp:</div>
<div class="dyncontent">
<div class="center"><img src="algorithm_8hpp__incl.png" border="0" usemap="#etl_2algorithm_8hpp" alt=""/></div>
<map name="etl_2algorithm_8hpp" id="etl_2algorithm_8hpp">
<area shape="rect" id="node2" href="cassert_8hpp.html" title="etl/cassert.hpp" alt="" coords="5,80,124,107"/>
<area shape="rect" id="node3" href="cstddef_8hpp.html" title="etl/cstddef.hpp" alt="" coords="1175,304,1293,331"/>
<area shape="rect" id="node7" href="type__traits_8hpp.html" title="etl/type_traits.hpp" alt="" coords="526,453,667,480"/>
<area shape="rect" id="node9" href="functional_8hpp.html" title="etl/functional.hpp" alt="" coords="890,80,1026,107"/>
<area shape="rect" id="node10" href="iterator_8hpp.html" title="etl/iterator.hpp" alt="" coords="800,155,919,181"/>
<area shape="rect" id="node20" href="algo__swap_8hpp.html" title="etl/detail/algo_swap.hpp" alt="" coords="250,304,431,331"/>
<area shape="rect" id="node23" href="algo__search_8hpp.html" title="etl/detail/algo_search.hpp" alt="" coords="1047,155,1237,181"/>
<area shape="rect" id="node4" href="cstddef__internal_8hpp.html" title="etl/detail/cstddef\l_internal.hpp" alt="" coords="993,528,1125,569"/>
<area shape="rect" id="node5" href="intrinsics_8hpp.html" title="etl/detail/intrinsics.hpp" alt="" coords="870,617,1041,644"/>
<area shape="rect" id="node6" href="sfinae_8hpp.html" title="etl/detail/sfinae.hpp" alt="" coords="1149,535,1300,562"/>
<area shape="rect" id="node8" href="type__traits__decl_8hpp.html" title="etl/detail/type_traits\l_decl.hpp" alt="" coords="547,528,702,569"/>
<area shape="rect" id="node19" href="utility_8hpp.html" title="etl/utility.hpp" alt="" coords="666,229,773,256"/>
<area shape="rect" id="node22" href="new_8hpp.html" title="etl/new.hpp" alt="" coords="997,229,1095,256"/>
<area shape="rect" id="node11" href="memory_8hpp.html" title="etl/memory.hpp" alt="" coords="797,229,921,256"/>
<area shape="rect" id="node18" href="warning_8hpp.html" title="etl/warning.hpp" alt="" coords="1027,304,1150,331"/>
<area shape="rect" id="node12" href="limits_8hpp.html" title="etl/limits.hpp" alt="" coords="753,304,861,331"/>
<area shape="rect" id="node13" href="cfloat_8hpp.html" title="cfloat.hpp" alt="" coords="725,379,812,405"/>
<area shape="rect" id="node14" href="climits_8hpp.html" title="climits.hpp" alt="" coords="607,379,701,405"/>
<area shape="rect" id="node15" href="cmath_8hpp.html" title="cmath.hpp" alt="" coords="887,379,978,405"/>
<area shape="rect" id="node16" href="cstdint_8hpp.html" title="cstdint.hpp" alt="" coords="1003,379,1097,405"/>
<area shape="rect" id="node17" href="version_8hpp.html" title="version.hpp" alt="" coords="999,453,1098,480"/>
<area shape="rect" id="node21" href="tuple__size_8hpp.html" title="etl/detail/tuple_size.hpp" alt="" coords="353,379,531,405"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="algorithm_8hpp__dep__incl.png" border="0" usemap="#etl_2algorithm_8hppdep" alt=""/></div>
<map name="etl_2algorithm_8hppdep" id="etl_2algorithm_8hppdep">
<area shape="rect" id="node2" href="array_8hpp.html" title="etl/array.hpp" alt="" coords="584,80,687,107"/>
<area shape="rect" id="node3" href="bitset_8hpp.html" title="etl/bitset.hpp" alt="" coords="189,162,297,189"/>
<area shape="rect" id="node5" href="vector_8hpp.html" title="etl/vector.hpp" alt="" coords="321,162,432,189"/>
<area shape="rect" id="node11" href="set_8hpp.html" title="etl/set.hpp" alt="" coords="1342,162,1433,189"/>
<area shape="rect" id="node13" href="string__view_8hpp.html" title="etl/string_view.hpp" alt="" coords="125,80,271,107"/>
<area shape="rect" id="node15" href="map_8hpp.html" title="etl/map.hpp" alt="" coords="763,80,863,107"/>
<area shape="rect" id="node16" href="optional_8hpp.html" title="etl/optional.hpp" alt="" coords="887,80,1011,107"/>
<area shape="rect" id="node4" href="dsp_8hpp.html" title="etl/experimental/dsp\l/dsp.hpp" alt="" coords="457,155,614,196"/>
<area shape="rect" id="node7" href="interrupt_8hpp.html" title="etl/experimental/hardware\l/stm32/interrupt.hpp" alt="" coords="638,155,833,196"/>
<area shape="rect" id="node8" href="buffer__const_8hpp.html" title="etl/experimental/net\l/buffer_const.hpp" alt="" coords="857,155,1011,196"/>
<area shape="rect" id="node10" href="buffer__mutable_8hpp.html" title="etl/experimental/net\l/buffer_mutable.hpp" alt="" coords="1035,155,1190,196"/>
<area shape="rect" id="node12" href="span_8hpp.html" title="etl/span.hpp" alt="" coords="1215,162,1317,189"/>
<area shape="rect" id="node6" href="format_8hpp.html" title="etl/experimental/format\l/format.hpp" alt="" coords="62,244,241,285"/>
<area shape="rect" id="node9" href="buffer_8hpp.html" title="etl/experimental/net\l/buffer.hpp" alt="" coords="946,244,1101,285"/>
<area shape="rect" id="node14" href="string_8hpp.html" title="etl/string.hpp" alt="" coords="5,162,113,189"/>
</map>
</div>
</div>
<p><a href="algorithm_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceetl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html">etl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa18b878794474881fce640e7a163abf3"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt1 , typename ForwardIt2 &gt; </td></tr>
<tr class="memitem:aa18b878794474881fce640e7a163abf3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa18b878794474881fce640e7a163abf3">etl::iter_swap</a> (ForwardIt1 a, ForwardIt2 b) -&gt; void</td></tr>
<tr class="memdesc:aa18b878794474881fce640e7a163abf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the values of the elements the given iterators are pointing to.  <a href="namespaceetl.html#aa18b878794474881fce640e7a163abf3">More...</a><br /></td></tr>
<tr class="separator:aa18b878794474881fce640e7a163abf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab304c4b8ab09994291b47d138bfe303c"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIter1 , typename ForwardIter2 &gt; </td></tr>
<tr class="memitem:ab304c4b8ab09994291b47d138bfe303c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab304c4b8ab09994291b47d138bfe303c">etl::swap_ranges</a> (ForwardIter1 first1, ForwardIter1 last1, ForwardIter2 first2) -&gt; ForwardIter2</td></tr>
<tr class="memdesc:ab304c4b8ab09994291b47d138bfe303c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges elements between range [first1 ,last1) and another range starting at first2.  <a href="namespaceetl.html#ab304c4b8ab09994291b47d138bfe303c">More...</a><br /></td></tr>
<tr class="separator:ab304c4b8ab09994291b47d138bfe303c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a5b274f170d18a9e175fddf538a4bc"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename OutputIter &gt; </td></tr>
<tr class="memitem:ad0a5b274f170d18a9e175fddf538a4bc"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad0a5b274f170d18a9e175fddf538a4bc">etl::move</a> (InputIter first, InputIter last, OutputIter destination) -&gt; OutputIter</td></tr>
<tr class="memdesc:ad0a5b274f170d18a9e175fddf538a4bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the elements in the range [first, last), to another range beginning at destination, starting from first and proceeding to last - 1. After this operation the elements in the moved-from range will still contain valid values of the appropriate type, but not necessarily the same values as before the move.  <a href="namespaceetl.html#ad0a5b274f170d18a9e175fddf538a4bc">More...</a><br /></td></tr>
<tr class="separator:ad0a5b274f170d18a9e175fddf538a4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c1bbc9c04ed65c5902b5a4d4f32035"><td class="memTemplParams" colspan="2">template&lt;typename BidirIter1 , typename BidirIter2 &gt; </td></tr>
<tr class="memitem:a75c1bbc9c04ed65c5902b5a4d4f32035"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a75c1bbc9c04ed65c5902b5a4d4f32035">etl::move_backward</a> (BidirIter1 first, BidirIter1 last, BidirIter2 destination) -&gt; BidirIter2</td></tr>
<tr class="memdesc:a75c1bbc9c04ed65c5902b5a4d4f32035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the elements from the range [first, last), to another range ending at destination. The elements are moved in reverse order (the last element is moved first), but their relative order is preserved.  <a href="namespaceetl.html#a75c1bbc9c04ed65c5902b5a4d4f32035">More...</a><br /></td></tr>
<tr class="separator:a75c1bbc9c04ed65c5902b5a4d4f32035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47b84f5bf40f76cc783ff22a0c3888e"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename UnaryFunction &gt; </td></tr>
<tr class="memitem:ad47b84f5bf40f76cc783ff22a0c3888e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad47b84f5bf40f76cc783ff22a0c3888e">etl::for_each</a> (InputIter first, InputIter last, UnaryFunction f) noexcept -&gt; UnaryFunction</td></tr>
<tr class="memdesc:ad47b84f5bf40f76cc783ff22a0c3888e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given function object f to the result of dereferencing every iterator in the range [first, last) in order.  <a href="namespaceetl.html#ad47b84f5bf40f76cc783ff22a0c3888e">More...</a><br /></td></tr>
<tr class="separator:ad47b84f5bf40f76cc783ff22a0c3888e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3c610f3a94e96a8a1c8cac49e70388"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename Size , typename UnaryFunction &gt; </td></tr>
<tr class="memitem:a9c3c610f3a94e96a8a1c8cac49e70388"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9c3c610f3a94e96a8a1c8cac49e70388">etl::for_each_n</a> (InputIter first, Size n, UnaryFunction f) noexcept -&gt; InputIter</td></tr>
<tr class="memdesc:a9c3c610f3a94e96a8a1c8cac49e70388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given function object f to the result of dereferencing every iterator in the range [first, first + n] in order.  <a href="namespaceetl.html#a9c3c610f3a94e96a8a1c8cac49e70388">More...</a><br /></td></tr>
<tr class="separator:a9c3c610f3a94e96a8a1c8cac49e70388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704b8d21ad6879a3a28be5c0bd435fa4"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename OutputIter , typename UnaryOperation &gt; </td></tr>
<tr class="memitem:a704b8d21ad6879a3a28be5c0bd435fa4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a704b8d21ad6879a3a28be5c0bd435fa4">etl::transform</a> (InputIter first, InputIter last, OutputIter dest, UnaryOperation op) -&gt; OutputIter</td></tr>
<tr class="memdesc:a704b8d21ad6879a3a28be5c0bd435fa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given function to a range and stores the result in another range, beginning at dest. The unary operation op is applied to the range defined by [first, last).  <a href="namespaceetl.html#a704b8d21ad6879a3a28be5c0bd435fa4">More...</a><br /></td></tr>
<tr class="separator:a704b8d21ad6879a3a28be5c0bd435fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f81702ed6fdeecec082a39e50e4e2a"><td class="memTemplParams" colspan="2">template&lt;typename InputIter1 , typename InputIter2 , typename OutputIter , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:a85f81702ed6fdeecec082a39e50e4e2a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a85f81702ed6fdeecec082a39e50e4e2a">etl::transform</a> (InputIter1 first1, InputIter1 last1, InputIter2 first2, OutputIter dest, BinaryOperation op) -&gt; OutputIter</td></tr>
<tr class="memdesc:a85f81702ed6fdeecec082a39e50e4e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given function to a range and stores the result in another range, beginning at destination. The binary operation op is applied to pairs of elements from two ranges: one defined by [first1, last1) and the other beginning at first2.  <a href="namespaceetl.html#a85f81702ed6fdeecec082a39e50e4e2a">More...</a><br /></td></tr>
<tr class="separator:a85f81702ed6fdeecec082a39e50e4e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dafeb773e43238a39165aeffe200e9a"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIter , typename Generator &gt; </td></tr>
<tr class="memitem:a9dafeb773e43238a39165aeffe200e9a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9dafeb773e43238a39165aeffe200e9a">etl::generate</a> (ForwardIter first, ForwardIter last, Generator g) -&gt; void</td></tr>
<tr class="memdesc:a9dafeb773e43238a39165aeffe200e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns each element in range [first, last) a value generated by the given function object g.  <a href="namespaceetl.html#a9dafeb773e43238a39165aeffe200e9a">More...</a><br /></td></tr>
<tr class="separator:a9dafeb773e43238a39165aeffe200e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ef45defed1d076c23d018658203f69"><td class="memTemplParams" colspan="2">template&lt;typename OutputIter , typename SizeT , typename Generator &gt; </td></tr>
<tr class="memitem:ae9ef45defed1d076c23d018658203f69"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae9ef45defed1d076c23d018658203f69">etl::generate_n</a> (OutputIter first, SizeT count, Generator g) -&gt; OutputIter</td></tr>
<tr class="memdesc:ae9ef45defed1d076c23d018658203f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns values, generated by given function object g, to the first count elements in the range beginning at first, if count &gt; 0. Does nothing otherwise.  <a href="namespaceetl.html#ae9ef45defed1d076c23d018658203f69">More...</a><br /></td></tr>
<tr class="separator:ae9ef45defed1d076c23d018658203f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12959aac739b3aca2ded392a4255ec12"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename T &gt; </td></tr>
<tr class="memitem:a12959aac739b3aca2ded392a4255ec12"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a12959aac739b3aca2ded392a4255ec12">etl::count</a> (InputIter first, InputIter last, T const &amp;value) -&gt; typename iterator_traits&lt; InputIter &gt;::difference_type</td></tr>
<tr class="memdesc:a12959aac739b3aca2ded392a4255ec12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the range [first, last) satisfying specific criteria. Counts the elements that are equal to value.  <a href="namespaceetl.html#a12959aac739b3aca2ded392a4255ec12">More...</a><br /></td></tr>
<tr class="separator:a12959aac739b3aca2ded392a4255ec12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af949f9bf15cdfd7e8282705ab00ddcc3"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:af949f9bf15cdfd7e8282705ab00ddcc3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af949f9bf15cdfd7e8282705ab00ddcc3">etl::count_if</a> (InputIter first, InputIter last, UnaryPredicate p) -&gt; typename iterator_traits&lt; InputIter &gt;::difference_type</td></tr>
<tr class="memdesc:af949f9bf15cdfd7e8282705ab00ddcc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the range [first, last) satisfying specific criteria. Counts elements for which predicate p returns true.  <a href="namespaceetl.html#af949f9bf15cdfd7e8282705ab00ddcc3">More...</a><br /></td></tr>
<tr class="separator:af949f9bf15cdfd7e8282705ab00ddcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab340ce2b640eb395b08fe8b266881603"><td class="memTemplParams" colspan="2">template&lt;typename InputIter1 , typename InputIter2 , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ab340ce2b640eb395b08fe8b266881603"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab340ce2b640eb395b08fe8b266881603">etl::mismatch</a> (InputIter1 first1, InputIter1 last1, InputIter2 first2, BinaryPredicate pred) -&gt; <a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; InputIter1, InputIter2 &gt;</td></tr>
<tr class="memdesc:ab340ce2b640eb395b08fe8b266881603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first mismatching pair of elements from two ranges: one defined by [first1, last1) and another defined by [first2,last2). If last2 is not provided (overloads (1-4)), it denotes first2 + (last1 - first1). Elements are compared using the given binary predicate pred.  <a href="namespaceetl.html#ab340ce2b640eb395b08fe8b266881603">More...</a><br /></td></tr>
<tr class="separator:ab340ce2b640eb395b08fe8b266881603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5670e9bd29e9fb8b573558fe9a6bff17"><td class="memTemplParams" colspan="2">template&lt;typename InputIter1 , typename InputIter2 &gt; </td></tr>
<tr class="memitem:a5670e9bd29e9fb8b573558fe9a6bff17"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5670e9bd29e9fb8b573558fe9a6bff17">etl::mismatch</a> (InputIter1 first1, InputIter1 last1, InputIter2 first2) -&gt; <a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; InputIter1, InputIter2 &gt;</td></tr>
<tr class="memdesc:a5670e9bd29e9fb8b573558fe9a6bff17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first mismatching pair of elements from two ranges: one defined by [first1, last1) and another defined by [first2,last2). If last2 is not provided (overloads (1-4)), it denotes first2 + (last1 - first1). Elements are compared using operator==.  <a href="namespaceetl.html#a5670e9bd29e9fb8b573558fe9a6bff17">More...</a><br /></td></tr>
<tr class="separator:a5670e9bd29e9fb8b573558fe9a6bff17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4d823211420bf94fe43c94bf902a57"><td class="memTemplParams" colspan="2">template&lt;typename InputIter1 , typename InputIter2 , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ace4d823211420bf94fe43c94bf902a57"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ace4d823211420bf94fe43c94bf902a57">etl::mismatch</a> (InputIter1 first1, InputIter1 last1, InputIter2 first2, InputIter2 last2, BinaryPredicate pred) -&gt; <a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; InputIter1, InputIter2 &gt;</td></tr>
<tr class="memdesc:ace4d823211420bf94fe43c94bf902a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first mismatching pair of elements from two ranges: one defined by [first1, last1) and another defined by [first2, last2). Elements are compared using the given binary predicate pred.  <a href="namespaceetl.html#ace4d823211420bf94fe43c94bf902a57">More...</a><br /></td></tr>
<tr class="separator:ace4d823211420bf94fe43c94bf902a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934b1b48023aa9532f3f329fe18f1079"><td class="memTemplParams" colspan="2">template&lt;typename InputIter1 , typename InputIter2 &gt; </td></tr>
<tr class="memitem:a934b1b48023aa9532f3f329fe18f1079"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a934b1b48023aa9532f3f329fe18f1079">etl::mismatch</a> (InputIter1 first1, InputIter1 last1, InputIter2 first2, InputIter2 last2) -&gt; <a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; InputIter1, InputIter2 &gt;</td></tr>
<tr class="memdesc:a934b1b48023aa9532f3f329fe18f1079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first mismatching pair of elements from two ranges: one defined by [first1, last1) and another defined by [first2,last2). Elements are compared using operator==.  <a href="namespaceetl.html#a934b1b48023aa9532f3f329fe18f1079">More...</a><br /></td></tr>
<tr class="separator:a934b1b48023aa9532f3f329fe18f1079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba98486c230b754b2cabc1805b53c16"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIter , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:a9ba98486c230b754b2cabc1805b53c16"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9ba98486c230b754b2cabc1805b53c16">etl::adjacent_find</a> (ForwardIter first, ForwardIter last, BinaryPredicate pred) -&gt; ForwardIter</td></tr>
<tr class="memdesc:a9ba98486c230b754b2cabc1805b53c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the range [first, last) for two consecutive equal elements. Elements are compared using the given binary predicate p.  <a href="namespaceetl.html#a9ba98486c230b754b2cabc1805b53c16">More...</a><br /></td></tr>
<tr class="separator:a9ba98486c230b754b2cabc1805b53c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe91c66e3042bde20710111a8d622e4"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt &gt; </td></tr>
<tr class="memitem:a4fe91c66e3042bde20710111a8d622e4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4fe91c66e3042bde20710111a8d622e4">etl::adjacent_find</a> (ForwardIt first, ForwardIt last) -&gt; ForwardIt</td></tr>
<tr class="memdesc:a4fe91c66e3042bde20710111a8d622e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the range [first, last) for two consecutive equal elements. Elements are compared using operator==.  <a href="namespaceetl.html#a4fe91c66e3042bde20710111a8d622e4">More...</a><br /></td></tr>
<tr class="separator:a4fe91c66e3042bde20710111a8d622e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac504b45acce22fba5a962a6ba642c942"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename T &gt; </td></tr>
<tr class="memitem:ac504b45acce22fba5a962a6ba642c942"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac504b45acce22fba5a962a6ba642c942">etl::find</a> (InputIter first, InputIter last, T const &amp;value) noexcept -&gt; InputIter</td></tr>
<tr class="memdesc:ac504b45acce22fba5a962a6ba642c942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an element equal to value.  <a href="namespaceetl.html#ac504b45acce22fba5a962a6ba642c942">More...</a><br /></td></tr>
<tr class="separator:ac504b45acce22fba5a962a6ba642c942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86af54b99a151aef63d7af26f0e8c26a"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a86af54b99a151aef63d7af26f0e8c26a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a86af54b99a151aef63d7af26f0e8c26a">etl::find_if</a> (InputIter first, InputIter last, UnaryPredicate pred) noexcept -&gt; InputIter</td></tr>
<tr class="memdesc:a86af54b99a151aef63d7af26f0e8c26a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an element for which predicate p returns true.  <a href="namespaceetl.html#a86af54b99a151aef63d7af26f0e8c26a">More...</a><br /></td></tr>
<tr class="separator:a86af54b99a151aef63d7af26f0e8c26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9d16dde42342fd1e6b91ea378af979"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a2a9d16dde42342fd1e6b91ea378af979"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2a9d16dde42342fd1e6b91ea378af979">etl::find_if_not</a> (InputIter first, InputIter last, UnaryPredicate predicate) noexcept -&gt; InputIter</td></tr>
<tr class="memdesc:a2a9d16dde42342fd1e6b91ea378af979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an element for which predicate q returns false.  <a href="namespaceetl.html#a2a9d16dde42342fd1e6b91ea378af979">More...</a><br /></td></tr>
<tr class="separator:a2a9d16dde42342fd1e6b91ea378af979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153bb5f923b54433abe623a6846a903a"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename ForwardIter , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:a153bb5f923b54433abe623a6846a903a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a153bb5f923b54433abe623a6846a903a">etl::find_first_of</a> (InputIter first, InputIter last, ForwardIter s_first, ForwardIter s_last, BinaryPredicate pred) -&gt; InputIter</td></tr>
<tr class="memdesc:a153bb5f923b54433abe623a6846a903a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the range [first, last) for any of the elements in the range [s_first, s_last). Elements are compared using the given binary predicate pred.  <a href="namespaceetl.html#a153bb5f923b54433abe623a6846a903a">More...</a><br /></td></tr>
<tr class="separator:a153bb5f923b54433abe623a6846a903a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76b6e0c91c8150e8b4b7c1192337fe2"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename ForwardIter &gt; </td></tr>
<tr class="memitem:af76b6e0c91c8150e8b4b7c1192337fe2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af76b6e0c91c8150e8b4b7c1192337fe2">etl::find_first_of</a> (InputIter first, InputIter last, ForwardIter s_first, ForwardIter s_last) -&gt; InputIter</td></tr>
<tr class="memdesc:af76b6e0c91c8150e8b4b7c1192337fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the range [first, last) for any of the elements in the range [s_first, s_last). Elements are compared using operator==.  <a href="namespaceetl.html#af76b6e0c91c8150e8b4b7c1192337fe2">More...</a><br /></td></tr>
<tr class="separator:af76b6e0c91c8150e8b4b7c1192337fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7813a73d80057255ef78a69804f2f361"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIter1 , typename ForwardIter2 , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:a7813a73d80057255ef78a69804f2f361"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7813a73d80057255ef78a69804f2f361">etl::search</a> (ForwardIter1 first, ForwardIter1 last, ForwardIter2 s_first, ForwardIter2 s_last, BinaryPredicate pred) -&gt; ForwardIter1</td></tr>
<tr class="memdesc:a7813a73d80057255ef78a69804f2f361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the first occurrence of the sequence of elements [s_first, s_last) in the range [first, last). Elements are compared using the given binary predicate pred.  <a href="namespaceetl.html#a7813a73d80057255ef78a69804f2f361">More...</a><br /></td></tr>
<tr class="separator:a7813a73d80057255ef78a69804f2f361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af723526a6284b865a1a001958e4f72a4"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIter1 , typename ForwardIter2 &gt; </td></tr>
<tr class="memitem:af723526a6284b865a1a001958e4f72a4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af723526a6284b865a1a001958e4f72a4">etl::search</a> (ForwardIter1 first, ForwardIter1 last, ForwardIter2 s_first, ForwardIter2 s_last) -&gt; ForwardIter1</td></tr>
<tr class="memdesc:af723526a6284b865a1a001958e4f72a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the first occurrence of the sequence of elements [s_first, s_last) in the range [first, last). Elements are compared using operator==.  <a href="namespaceetl.html#af723526a6284b865a1a001958e4f72a4">More...</a><br /></td></tr>
<tr class="separator:af723526a6284b865a1a001958e4f72a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358e4ef95efe7ae5429eb586dedf290f"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIter , typename Searcher &gt; </td></tr>
<tr class="memitem:a358e4ef95efe7ae5429eb586dedf290f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a358e4ef95efe7ae5429eb586dedf290f">etl::search</a> (ForwardIter first, ForwardIter last, Searcher const &amp;searcher) -&gt; ForwardIter</td></tr>
<tr class="memdesc:a358e4ef95efe7ae5429eb586dedf290f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the sequence [first, last) for the pattern specified in the constructor of searcher.  <a href="namespaceetl.html#a358e4ef95efe7ae5429eb586dedf290f">More...</a><br /></td></tr>
<tr class="separator:a358e4ef95efe7ae5429eb586dedf290f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d677a05e506fdaaad8076170be13c4"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIter , typename Size , typename ValueT , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ae3d677a05e506fdaaad8076170be13c4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae3d677a05e506fdaaad8076170be13c4">etl::search_n</a> (ForwardIter first, ForwardIter last, Size count, ValueT const &amp;value, BinaryPredicate pred) -&gt; ForwardIter</td></tr>
<tr class="memdesc:ae3d677a05e506fdaaad8076170be13c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the range [first, last) for the first sequence of count identical elements, each equal to the given value.  <a href="namespaceetl.html#ae3d677a05e506fdaaad8076170be13c4">More...</a><br /></td></tr>
<tr class="separator:ae3d677a05e506fdaaad8076170be13c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7087e9411c18f19a166d89a93f7d4b99"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIter , typename Size , typename ValueT &gt; </td></tr>
<tr class="memitem:a7087e9411c18f19a166d89a93f7d4b99"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7087e9411c18f19a166d89a93f7d4b99">etl::search_n</a> (ForwardIter first, ForwardIter last, Size count, ValueT const &amp;value) -&gt; ForwardIter</td></tr>
<tr class="memdesc:a7087e9411c18f19a166d89a93f7d4b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the range [first, last) for the first sequence of count identical elements, each equal to the given value.  <a href="namespaceetl.html#a7087e9411c18f19a166d89a93f7d4b99">More...</a><br /></td></tr>
<tr class="separator:a7087e9411c18f19a166d89a93f7d4b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e77a31d2842fc3ce0d0830363d39429"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIter , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a8e77a31d2842fc3ce0d0830363d39429"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8e77a31d2842fc3ce0d0830363d39429">etl::remove_if</a> (ForwardIter first, ForwardIter last, UnaryPredicate pred) -&gt; ForwardIter</td></tr>
<tr class="memdesc:a8e77a31d2842fc3ce0d0830363d39429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements satisfying specific criteria from the range [first, last) and returns a past-the-end iterator for the new end of the range.  <a href="namespaceetl.html#a8e77a31d2842fc3ce0d0830363d39429">More...</a><br /></td></tr>
<tr class="separator:a8e77a31d2842fc3ce0d0830363d39429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503e23901912a73957ee7739fe5a2b72"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIter , typename T &gt; </td></tr>
<tr class="memitem:a503e23901912a73957ee7739fe5a2b72"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a503e23901912a73957ee7739fe5a2b72">etl::remove</a> (ForwardIter first, ForwardIter last, T const &amp;value) -&gt; ForwardIter</td></tr>
<tr class="memdesc:a503e23901912a73957ee7739fe5a2b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements satisfying specific criteria from the range [first, last) and returns a past-the-end iterator for the new end of the range.  <a href="namespaceetl.html#a503e23901912a73957ee7739fe5a2b72">More...</a><br /></td></tr>
<tr class="separator:a503e23901912a73957ee7739fe5a2b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6d6ee3525b61f4cf4adb57febcf54f"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename OutputIter , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:abc6d6ee3525b61f4cf4adb57febcf54f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abc6d6ee3525b61f4cf4adb57febcf54f">etl::remove_copy_if</a> (InputIter first, InputIter last, OutputIter destination, UnaryPredicate p) -&gt; OutputIter</td></tr>
<tr class="memdesc:abc6d6ee3525b61f4cf4adb57febcf54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies elements from the range [ first , last ), to another range beginning at destination, omitting the elements which satisfy specific criteria. Source and destination ranges cannot overlap. Ignores all elements for which predicate p returns true.  <a href="namespaceetl.html#abc6d6ee3525b61f4cf4adb57febcf54f">More...</a><br /></td></tr>
<tr class="separator:abc6d6ee3525b61f4cf4adb57febcf54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4339ec2a525bcc25e197da3ba0fc2428"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename OutputIter , typename T &gt; </td></tr>
<tr class="memitem:a4339ec2a525bcc25e197da3ba0fc2428"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4339ec2a525bcc25e197da3ba0fc2428">etl::remove_copy</a> (InputIter first, InputIter last, OutputIter destination, T const &amp;value) -&gt; OutputIter</td></tr>
<tr class="memdesc:a4339ec2a525bcc25e197da3ba0fc2428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies elements from the range [ first , last ), to another range beginning at destination, omitting the elements which satisfy specific criteria. Source and destination ranges cannot overlap. Ignores all elements that are equal to value.  <a href="namespaceetl.html#a4339ec2a525bcc25e197da3ba0fc2428">More...</a><br /></td></tr>
<tr class="separator:a4339ec2a525bcc25e197da3ba0fc2428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd524dd4e2bef44f16351525ccb4c68b"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename UnaryPredicate , typename T &gt; </td></tr>
<tr class="memitem:afd524dd4e2bef44f16351525ccb4c68b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afd524dd4e2bef44f16351525ccb4c68b">etl::replace_if</a> (ForwardIt first, ForwardIt last, UnaryPredicate p, T const &amp;new_value) -&gt; void</td></tr>
<tr class="memdesc:afd524dd4e2bef44f16351525ccb4c68b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all elements satisfying specific criteria with new_value in the range [ first , last ). Replaces all elements for which predicate p returns true.  <a href="namespaceetl.html#afd524dd4e2bef44f16351525ccb4c68b">More...</a><br /></td></tr>
<tr class="separator:afd524dd4e2bef44f16351525ccb4c68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30584dde0e75b7b64eab8813f209015b"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename T &gt; </td></tr>
<tr class="memitem:a30584dde0e75b7b64eab8813f209015b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a30584dde0e75b7b64eab8813f209015b">etl::replace</a> (ForwardIt first, ForwardIt last, T const &amp;old_value, T const &amp;new_value) -&gt; void</td></tr>
<tr class="memdesc:a30584dde0e75b7b64eab8813f209015b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all elements satisfying specific criteria with new_value in the range [ first , last ). Replaces all elements that are equal to old_value.  <a href="namespaceetl.html#a30584dde0e75b7b64eab8813f209015b">More...</a><br /></td></tr>
<tr class="separator:a30584dde0e75b7b64eab8813f209015b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fdd0cf88f36f44f8fe8ec8327cfac74"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a7fdd0cf88f36f44f8fe8ec8327cfac74"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7fdd0cf88f36f44f8fe8ec8327cfac74">etl::max</a> (Type const &amp;a, Type const &amp;b) noexcept -&gt; Type const &amp;</td></tr>
<tr class="memdesc:a7fdd0cf88f36f44f8fe8ec8327cfac74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the greater of a and b.  <a href="namespaceetl.html#a7fdd0cf88f36f44f8fe8ec8327cfac74">More...</a><br /></td></tr>
<tr class="separator:a7fdd0cf88f36f44f8fe8ec8327cfac74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220fbd23aca7dbc728c200471ed114c8"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Compare &gt; </td></tr>
<tr class="memitem:a220fbd23aca7dbc728c200471ed114c8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a220fbd23aca7dbc728c200471ed114c8">etl::max</a> (Type const &amp;a, Type const &amp;b, Compare comp) noexcept -&gt; Type const &amp;</td></tr>
<tr class="memdesc:a220fbd23aca7dbc728c200471ed114c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the greater of a and b, using a compare function.  <a href="namespaceetl.html#a220fbd23aca7dbc728c200471ed114c8">More...</a><br /></td></tr>
<tr class="separator:a220fbd23aca7dbc728c200471ed114c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa58c8973da727c50c3d0d28b83fdf304"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:aa58c8973da727c50c3d0d28b83fdf304"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa58c8973da727c50c3d0d28b83fdf304">etl::max_element</a> (ForwardIterator first, ForwardIterator last) noexcept -&gt; ForwardIterator</td></tr>
<tr class="memdesc:aa58c8973da727c50c3d0d28b83fdf304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the greatest element in the range [first, last). Elements are compared using operator&lt;.  <a href="namespaceetl.html#aa58c8973da727c50c3d0d28b83fdf304">More...</a><br /></td></tr>
<tr class="separator:aa58c8973da727c50c3d0d28b83fdf304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab573cae5dd21a6ab0e00ee00da8855e0"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Compare &gt; </td></tr>
<tr class="memitem:ab573cae5dd21a6ab0e00ee00da8855e0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab573cae5dd21a6ab0e00ee00da8855e0">etl::max_element</a> (ForwardIterator first, ForwardIterator last, Compare comp) -&gt; ForwardIterator</td></tr>
<tr class="memdesc:ab573cae5dd21a6ab0e00ee00da8855e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the greatest element in the range [first, last). Elements are compared using the given binary comparison function comp.  <a href="namespaceetl.html#ab573cae5dd21a6ab0e00ee00da8855e0">More...</a><br /></td></tr>
<tr class="separator:ab573cae5dd21a6ab0e00ee00da8855e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae1500815312b248e453896d5439b63"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:adae1500815312b248e453896d5439b63"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adae1500815312b248e453896d5439b63">etl::min</a> (Type const &amp;a, Type const &amp;b) noexcept -&gt; Type const &amp;</td></tr>
<tr class="memdesc:adae1500815312b248e453896d5439b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller of a and b.  <a href="namespaceetl.html#adae1500815312b248e453896d5439b63">More...</a><br /></td></tr>
<tr class="separator:adae1500815312b248e453896d5439b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479c4a8315ae3ef2d1128858d723afc2"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Compare &gt; </td></tr>
<tr class="memitem:a479c4a8315ae3ef2d1128858d723afc2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a479c4a8315ae3ef2d1128858d723afc2">etl::min</a> (Type const &amp;a, Type const &amp;b, Compare comp) noexcept -&gt; Type const &amp;</td></tr>
<tr class="memdesc:a479c4a8315ae3ef2d1128858d723afc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller of a and b, using a compare function.  <a href="namespaceetl.html#a479c4a8315ae3ef2d1128858d723afc2">More...</a><br /></td></tr>
<tr class="separator:a479c4a8315ae3ef2d1128858d723afc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f1e60aa2d0ca23d39bd975ed52e4b4"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:a41f1e60aa2d0ca23d39bd975ed52e4b4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a41f1e60aa2d0ca23d39bd975ed52e4b4">etl::min_element</a> (ForwardIterator first, ForwardIterator last) noexcept -&gt; ForwardIterator</td></tr>
<tr class="memdesc:a41f1e60aa2d0ca23d39bd975ed52e4b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the smallest element in the range [first, last). Elements are compared using operator&lt;.  <a href="namespaceetl.html#a41f1e60aa2d0ca23d39bd975ed52e4b4">More...</a><br /></td></tr>
<tr class="separator:a41f1e60aa2d0ca23d39bd975ed52e4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae206eeb82f5e460124ce4b40e951fa0d"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Compare &gt; </td></tr>
<tr class="memitem:ae206eeb82f5e460124ce4b40e951fa0d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae206eeb82f5e460124ce4b40e951fa0d">etl::min_element</a> (ForwardIterator first, ForwardIterator last, Compare comp) -&gt; ForwardIterator</td></tr>
<tr class="memdesc:ae206eeb82f5e460124ce4b40e951fa0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the smallest element in the range [first, last). Elements are compared using the given binary comparison function comp.  <a href="namespaceetl.html#ae206eeb82f5e460124ce4b40e951fa0d">More...</a><br /></td></tr>
<tr class="separator:ae206eeb82f5e460124ce4b40e951fa0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7559af67c20b372bc0b033e62c5e392d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Compare &gt; </td></tr>
<tr class="memitem:a7559af67c20b372bc0b033e62c5e392d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7559af67c20b372bc0b033e62c5e392d">etl::minmax</a> (T const &amp;a, T const &amp;b, Compare comp) -&gt; <a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; T const &amp;, T const &amp;&gt;</td></tr>
<tr class="memdesc:a7559af67c20b372bc0b033e62c5e392d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lowest and the greatest of the given values.  <a href="namespaceetl.html#a7559af67c20b372bc0b033e62c5e392d">More...</a><br /></td></tr>
<tr class="separator:a7559af67c20b372bc0b033e62c5e392d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea649fb091eda986ea8f239e9e6b8fa0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aea649fb091eda986ea8f239e9e6b8fa0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aea649fb091eda986ea8f239e9e6b8fa0">etl::minmax</a> (T const &amp;a, T const &amp;b) -&gt; <a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; T const &amp;, T const &amp;&gt;</td></tr>
<tr class="memdesc:aea649fb091eda986ea8f239e9e6b8fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lowest and the greatest of the given values.  <a href="namespaceetl.html#aea649fb091eda986ea8f239e9e6b8fa0">More...</a><br /></td></tr>
<tr class="separator:aea649fb091eda986ea8f239e9e6b8fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0fbc89d84ad598117991376121167e8"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIter , typename Compare &gt; </td></tr>
<tr class="memitem:af0fbc89d84ad598117991376121167e8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af0fbc89d84ad598117991376121167e8">etl::minmax_element</a> (ForwardIter first, ForwardIter last, Compare comp) -&gt; <a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; ForwardIter, ForwardIter &gt;</td></tr>
<tr class="memdesc:af0fbc89d84ad598117991376121167e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the smallest and greatest element in the range [first, last).  <a href="namespaceetl.html#af0fbc89d84ad598117991376121167e8">More...</a><br /></td></tr>
<tr class="separator:af0fbc89d84ad598117991376121167e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad842c3b73117c7bef3f4edadafa5ebb0"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIter &gt; </td></tr>
<tr class="memitem:ad842c3b73117c7bef3f4edadafa5ebb0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad842c3b73117c7bef3f4edadafa5ebb0">etl::minmax_element</a> (ForwardIter first, ForwardIter last) -&gt; <a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; ForwardIter, ForwardIter &gt;</td></tr>
<tr class="memdesc:ad842c3b73117c7bef3f4edadafa5ebb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the smallest and greatest element in the range [first, last).  <a href="namespaceetl.html#ad842c3b73117c7bef3f4edadafa5ebb0">More...</a><br /></td></tr>
<tr class="separator:ad842c3b73117c7bef3f4edadafa5ebb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90379160c94dc0396b5f32204c790bf"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:af90379160c94dc0396b5f32204c790bf"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af90379160c94dc0396b5f32204c790bf">etl::clamp</a> (Type const &amp;v, Type const &amp;lo, Type const &amp;hi) noexcept -&gt; Type const &amp;</td></tr>
<tr class="memdesc:af90379160c94dc0396b5f32204c790bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">If v compares less than lo, returns lo; otherwise if hi compares less than v, returns hi; otherwise returns v. Uses operator&lt; to compare the values.  <a href="namespaceetl.html#af90379160c94dc0396b5f32204c790bf">More...</a><br /></td></tr>
<tr class="separator:af90379160c94dc0396b5f32204c790bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa416a307b0bb33666d34845c42ba2b"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Compare &gt; </td></tr>
<tr class="memitem:abfa416a307b0bb33666d34845c42ba2b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abfa416a307b0bb33666d34845c42ba2b">etl::clamp</a> (Type const &amp;v, Type const &amp;lo, Type const &amp;hi, Compare comp) -&gt; Type const &amp;</td></tr>
<tr class="separator:abfa416a307b0bb33666d34845c42ba2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b77a574e3e855966765f90b89bd753"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a88b77a574e3e855966765f90b89bd753"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a88b77a574e3e855966765f90b89bd753">etl::all_of</a> (InputIter first, InputIter last, UnaryPredicate p) -&gt; bool</td></tr>
<tr class="memdesc:a88b77a574e3e855966765f90b89bd753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate p returns true for all elements in the range [first, last).  <a href="namespaceetl.html#a88b77a574e3e855966765f90b89bd753">More...</a><br /></td></tr>
<tr class="separator:a88b77a574e3e855966765f90b89bd753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d54e00f1a365a0fb3d26386088c99c8"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a4d54e00f1a365a0fb3d26386088c99c8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4d54e00f1a365a0fb3d26386088c99c8">etl::any_of</a> (InputIter first, InputIter last, UnaryPredicate p) -&gt; bool</td></tr>
<tr class="memdesc:a4d54e00f1a365a0fb3d26386088c99c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate p returns true for at least one element in the range [first, last).  <a href="namespaceetl.html#a4d54e00f1a365a0fb3d26386088c99c8">More...</a><br /></td></tr>
<tr class="separator:a4d54e00f1a365a0fb3d26386088c99c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c75a52b3924626ffd935049fd0d510"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a75c75a52b3924626ffd935049fd0d510"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a75c75a52b3924626ffd935049fd0d510">etl::none_of</a> (InputIter first, InputIter last, UnaryPredicate p) -&gt; bool</td></tr>
<tr class="memdesc:a75c75a52b3924626ffd935049fd0d510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate p returns true for no elements in the range [first, last).  <a href="namespaceetl.html#a75c75a52b3924626ffd935049fd0d510">More...</a><br /></td></tr>
<tr class="separator:a75c75a52b3924626ffd935049fd0d510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9590c66ecd3e2668da22396b36470994"><td class="memTemplParams" colspan="2">template&lt;typename BidirIter &gt; </td></tr>
<tr class="memitem:a9590c66ecd3e2668da22396b36470994"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9590c66ecd3e2668da22396b36470994">etl::reverse</a> (BidirIter first, BidirIter last) -&gt; void</td></tr>
<tr class="memdesc:a9590c66ecd3e2668da22396b36470994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the order of the elements in the range [first, last). Behaves as if applying <a class="el" href="namespaceetl.html#aa18b878794474881fce640e7a163abf3" title="Swaps the values of the elements the given iterators are pointing to. ">etl::iter_swap</a> to every pair of iterators first+i, (last-i) - 1 for each non-negative i &lt; (last-first)/2.  <a href="namespaceetl.html#a9590c66ecd3e2668da22396b36470994">More...</a><br /></td></tr>
<tr class="separator:a9590c66ecd3e2668da22396b36470994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbd6a789b8ca03eeb582c7e2cb433e4"><td class="memTemplParams" colspan="2">template&lt;typename BidirIter , typename OutputIter &gt; </td></tr>
<tr class="memitem:a9cbd6a789b8ca03eeb582c7e2cb433e4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9cbd6a789b8ca03eeb582c7e2cb433e4">etl::reverse_copy</a> (BidirIter first, BidirIter last, OutputIter destination) -&gt; OutputIter</td></tr>
<tr class="memdesc:a9cbd6a789b8ca03eeb582c7e2cb433e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range [ first, last ) to another range beginning at d_first in such a way that the elements in the new range are in reverse order.  <a href="namespaceetl.html#a9cbd6a789b8ca03eeb582c7e2cb433e4">More...</a><br /></td></tr>
<tr class="separator:a9cbd6a789b8ca03eeb582c7e2cb433e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413f3ca2a6ec99863544b907a18e2b77"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIter &gt; </td></tr>
<tr class="memitem:a413f3ca2a6ec99863544b907a18e2b77"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a413f3ca2a6ec99863544b907a18e2b77">etl::rotate</a> (ForwardIter first, ForwardIter n_first, ForwardIter last) -&gt; ForwardIter</td></tr>
<tr class="memdesc:a413f3ca2a6ec99863544b907a18e2b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a left rotation on a range of elements.  <a href="namespaceetl.html#a413f3ca2a6ec99863544b907a18e2b77">More...</a><br /></td></tr>
<tr class="separator:a413f3ca2a6ec99863544b907a18e2b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b71bc0359b4e8144996d1a1ea271d46"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIter , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:a9b71bc0359b4e8144996d1a1ea271d46"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9b71bc0359b4e8144996d1a1ea271d46">etl::unique</a> (ForwardIter first, ForwardIter last, BinaryPredicate pred) -&gt; ForwardIter</td></tr>
<tr class="memdesc:a9b71bc0359b4e8144996d1a1ea271d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminates all except the first element from every consecutive group of equivalent elements from the range [first, last) and returns a past-the-end iterator for the new logical end of the range.  <a href="namespaceetl.html#a9b71bc0359b4e8144996d1a1ea271d46">More...</a><br /></td></tr>
<tr class="separator:a9b71bc0359b4e8144996d1a1ea271d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825f3aafcdce4f906287730fe3a44709"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIter &gt; </td></tr>
<tr class="memitem:a825f3aafcdce4f906287730fe3a44709"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a825f3aafcdce4f906287730fe3a44709">etl::unique</a> (ForwardIter first, ForwardIter last) -&gt; ForwardIter</td></tr>
<tr class="memdesc:a825f3aafcdce4f906287730fe3a44709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminates all except the first element from every consecutive group of equivalent elements from the range [first, last) and returns a past-the-end iterator for the new logical end of the range.  <a href="namespaceetl.html#a825f3aafcdce4f906287730fe3a44709">More...</a><br /></td></tr>
<tr class="separator:a825f3aafcdce4f906287730fe3a44709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c85c3f38fdc2e8f49bdb6c5e5dea43"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename OutputIter , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ad7c85c3f38fdc2e8f49bdb6c5e5dea43"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad7c85c3f38fdc2e8f49bdb6c5e5dea43">etl::unique_copy</a> (InputIter first, InputIter last, OutputIter destination, BinaryPredicate pred) -&gt; OutputIter</td></tr>
<tr class="memdesc:ad7c85c3f38fdc2e8f49bdb6c5e5dea43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range [first, last), to another range beginning at d_first in such a way that there are no consecutive equal elements. Only the first element of each group of equal elements is copied.  <a href="namespaceetl.html#ad7c85c3f38fdc2e8f49bdb6c5e5dea43">More...</a><br /></td></tr>
<tr class="separator:ad7c85c3f38fdc2e8f49bdb6c5e5dea43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75adac4ca1890a2c3dee203f76fee1bf"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename OutputIter &gt; </td></tr>
<tr class="memitem:a75adac4ca1890a2c3dee203f76fee1bf"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a75adac4ca1890a2c3dee203f76fee1bf">etl::unique_copy</a> (InputIter first, InputIter last, OutputIter destination) -&gt; OutputIter</td></tr>
<tr class="memdesc:a75adac4ca1890a2c3dee203f76fee1bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range [first, last), to another range beginning at d_first in such a way that there are no consecutive equal elements. Only the first element of each group of equal elements is copied.  <a href="namespaceetl.html#a75adac4ca1890a2c3dee203f76fee1bf">More...</a><br /></td></tr>
<tr class="separator:a75adac4ca1890a2c3dee203f76fee1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4630df1b225348af807f0f6a34b43d3"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIter , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:ae4630df1b225348af807f0f6a34b43d3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae4630df1b225348af807f0f6a34b43d3">etl::partition</a> (ForwardIter first, ForwardIter last, UnaryPredicate p) -&gt; ForwardIter</td></tr>
<tr class="memdesc:ae4630df1b225348af807f0f6a34b43d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders the elements in the range [first, last) in such a way that all elements for which the predicate p returns true precede the elements for which predicate p returns false. Relative order of the elements is not preserved.  <a href="namespaceetl.html#ae4630df1b225348af807f0f6a34b43d3">More...</a><br /></td></tr>
<tr class="separator:ae4630df1b225348af807f0f6a34b43d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5895e9a9060bb185c3f73e45b2c64e1"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename OutputIter1 , typename OutputIter2 , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:ab5895e9a9060bb185c3f73e45b2c64e1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab5895e9a9060bb185c3f73e45b2c64e1">etl::partition_copy</a> (InputIter first, InputIter last, OutputIter1 destination_true, OutputIter2 destination_false, UnaryPredicate p) -&gt; <a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; OutputIter1, OutputIter2 &gt;</td></tr>
<tr class="memdesc:ab5895e9a9060bb185c3f73e45b2c64e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range [ first , last ) to two different ranges depending on the value returned by the predicate p. The elements that satisfy the predicate p are copied to the range beginning at destination_true. The rest of the elements are copied to the range beginning at destination_false.  <a href="namespaceetl.html#ab5895e9a9060bb185c3f73e45b2c64e1">More...</a><br /></td></tr>
<tr class="separator:ab5895e9a9060bb185c3f73e45b2c64e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20e1d1b920a713420af38a83dd99486"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:ae20e1d1b920a713420af38a83dd99486"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae20e1d1b920a713420af38a83dd99486">etl::is_partitioned</a> (InputIter first, InputIter last, UnaryPredicate p) -&gt; bool</td></tr>
<tr class="memdesc:ae20e1d1b920a713420af38a83dd99486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all elements in the range [ first , last ) that satisfy the predicate p appear before all elements that don't. Also returns true if the range is empty.  <a href="namespaceetl.html#ae20e1d1b920a713420af38a83dd99486">More...</a><br /></td></tr>
<tr class="separator:ae20e1d1b920a713420af38a83dd99486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44f343846943962603cab0d192e2c4b"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIter , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:ae44f343846943962603cab0d192e2c4b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae44f343846943962603cab0d192e2c4b">etl::partition_point</a> (ForwardIter first, ForwardIter last, UnaryPredicate p) -&gt; ForwardIter</td></tr>
<tr class="memdesc:ae44f343846943962603cab0d192e2c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Examines the partitioned (as if by <a class="el" href="namespaceetl.html#ae4630df1b225348af807f0f6a34b43d3" title="Reorders the elements in the range [first, last) in such a way that all elements for which the predic...">etl::partition</a>) range [ first , last ) and locates the end of the first partition, that is, the first element that does not satisfy p or last if all elements satisfy p.  <a href="namespaceetl.html#ae44f343846943962603cab0d192e2c4b">More...</a><br /></td></tr>
<tr class="separator:ae44f343846943962603cab0d192e2c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e8e725e2d66da347e7e1f8c0aae083"><td class="memTemplParams" colspan="2">template&lt;typename BidirIter , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a08e8e725e2d66da347e7e1f8c0aae083"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a08e8e725e2d66da347e7e1f8c0aae083">etl::stable_partition</a> (BidirIter f, BidirIter l, UnaryPredicate p) -&gt; BidirIter</td></tr>
<tr class="memdesc:a08e8e725e2d66da347e7e1f8c0aae083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders the elements in the range [first, last) in such a way that all elements for which the predicate p returns true precede the elements for which predicate p returns false. Relative order of the elements is preserved.  <a href="namespaceetl.html#a08e8e725e2d66da347e7e1f8c0aae083">More...</a><br /></td></tr>
<tr class="separator:a08e8e725e2d66da347e7e1f8c0aae083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6c95d500822d453650e96620caee5d"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename OutputIter &gt; </td></tr>
<tr class="memitem:a6a6c95d500822d453650e96620caee5d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6a6c95d500822d453650e96620caee5d">etl::copy</a> (InputIter first, InputIter last, OutputIter destination) -&gt; OutputIter</td></tr>
<tr class="memdesc:a6a6c95d500822d453650e96620caee5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements in the range, defined by [first, last), to another range beginning at destination.  <a href="namespaceetl.html#a6a6c95d500822d453650e96620caee5d">More...</a><br /></td></tr>
<tr class="separator:a6a6c95d500822d453650e96620caee5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af598f817fb64b8da3b8f3dffd0a11ba0"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename OutputIter , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:af598f817fb64b8da3b8f3dffd0a11ba0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af598f817fb64b8da3b8f3dffd0a11ba0">etl::copy_if</a> (InputIter first, InputIter last, OutputIter d_first, UnaryPredicate pred) -&gt; OutputIter</td></tr>
<tr class="memdesc:af598f817fb64b8da3b8f3dffd0a11ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements in the range, defined by [first, last), to another range beginning at destination.  <a href="namespaceetl.html#af598f817fb64b8da3b8f3dffd0a11ba0">More...</a><br /></td></tr>
<tr class="separator:af598f817fb64b8da3b8f3dffd0a11ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1bb0a9fce600f19a513fe310b38bc9"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename Size , typename OutputIter &gt; </td></tr>
<tr class="memitem:a0c1bb0a9fce600f19a513fe310b38bc9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0c1bb0a9fce600f19a513fe310b38bc9">etl::copy_n</a> (InputIter first, Size count, OutputIter result) -&gt; OutputIter</td></tr>
<tr class="memdesc:a0c1bb0a9fce600f19a513fe310b38bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies exactly count values from the range beginning at first to the range beginning at result. Formally, for each integer 0  i &lt; count, performs *(result + i) = *(first + i). Overlap of ranges is formally permitted, but leads to unpredictable ordering of the results.  <a href="namespaceetl.html#a0c1bb0a9fce600f19a513fe310b38bc9">More...</a><br /></td></tr>
<tr class="separator:a0c1bb0a9fce600f19a513fe310b38bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53fd2bc273dba3758e8649ead0701ea2"><td class="memTemplParams" colspan="2">template&lt;typename BidirIter1 , typename BidirIter2 &gt; </td></tr>
<tr class="memitem:a53fd2bc273dba3758e8649ead0701ea2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a53fd2bc273dba3758e8649ead0701ea2">etl::copy_backward</a> (BidirIter1 first, BidirIter1 last, BidirIter2 d_last) -&gt; BidirIter2</td></tr>
<tr class="memdesc:a53fd2bc273dba3758e8649ead0701ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range, defined by [first, last), to another range ending at d_last. The elements are copied in reverse order (the last element is copied first), but their relative order is preserved.  <a href="namespaceetl.html#a53fd2bc273dba3758e8649ead0701ea2">More...</a><br /></td></tr>
<tr class="separator:a53fd2bc273dba3758e8649ead0701ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9817c300a21e9f09695a8b8a3a40db"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIter , typename OutputIter &gt; </td></tr>
<tr class="memitem:adc9817c300a21e9f09695a8b8a3a40db"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adc9817c300a21e9f09695a8b8a3a40db">etl::rotate_copy</a> (ForwardIter first, ForwardIter n_first, ForwardIter last, OutputIter destination) -&gt; OutputIter</td></tr>
<tr class="memdesc:adc9817c300a21e9f09695a8b8a3a40db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range [ first , last ), to another range beginning at destination in such a way, that the element n_first becomes the first element of the new range and n_first - 1 becomes the last element.  <a href="namespaceetl.html#adc9817c300a21e9f09695a8b8a3a40db">More...</a><br /></td></tr>
<tr class="separator:adc9817c300a21e9f09695a8b8a3a40db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0512bc5f4147d65b4de29c284371f385"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIter , typename T &gt; </td></tr>
<tr class="memitem:a0512bc5f4147d65b4de29c284371f385"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0512bc5f4147d65b4de29c284371f385">etl::fill</a> (ForwardIter first, ForwardIter last, T const &amp;value) -&gt; void</td></tr>
<tr class="memdesc:a0512bc5f4147d65b4de29c284371f385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the given value to the elements in the range [first, last).  <a href="namespaceetl.html#a0512bc5f4147d65b4de29c284371f385">More...</a><br /></td></tr>
<tr class="separator:a0512bc5f4147d65b4de29c284371f385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0dfc7b3bab2792cb392c0453abdb2d"><td class="memTemplParams" colspan="2">template&lt;typename OutputIter , typename Size , typename T &gt; </td></tr>
<tr class="memitem:a9b0dfc7b3bab2792cb392c0453abdb2d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9b0dfc7b3bab2792cb392c0453abdb2d">etl::fill_n</a> (OutputIter first, Size count, T const &amp;value) -&gt; OutputIter</td></tr>
<tr class="memdesc:a9b0dfc7b3bab2792cb392c0453abdb2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the given value to the first count elements in the range beginning at first if count &gt; 0. Does nothing otherwise.  <a href="namespaceetl.html#a9b0dfc7b3bab2792cb392c0453abdb2d">More...</a><br /></td></tr>
<tr class="separator:a9b0dfc7b3bab2792cb392c0453abdb2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5643f3eb1ca8c4e0028a62ab747962fb"><td class="memTemplParams" colspan="2">template&lt;typename InputIter1 , typename InputIter2 , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:a5643f3eb1ca8c4e0028a62ab747962fb"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5643f3eb1ca8c4e0028a62ab747962fb">etl::equal</a> (InputIter1 first1, InputIter1 last1, InputIter2 first2, BinaryPredicate p) -&gt; bool</td></tr>
<tr class="memdesc:a5643f3eb1ca8c4e0028a62ab747962fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the range [first1, last1) is equal to the range [first2, first2.  <a href="namespaceetl.html#a5643f3eb1ca8c4e0028a62ab747962fb">More...</a><br /></td></tr>
<tr class="separator:a5643f3eb1ca8c4e0028a62ab747962fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c78fffa2308b92923b533f16971a0c5"><td class="memTemplParams" colspan="2">template&lt;typename InputIter1 , typename InputIter2 &gt; </td></tr>
<tr class="memitem:a3c78fffa2308b92923b533f16971a0c5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3c78fffa2308b92923b533f16971a0c5">etl::equal</a> (InputIter1 first1, InputIter1 last1, InputIter2 first2) -&gt; bool</td></tr>
<tr class="memdesc:a3c78fffa2308b92923b533f16971a0c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the range [first1, last1) is equal to the range [first2, first2.  <a href="namespaceetl.html#a3c78fffa2308b92923b533f16971a0c5">More...</a><br /></td></tr>
<tr class="separator:a3c78fffa2308b92923b533f16971a0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6009b4f377f7a386dc3ee9d5217604"><td class="memTemplParams" colspan="2">template&lt;typename InputIter1 , typename InputIter2 , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:a6a6009b4f377f7a386dc3ee9d5217604"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6a6009b4f377f7a386dc3ee9d5217604">etl::equal</a> (InputIter1 first1, InputIter1 last1, InputIter2 first2, InputIter2 last2, BinaryPredicate p) -&gt; bool</td></tr>
<tr class="memdesc:a6a6009b4f377f7a386dc3ee9d5217604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the range [first1, last1) is equal to the range [first2, last2), and false otherwise.  <a href="namespaceetl.html#a6a6009b4f377f7a386dc3ee9d5217604">More...</a><br /></td></tr>
<tr class="separator:a6a6009b4f377f7a386dc3ee9d5217604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9b428e2e900d9c2c9106b699464412"><td class="memTemplParams" colspan="2">template&lt;typename InputIter1 , typename InputIter2 &gt; </td></tr>
<tr class="memitem:abc9b428e2e900d9c2c9106b699464412"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abc9b428e2e900d9c2c9106b699464412">etl::equal</a> (InputIter1 first1, InputIter1 last1, InputIter2 first2, InputIter2 last2) -&gt; bool</td></tr>
<tr class="memdesc:abc9b428e2e900d9c2c9106b699464412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the range [first1, last1) is equal to the range [first2, last2), and false otherwise.  <a href="namespaceetl.html#abc9b428e2e900d9c2c9106b699464412">More...</a><br /></td></tr>
<tr class="separator:abc9b428e2e900d9c2c9106b699464412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bf6272342dcb53c476905d305d5253"><td class="memTemplParams" colspan="2">template&lt;typename InputIter1 , typename InputIter2 , typename Compare &gt; </td></tr>
<tr class="memitem:a22bf6272342dcb53c476905d305d5253"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a22bf6272342dcb53c476905d305d5253">etl::lexicographical_compare</a> (InputIter1 first1, InputIter1 last1, InputIter2 first2, InputIter2 last2, Compare comp) -&gt; bool</td></tr>
<tr class="memdesc:a22bf6272342dcb53c476905d305d5253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the first range [first1, last1) is lexicographically less than the second range [first2, last2). Elements are compared using the given binary comparison function comp.  <a href="namespaceetl.html#a22bf6272342dcb53c476905d305d5253">More...</a><br /></td></tr>
<tr class="separator:a22bf6272342dcb53c476905d305d5253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b18462d7f6dac998d3af5eaf17d1dca"><td class="memTemplParams" colspan="2">template&lt;typename InputIter1 , typename InputIter2 &gt; </td></tr>
<tr class="memitem:a1b18462d7f6dac998d3af5eaf17d1dca"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1b18462d7f6dac998d3af5eaf17d1dca">etl::lexicographical_compare</a> (InputIter1 first1, InputIter1 last1, InputIter2 first2, InputIter2 last2) -&gt; bool</td></tr>
<tr class="memdesc:a1b18462d7f6dac998d3af5eaf17d1dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the first range [first1, last1) is lexicographically less than the second range [first2, last2). Elements are compared using operator&lt;.  <a href="namespaceetl.html#a1b18462d7f6dac998d3af5eaf17d1dca">More...</a><br /></td></tr>
<tr class="separator:a1b18462d7f6dac998d3af5eaf17d1dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed5055c5289238946a6c7bafe150497"><td class="memTemplParams" colspan="2">template&lt;typename RandomIter , typename Compare &gt; </td></tr>
<tr class="memitem:a8ed5055c5289238946a6c7bafe150497"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8ed5055c5289238946a6c7bafe150497">etl::sort</a> (RandomIter first, RandomIter last, Compare comp) -&gt; void</td></tr>
<tr class="memdesc:a8ed5055c5289238946a6c7bafe150497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range [first, last) in non-descending order. The order of equal elements is not guaranteed to be preserved.  <a href="namespaceetl.html#a8ed5055c5289238946a6c7bafe150497">More...</a><br /></td></tr>
<tr class="separator:a8ed5055c5289238946a6c7bafe150497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7957b9c32908c1d07cffc279885835"><td class="memTemplParams" colspan="2">template&lt;typename RandomIter &gt; </td></tr>
<tr class="memitem:acd7957b9c32908c1d07cffc279885835"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#acd7957b9c32908c1d07cffc279885835">etl::sort</a> (RandomIter first, RandomIter last) -&gt; void</td></tr>
<tr class="memdesc:acd7957b9c32908c1d07cffc279885835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range [first, last) in non-descending order. The order of equal elements is not guaranteed to be preserved. Elements are compared using operator&lt;.  <a href="namespaceetl.html#acd7957b9c32908c1d07cffc279885835">More...</a><br /></td></tr>
<tr class="separator:acd7957b9c32908c1d07cffc279885835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d06375f6c6ee1b6ffe30e433b5ca742"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIter &gt; </td></tr>
<tr class="memitem:a3d06375f6c6ee1b6ffe30e433b5ca742"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3d06375f6c6ee1b6ffe30e433b5ca742">etl::is_sorted_until</a> (ForwardIter first, ForwardIter last) -&gt; ForwardIter</td></tr>
<tr class="memdesc:a3d06375f6c6ee1b6ffe30e433b5ca742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Examines the range [first, last) and finds the largest range beginning at first in which the elements are sorted in non-descending order. Elements are compared using operator&lt;.  <a href="namespaceetl.html#a3d06375f6c6ee1b6ffe30e433b5ca742">More...</a><br /></td></tr>
<tr class="separator:a3d06375f6c6ee1b6ffe30e433b5ca742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8cd072db84b3726ff5ff9734f09c81e"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIter , typename Compare &gt; </td></tr>
<tr class="memitem:af8cd072db84b3726ff5ff9734f09c81e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af8cd072db84b3726ff5ff9734f09c81e">etl::is_sorted_until</a> (ForwardIter first, ForwardIter last, Compare comp) -&gt; ForwardIter</td></tr>
<tr class="memdesc:af8cd072db84b3726ff5ff9734f09c81e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Examines the range [first, last) and finds the largest range beginning at first in which the elements are sorted in non-descending order. Elements are compared using the given binary comparison function comp.  <a href="namespaceetl.html#af8cd072db84b3726ff5ff9734f09c81e">More...</a><br /></td></tr>
<tr class="separator:af8cd072db84b3726ff5ff9734f09c81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab088a74d056814b99f64cba7c31cef"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIter &gt; </td></tr>
<tr class="memitem:aaab088a74d056814b99f64cba7c31cef"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aaab088a74d056814b99f64cba7c31cef">etl::is_sorted</a> (ForwardIter first, ForwardIter last) -&gt; bool</td></tr>
<tr class="memdesc:aaab088a74d056814b99f64cba7c31cef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the elements in range [first, last) are sorted in non-descending order. Elements are compared using operator&lt;.  <a href="namespaceetl.html#aaab088a74d056814b99f64cba7c31cef">More...</a><br /></td></tr>
<tr class="separator:aaab088a74d056814b99f64cba7c31cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a93174fd55dba4449e55dd3accbd299"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIter , typename Compare &gt; </td></tr>
<tr class="memitem:a5a93174fd55dba4449e55dd3accbd299"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5a93174fd55dba4449e55dd3accbd299">etl::is_sorted</a> (ForwardIter first, ForwardIter last, Compare comp) -&gt; bool</td></tr>
<tr class="memdesc:a5a93174fd55dba4449e55dd3accbd299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the elements in range [ first , last ) are sorted in non-descending order. Elements are compared using the given binary comparison function comp.  <a href="namespaceetl.html#a5a93174fd55dba4449e55dd3accbd299">More...</a><br /></td></tr>
<tr class="separator:a5a93174fd55dba4449e55dd3accbd299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89997aba186b70f2d457898409efb285"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIter , typename T , typename Compare &gt; </td></tr>
<tr class="memitem:a89997aba186b70f2d457898409efb285"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a89997aba186b70f2d457898409efb285">etl::lower_bound</a> (ForwardIter first, ForwardIter last, T const &amp;value, Compare comp) noexcept -&gt; ForwardIter</td></tr>
<tr class="memdesc:a89997aba186b70f2d457898409efb285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element in the range [first, last) that is not less than (i.e. greater or equal to) value, or last if no such element is found.  <a href="namespaceetl.html#a89997aba186b70f2d457898409efb285">More...</a><br /></td></tr>
<tr class="separator:a89997aba186b70f2d457898409efb285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d4571402e3c6c23bbbf5b22987c9b5"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIter , typename T &gt; </td></tr>
<tr class="memitem:a11d4571402e3c6c23bbbf5b22987c9b5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a11d4571402e3c6c23bbbf5b22987c9b5">etl::lower_bound</a> (ForwardIter first, ForwardIter last, T const &amp;value) noexcept -&gt; ForwardIter</td></tr>
<tr class="memdesc:a11d4571402e3c6c23bbbf5b22987c9b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element in the range [first, last) that is not less than (i.e. greater or equal to) value, or last if no such element is found.  <a href="namespaceetl.html#a11d4571402e3c6c23bbbf5b22987c9b5">More...</a><br /></td></tr>
<tr class="separator:a11d4571402e3c6c23bbbf5b22987c9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903280b11e2556ae82b7ce83664c2493"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIter , typename T , typename Compare &gt; </td></tr>
<tr class="memitem:a903280b11e2556ae82b7ce83664c2493"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a903280b11e2556ae82b7ce83664c2493">etl::upper_bound</a> (ForwardIter first, ForwardIter last, T const &amp;value, Compare comp) -&gt; ForwardIter</td></tr>
<tr class="memdesc:a903280b11e2556ae82b7ce83664c2493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element in the range [ first , last ) that is greater than value, or last if no such element is found.  <a href="namespaceetl.html#a903280b11e2556ae82b7ce83664c2493">More...</a><br /></td></tr>
<tr class="separator:a903280b11e2556ae82b7ce83664c2493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493b1a0e8c11135ffb3bedb15ec44026"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIter , typename T &gt; </td></tr>
<tr class="memitem:a493b1a0e8c11135ffb3bedb15ec44026"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a493b1a0e8c11135ffb3bedb15ec44026">etl::upper_bound</a> (ForwardIter first, ForwardIter last, T const &amp;value) -&gt; ForwardIter</td></tr>
<tr class="memdesc:a493b1a0e8c11135ffb3bedb15ec44026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element in the range [ first , last ) that is greater than value, or last if no such element is found.  <a href="namespaceetl.html#a493b1a0e8c11135ffb3bedb15ec44026">More...</a><br /></td></tr>
<tr class="separator:a493b1a0e8c11135ffb3bedb15ec44026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e45f8eb56e59e6cd591cab63654758"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename T , typename Compare &gt; </td></tr>
<tr class="memitem:ad9e45f8eb56e59e6cd591cab63654758"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad9e45f8eb56e59e6cd591cab63654758">etl::equal_range</a> (ForwardIt first, ForwardIt last, T const &amp;value, Compare comp) -&gt; <a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; ForwardIt, ForwardIt &gt;</td></tr>
<tr class="memdesc:ad9e45f8eb56e59e6cd591cab63654758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements equivalent to value in the range [first, last).  <a href="namespaceetl.html#ad9e45f8eb56e59e6cd591cab63654758">More...</a><br /></td></tr>
<tr class="separator:ad9e45f8eb56e59e6cd591cab63654758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab395a58a237abfb479d2ae0163afb29"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename T &gt; </td></tr>
<tr class="memitem:aab395a58a237abfb479d2ae0163afb29"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aab395a58a237abfb479d2ae0163afb29">etl::equal_range</a> (ForwardIt first, ForwardIt last, T const &amp;value) -&gt; <a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; ForwardIt, ForwardIt &gt;</td></tr>
<tr class="memdesc:aab395a58a237abfb479d2ae0163afb29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements equivalent to value in the range [first, last).  <a href="namespaceetl.html#aab395a58a237abfb479d2ae0163afb29">More...</a><br /></td></tr>
<tr class="separator:aab395a58a237abfb479d2ae0163afb29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb582735f4f25812f76c14383c62b35"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIter , typename T , typename Compare &gt; </td></tr>
<tr class="memitem:adbb582735f4f25812f76c14383c62b35"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adbb582735f4f25812f76c14383c62b35">etl::binary_search</a> (ForwardIter first, ForwardIter last, T const &amp;value, Compare comp) -&gt; bool</td></tr>
<tr class="memdesc:adbb582735f4f25812f76c14383c62b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an element equivalent to value appears within the range [ first , last ).  <a href="namespaceetl.html#adbb582735f4f25812f76c14383c62b35">More...</a><br /></td></tr>
<tr class="separator:adbb582735f4f25812f76c14383c62b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b019f36dc291f87d2904fe1d5d7b261"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIter , class T &gt; </td></tr>
<tr class="memitem:a8b019f36dc291f87d2904fe1d5d7b261"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8b019f36dc291f87d2904fe1d5d7b261">etl::binary_search</a> (ForwardIter first, ForwardIter last, T const &amp;value) -&gt; bool</td></tr>
<tr class="memdesc:a8b019f36dc291f87d2904fe1d5d7b261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an element equivalent to value appears within the range [ first , last ).  <a href="namespaceetl.html#a8b019f36dc291f87d2904fe1d5d7b261">More...</a><br /></td></tr>
<tr class="separator:a8b019f36dc291f87d2904fe1d5d7b261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1982436ea3e6e16a1d3aac993ffb0b6c"><td class="memTemplParams" colspan="2">template&lt;typename InputIter1 , typename InputIter2 &gt; </td></tr>
<tr class="memitem:a1982436ea3e6e16a1d3aac993ffb0b6c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1982436ea3e6e16a1d3aac993ffb0b6c">etl::includes</a> (InputIter1 first1, InputIter1 last1, InputIter2 first2, InputIter2 last2) -&gt; bool</td></tr>
<tr class="memdesc:a1982436ea3e6e16a1d3aac993ffb0b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the sorted range [first2, last2) is a subsequence of the sorted range [first1, last1). Both ranges must be sorted with operator&lt;.  <a href="namespaceetl.html#a1982436ea3e6e16a1d3aac993ffb0b6c">More...</a><br /></td></tr>
<tr class="separator:a1982436ea3e6e16a1d3aac993ffb0b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43bd1441d3f2aa745a450e2a5789f2d8"><td class="memTemplParams" colspan="2">template&lt;typename InputIter1 , typename InputIter2 , typename Compare &gt; </td></tr>
<tr class="memitem:a43bd1441d3f2aa745a450e2a5789f2d8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a43bd1441d3f2aa745a450e2a5789f2d8">etl::includes</a> (InputIter1 first1, InputIter1 last1, InputIter2 first2, InputIter2 last2, Compare comp) -&gt; bool</td></tr>
<tr class="memdesc:a43bd1441d3f2aa745a450e2a5789f2d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the sorted range [first2, last2) is a subsequence of the sorted range [first1, last1). Both ranges must be sorted with the given comparison function comp.  <a href="namespaceetl.html#a43bd1441d3f2aa745a450e2a5789f2d8">More...</a><br /></td></tr>
<tr class="separator:a43bd1441d3f2aa745a450e2a5789f2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
