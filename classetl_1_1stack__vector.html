<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>taetl: etl::stack_vector&lt; ValueType, Capacity &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">taetl
   &#160;<span id="projectnumber">0.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceetl.html">etl</a></li><li class="navelem"><a class="el" href="classetl_1_1stack__vector.html">stack_vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classetl_1_1stack__vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">etl::stack_vector&lt; ValueType, Capacity &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="vector_8hpp_source.html">vector.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1ca734bd8408cb6bddf90faf61cde4f3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#a1ca734bd8408cb6bddf90faf61cde4f3">value_type</a> = ValueType</td></tr>
<tr class="separator:a1ca734bd8408cb6bddf90faf61cde4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1e176acdd71046a45faf78c0046ec3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#a4e1e176acdd71046a45faf78c0046ec3">size_type</a> = <a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">etl::size_t</a></td></tr>
<tr class="separator:a4e1e176acdd71046a45faf78c0046ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4472b1b3a6cff3426a8cf04a32205e70"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#a4472b1b3a6cff3426a8cf04a32205e70">difference_type</a> = <a class="el" href="namespaceetl.html#a56e0abf50b318376b511f461e8baca33">etl::ptrdiff_t</a></td></tr>
<tr class="separator:a4472b1b3a6cff3426a8cf04a32205e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfacec365ce3a796fd3292001cd50456"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#adfacec365ce3a796fd3292001cd50456">reference</a> = ValueType &amp;</td></tr>
<tr class="separator:adfacec365ce3a796fd3292001cd50456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1fdca98a052d969cb4702e7264acd8e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#ae1fdca98a052d969cb4702e7264acd8e">const_reference</a> = ValueType const  &amp;</td></tr>
<tr class="separator:ae1fdca98a052d969cb4702e7264acd8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4437920bc54dad56381af5fcd1892f60"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#a4437920bc54dad56381af5fcd1892f60">pointer</a> = ValueType *</td></tr>
<tr class="separator:a4437920bc54dad56381af5fcd1892f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dbdecb1e3c014501d922997dbb13f52"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#a2dbdecb1e3c014501d922997dbb13f52">const_pointer</a> = ValueType const  *</td></tr>
<tr class="separator:a2dbdecb1e3c014501d922997dbb13f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7795d3ad62d408d0776260e4731bdcdb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#a7795d3ad62d408d0776260e4731bdcdb">iterator</a> = ValueType *</td></tr>
<tr class="separator:a7795d3ad62d408d0776260e4731bdcdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a646b1d059790ed521c54df2b6298bd6b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#a646b1d059790ed521c54df2b6298bd6b">const_iterator</a> = ValueType const  *</td></tr>
<tr class="separator:a646b1d059790ed521c54df2b6298bd6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2750d30d33c6a5f19feedf1fd59a7001"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#a2750d30d33c6a5f19feedf1fd59a7001">stack_vector</a> () noexcept=default</td></tr>
<tr class="memdesc:a2750d30d33c6a5f19feedf1fd59a7001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. Constructs an empty container.  <a href="#a2750d30d33c6a5f19feedf1fd59a7001">More...</a><br /></td></tr>
<tr class="separator:a2750d30d33c6a5f19feedf1fd59a7001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09cba3fa3806220e983a0c61fb0049a7"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#a09cba3fa3806220e983a0c61fb0049a7">stack_vector</a> (<a class="el" href="classetl_1_1stack__vector.html#a4e1e176acdd71046a45faf78c0046ec3">size_type</a> <a class="el" href="namespaceetl.html#afe8c29a359a0bffc469225b6aeb0ae64">count</a>)</td></tr>
<tr class="memdesc:a09cba3fa3806220e983a0c61fb0049a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with count default-inserted instances of T. No copies are made.  <a href="#a09cba3fa3806220e983a0c61fb0049a7">More...</a><br /></td></tr>
<tr class="separator:a09cba3fa3806220e983a0c61fb0049a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadcc74e1266dcf3cb58404d775069e5f"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#aadcc74e1266dcf3cb58404d775069e5f">stack_vector</a> (<a class="el" href="classetl_1_1stack__vector.html#a4e1e176acdd71046a45faf78c0046ec3">size_type</a> <a class="el" href="namespaceetl.html#afe8c29a359a0bffc469225b6aeb0ae64">count</a>, <a class="el" href="classetl_1_1stack__vector.html#ae1fdca98a052d969cb4702e7264acd8e">const_reference</a> value)</td></tr>
<tr class="memdesc:aadcc74e1266dcf3cb58404d775069e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with count copies of elements with value value.  <a href="#aadcc74e1266dcf3cb58404d775069e5f">More...</a><br /></td></tr>
<tr class="separator:aadcc74e1266dcf3cb58404d775069e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf79ee148b5175b49cee2dca0e3df71"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#afcf79ee148b5175b49cee2dca0e3df71">stack_vector</a> (<a class="el" href="classetl_1_1stack__vector.html">stack_vector</a> const &amp;other)</td></tr>
<tr class="memdesc:afcf79ee148b5175b49cee2dca0e3df71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. Constructs the container with the copy of the contents of other.  <a href="#afcf79ee148b5175b49cee2dca0e3df71">More...</a><br /></td></tr>
<tr class="separator:afcf79ee148b5175b49cee2dca0e3df71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17156b2cc758cf51899fe0f5c93c812"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#ac17156b2cc758cf51899fe0f5c93c812">stack_vector</a> (<a class="el" href="classetl_1_1stack__vector.html">stack_vector</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:ac17156b2cc758cf51899fe0f5c93c812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. Constructs the container with the contents of other using move semantics. Allocator is obtained by move-construction from the allocator belonging to other. After the move, other is guaranteed to be <a class="el" href="classetl_1_1stack__vector.html#a2bc87e62b9bdf133d7ef34a836413f92" title="Checks if the container has no elements, i.e. whether begin() == end(). ">empty()</a>.  <a href="#ac17156b2cc758cf51899fe0f5c93c812">More...</a><br /></td></tr>
<tr class="separator:ac17156b2cc758cf51899fe0f5c93c812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72901b511fbe64245b5d5d50009aefb"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#af72901b511fbe64245b5d5d50009aefb">operator=</a> (<a class="el" href="classetl_1_1stack__vector.html">stack_vector</a> const &amp;other) -&gt; <a class="el" href="classetl_1_1stack__vector.html">stack_vector</a> &amp;</td></tr>
<tr class="memdesc:af72901b511fbe64245b5d5d50009aefb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents of the container. Copy assignment operator. Replaces the contents with a copy of the contents of other.  <a href="#af72901b511fbe64245b5d5d50009aefb">More...</a><br /></td></tr>
<tr class="separator:af72901b511fbe64245b5d5d50009aefb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e217a2f0481f574a17b2ccd1f89f08c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#a3e217a2f0481f574a17b2ccd1f89f08c">operator=</a> (<a class="el" href="classetl_1_1stack__vector.html">stack_vector</a> &amp;&amp;other) noexcept -&gt; <a class="el" href="classetl_1_1stack__vector.html">stack_vector</a> &amp;</td></tr>
<tr class="memdesc:a3e217a2f0481f574a17b2ccd1f89f08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents of the container. Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in other is moved from other into this container). other is in a valid but unspecified state afterwards.  <a href="#a3e217a2f0481f574a17b2ccd1f89f08c">More...</a><br /></td></tr>
<tr class="separator:a3e217a2f0481f574a17b2ccd1f89f08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcaf9313662216accfadc7fb4f3a7476"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#afcaf9313662216accfadc7fb4f3a7476">~stack_vector</a> ()</td></tr>
<tr class="memdesc:afcaf9313662216accfadc7fb4f3a7476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructs the vector. The destructors of the elements are called and the used storage is deallocated. Note, that if the elements are pointers, the pointed-to objects are not destroyed.  <a href="#afcaf9313662216accfadc7fb4f3a7476">More...</a><br /></td></tr>
<tr class="separator:afcaf9313662216accfadc7fb4f3a7476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e5eb3ddcd1a144d16b5e677179ad68"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#a84e5eb3ddcd1a144d16b5e677179ad68">assign</a> (<a class="el" href="classetl_1_1stack__vector.html#a4e1e176acdd71046a45faf78c0046ec3">size_type</a> <a class="el" href="namespaceetl.html#afe8c29a359a0bffc469225b6aeb0ae64">count</a>, <a class="el" href="classetl_1_1stack__vector.html#ae1fdca98a052d969cb4702e7264acd8e">const_reference</a> value) -&gt; void</td></tr>
<tr class="memdesc:a84e5eb3ddcd1a144d16b5e677179ad68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents of the container. Replaces the contents with count copies of value value.  <a href="#a84e5eb3ddcd1a144d16b5e677179ad68">More...</a><br /></td></tr>
<tr class="separator:a84e5eb3ddcd1a144d16b5e677179ad68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45fe1c02649b334984307dcf6fdd3d7c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#a45fe1c02649b334984307dcf6fdd3d7c">front</a> () -&gt; <a class="el" href="classetl_1_1stack__vector.html#adfacec365ce3a796fd3292001cd50456">reference</a></td></tr>
<tr class="memdesc:a45fe1c02649b334984307dcf6fdd3d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the container. Calling front on an empty container is undefined.  <a href="#a45fe1c02649b334984307dcf6fdd3d7c">More...</a><br /></td></tr>
<tr class="separator:a45fe1c02649b334984307dcf6fdd3d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe255e38ea6b1a4de2a810762de1822"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#aebe255e38ea6b1a4de2a810762de1822">front</a> () const -&gt; <a class="el" href="classetl_1_1stack__vector.html#ae1fdca98a052d969cb4702e7264acd8e">const_reference</a></td></tr>
<tr class="memdesc:aebe255e38ea6b1a4de2a810762de1822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the container. Calling front on an empty container is undefined.  <a href="#aebe255e38ea6b1a4de2a810762de1822">More...</a><br /></td></tr>
<tr class="separator:aebe255e38ea6b1a4de2a810762de1822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c65f48f57c9ef07d4ba3c5c8d353698"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#a4c65f48f57c9ef07d4ba3c5c8d353698">back</a> () -&gt; <a class="el" href="classetl_1_1stack__vector.html#adfacec365ce3a796fd3292001cd50456">reference</a></td></tr>
<tr class="memdesc:a4c65f48f57c9ef07d4ba3c5c8d353698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to the last element in the container. Calling back on an empty container causes undefined behavior.  <a href="#a4c65f48f57c9ef07d4ba3c5c8d353698">More...</a><br /></td></tr>
<tr class="separator:a4c65f48f57c9ef07d4ba3c5c8d353698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcef2403b3bee9a808a118d5ecfc9943"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#adcef2403b3bee9a808a118d5ecfc9943">back</a> () const -&gt; <a class="el" href="classetl_1_1stack__vector.html#ae1fdca98a052d969cb4702e7264acd8e">const_reference</a></td></tr>
<tr class="memdesc:adcef2403b3bee9a808a118d5ecfc9943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to the last element in the container. Calling back on an empty container causes undefined behavior.  <a href="#adcef2403b3bee9a808a118d5ecfc9943">More...</a><br /></td></tr>
<tr class="separator:adcef2403b3bee9a808a118d5ecfc9943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171c07254ef15cacd465f7ed67b2afb4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#a171c07254ef15cacd465f7ed67b2afb4">operator[]</a> (<a class="el" href="classetl_1_1stack__vector.html#a4e1e176acdd71046a45faf78c0046ec3">size_type</a> pos) -&gt; <a class="el" href="classetl_1_1stack__vector.html#adfacec365ce3a796fd3292001cd50456">reference</a></td></tr>
<tr class="memdesc:a171c07254ef15cacd465f7ed67b2afb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location pos. No bounds checking is performed.  <a href="#a171c07254ef15cacd465f7ed67b2afb4">More...</a><br /></td></tr>
<tr class="separator:a171c07254ef15cacd465f7ed67b2afb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad722dce0d1b9ae2b59159c57c6ae5c82"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#ad722dce0d1b9ae2b59159c57c6ae5c82">operator[]</a> (<a class="el" href="classetl_1_1stack__vector.html#a4e1e176acdd71046a45faf78c0046ec3">size_type</a> pos) const -&gt; <a class="el" href="classetl_1_1stack__vector.html#ae1fdca98a052d969cb4702e7264acd8e">const_reference</a></td></tr>
<tr class="memdesc:ad722dce0d1b9ae2b59159c57c6ae5c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location pos. No bounds checking is performed.  <a href="#ad722dce0d1b9ae2b59159c57c6ae5c82">More...</a><br /></td></tr>
<tr class="separator:ad722dce0d1b9ae2b59159c57c6ae5c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5ae253abebbcee100d7addea9a0554"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#afd5ae253abebbcee100d7addea9a0554">at</a> (<a class="el" href="classetl_1_1stack__vector.html#a4e1e176acdd71046a45faf78c0046ec3">size_type</a> pos) -&gt; <a class="el" href="classetl_1_1stack__vector.html#adfacec365ce3a796fd3292001cd50456">reference</a></td></tr>
<tr class="memdesc:afd5ae253abebbcee100d7addea9a0554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location pos, with bounds checking. If pos is not within the range of the container, an exception of type etl::out_of_range is thrown.  <a href="#afd5ae253abebbcee100d7addea9a0554">More...</a><br /></td></tr>
<tr class="separator:afd5ae253abebbcee100d7addea9a0554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548d9435366a786e26a7a6045ec0de41"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#a548d9435366a786e26a7a6045ec0de41">at</a> (<a class="el" href="classetl_1_1stack__vector.html#a4e1e176acdd71046a45faf78c0046ec3">size_type</a> pos) const -&gt; <a class="el" href="classetl_1_1stack__vector.html#ae1fdca98a052d969cb4702e7264acd8e">const_reference</a></td></tr>
<tr class="memdesc:a548d9435366a786e26a7a6045ec0de41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location pos, with bounds checking. If pos is not within the range of the container, an exception of type etl::out_of_range is thrown.  <a href="#a548d9435366a786e26a7a6045ec0de41">More...</a><br /></td></tr>
<tr class="separator:a548d9435366a786e26a7a6045ec0de41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f5ea8795ece00b43de069e4cdcd6ec7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#a2f5ea8795ece00b43de069e4cdcd6ec7">data</a> () noexcept -&gt; <a class="el" href="classetl_1_1stack__vector.html#a4437920bc54dad56381af5fcd1892f60">pointer</a></td></tr>
<tr class="memdesc:a2f5ea8795ece00b43de069e4cdcd6ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the underlying array serving as element storage. The pointer is such that range [<a class="el" href="classetl_1_1stack__vector.html#a2f5ea8795ece00b43de069e4cdcd6ec7" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a>; <a class="el" href="classetl_1_1stack__vector.html#a2f5ea8795ece00b43de069e4cdcd6ec7" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a> + <a class="el" href="classetl_1_1stack__vector.html#adce1d5298e676ae4a4564dac2b000256" title="Returns the number of elements in the container, i.e. etl::distance(begin(), end()). ">size()</a>) is always a valid range, even if the container is empty (<a class="el" href="classetl_1_1stack__vector.html#a2f5ea8795ece00b43de069e4cdcd6ec7" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a> is not dereferenceable in that case).  <a href="#a2f5ea8795ece00b43de069e4cdcd6ec7">More...</a><br /></td></tr>
<tr class="separator:a2f5ea8795ece00b43de069e4cdcd6ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d885379be7f439d112b2b85f85dad9d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#a2d885379be7f439d112b2b85f85dad9d">data</a> () const noexcept -&gt; <a class="el" href="classetl_1_1stack__vector.html#a2dbdecb1e3c014501d922997dbb13f52">const_pointer</a></td></tr>
<tr class="memdesc:a2d885379be7f439d112b2b85f85dad9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the underlying array serving as element storage. The pointer is such that range [<a class="el" href="classetl_1_1stack__vector.html#a2f5ea8795ece00b43de069e4cdcd6ec7" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a>; <a class="el" href="classetl_1_1stack__vector.html#a2f5ea8795ece00b43de069e4cdcd6ec7" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a> + <a class="el" href="classetl_1_1stack__vector.html#adce1d5298e676ae4a4564dac2b000256" title="Returns the number of elements in the container, i.e. etl::distance(begin(), end()). ">size()</a>) is always a valid range, even if the container is empty (<a class="el" href="classetl_1_1stack__vector.html#a2f5ea8795ece00b43de069e4cdcd6ec7" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a> is not dereferenceable in that case).  <a href="#a2d885379be7f439d112b2b85f85dad9d">More...</a><br /></td></tr>
<tr class="separator:a2d885379be7f439d112b2b85f85dad9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879d448e68f2cb8caec8092d8bda2fcc"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#a879d448e68f2cb8caec8092d8bda2fcc">begin</a> () noexcept -&gt; <a class="el" href="classetl_1_1stack__vector.html#a7795d3ad62d408d0776260e4731bdcdb">iterator</a></td></tr>
<tr class="memdesc:a879d448e68f2cb8caec8092d8bda2fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the vector. If the vector is empty, the returned iterator will be equal to <a class="el" href="classetl_1_1stack__vector.html#a500b313a92360836b0b28485c34b9bfc" title="Returns an iterator to the element following the last element of the vector. This element acts as a p...">end()</a>.  <a href="#a879d448e68f2cb8caec8092d8bda2fcc">More...</a><br /></td></tr>
<tr class="separator:a879d448e68f2cb8caec8092d8bda2fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7c22d339bbfa86f1c59d804574d3be"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#aaf7c22d339bbfa86f1c59d804574d3be">begin</a> () const noexcept -&gt; <a class="el" href="classetl_1_1stack__vector.html#a646b1d059790ed521c54df2b6298bd6b">const_iterator</a></td></tr>
<tr class="memdesc:aaf7c22d339bbfa86f1c59d804574d3be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the vector. If the vector is empty, the returned iterator will be equal to <a class="el" href="classetl_1_1stack__vector.html#a500b313a92360836b0b28485c34b9bfc" title="Returns an iterator to the element following the last element of the vector. This element acts as a p...">end()</a>.  <a href="#aaf7c22d339bbfa86f1c59d804574d3be">More...</a><br /></td></tr>
<tr class="separator:aaf7c22d339bbfa86f1c59d804574d3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e50a14971c7dc8f13281f08eef1422"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#a51e50a14971c7dc8f13281f08eef1422">cbegin</a> () const noexcept -&gt; <a class="el" href="classetl_1_1stack__vector.html#a646b1d059790ed521c54df2b6298bd6b">const_iterator</a></td></tr>
<tr class="memdesc:a51e50a14971c7dc8f13281f08eef1422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the vector. If the vector is empty, the returned iterator will be equal to <a class="el" href="classetl_1_1stack__vector.html#a500b313a92360836b0b28485c34b9bfc" title="Returns an iterator to the element following the last element of the vector. This element acts as a p...">end()</a>.  <a href="#a51e50a14971c7dc8f13281f08eef1422">More...</a><br /></td></tr>
<tr class="separator:a51e50a14971c7dc8f13281f08eef1422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500b313a92360836b0b28485c34b9bfc"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#a500b313a92360836b0b28485c34b9bfc">end</a> () noexcept -&gt; <a class="el" href="classetl_1_1stack__vector.html#a7795d3ad62d408d0776260e4731bdcdb">iterator</a></td></tr>
<tr class="memdesc:a500b313a92360836b0b28485c34b9bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the vector. This element acts as a placeholder; attempting to access it results in undefined behavior.  <a href="#a500b313a92360836b0b28485c34b9bfc">More...</a><br /></td></tr>
<tr class="separator:a500b313a92360836b0b28485c34b9bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af5da1b65fee3149db5ce93ce1e345f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#a0af5da1b65fee3149db5ce93ce1e345f">end</a> () const noexcept -&gt; <a class="el" href="classetl_1_1stack__vector.html#a646b1d059790ed521c54df2b6298bd6b">const_iterator</a></td></tr>
<tr class="memdesc:a0af5da1b65fee3149db5ce93ce1e345f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the vector. This element acts as a placeholder; attempting to access it results in undefined behavior.  <a href="#a0af5da1b65fee3149db5ce93ce1e345f">More...</a><br /></td></tr>
<tr class="separator:a0af5da1b65fee3149db5ce93ce1e345f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d9a8c8d64efc03f9a6b6e77b1410c4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#ae3d9a8c8d64efc03f9a6b6e77b1410c4">cend</a> () const noexcept -&gt; <a class="el" href="classetl_1_1stack__vector.html#a646b1d059790ed521c54df2b6298bd6b">const_iterator</a></td></tr>
<tr class="memdesc:ae3d9a8c8d64efc03f9a6b6e77b1410c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the vector. This element acts as a placeholder; attempting to access it results in undefined behavior.  <a href="#ae3d9a8c8d64efc03f9a6b6e77b1410c4">More...</a><br /></td></tr>
<tr class="separator:ae3d9a8c8d64efc03f9a6b6e77b1410c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc87e62b9bdf133d7ef34a836413f92"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#a2bc87e62b9bdf133d7ef34a836413f92">empty</a> () const noexcept -&gt; bool</td></tr>
<tr class="memdesc:a2bc87e62b9bdf133d7ef34a836413f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the container has no elements, i.e. whether <a class="el" href="classetl_1_1stack__vector.html#a879d448e68f2cb8caec8092d8bda2fcc" title="Returns an iterator to the first element of the vector. If the vector is empty, the returned iterator...">begin()</a> == <a class="el" href="classetl_1_1stack__vector.html#a500b313a92360836b0b28485c34b9bfc" title="Returns an iterator to the element following the last element of the vector. This element acts as a p...">end()</a>.  <a href="#a2bc87e62b9bdf133d7ef34a836413f92">More...</a><br /></td></tr>
<tr class="separator:a2bc87e62b9bdf133d7ef34a836413f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce1d5298e676ae4a4564dac2b000256"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#adce1d5298e676ae4a4564dac2b000256">size</a> () const noexcept -&gt; <a class="el" href="classetl_1_1stack__vector.html#a4e1e176acdd71046a45faf78c0046ec3">size_type</a></td></tr>
<tr class="memdesc:adce1d5298e676ae4a4564dac2b000256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the container, i.e. <a class="el" href="namespaceetl.html#aa5fe5f67d90d1f2c3c3d293099fe12e9" title="Returns the number of hops from first to last. ">etl::distance</a>(<a class="el" href="classetl_1_1stack__vector.html#a879d448e68f2cb8caec8092d8bda2fcc" title="Returns an iterator to the first element of the vector. If the vector is empty, the returned iterator...">begin()</a>, <a class="el" href="classetl_1_1stack__vector.html#a500b313a92360836b0b28485c34b9bfc" title="Returns an iterator to the element following the last element of the vector. This element acts as a p...">end()</a>).  <a href="#adce1d5298e676ae4a4564dac2b000256">More...</a><br /></td></tr>
<tr class="separator:adce1d5298e676ae4a4564dac2b000256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38236c7c2de889c209b43d18bc4d604"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#ac38236c7c2de889c209b43d18bc4d604">max_size</a> () const noexcept -&gt; <a class="el" href="classetl_1_1stack__vector.html#a4e1e176acdd71046a45faf78c0046ec3">size_type</a></td></tr>
<tr class="memdesc:ac38236c7c2de889c209b43d18bc4d604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of elements the container is able to hold.  <a href="#ac38236c7c2de889c209b43d18bc4d604">More...</a><br /></td></tr>
<tr class="separator:ac38236c7c2de889c209b43d18bc4d604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd58f36a7dd0d960f19d45facdadf1c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#a4cd58f36a7dd0d960f19d45facdadf1c">capacity</a> () const noexcept -&gt; <a class="el" href="classetl_1_1stack__vector.html#a4e1e176acdd71046a45faf78c0046ec3">size_type</a></td></tr>
<tr class="memdesc:a4cd58f36a7dd0d960f19d45facdadf1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements that the container has currently allocated space for.  <a href="#a4cd58f36a7dd0d960f19d45facdadf1c">More...</a><br /></td></tr>
<tr class="separator:a4cd58f36a7dd0d960f19d45facdadf1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7807e83f8e11cf2b1c5c9e8d59fbea9f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#a7807e83f8e11cf2b1c5c9e8d59fbea9f">clear</a> () noexcept -&gt; void</td></tr>
<tr class="memdesc:a7807e83f8e11cf2b1c5c9e8d59fbea9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all elements from the container. After this call, <a class="el" href="classetl_1_1stack__vector.html#adce1d5298e676ae4a4564dac2b000256" title="Returns the number of elements in the container, i.e. etl::distance(begin(), end()). ">size()</a> returns zero.  <a href="#a7807e83f8e11cf2b1c5c9e8d59fbea9f">More...</a><br /></td></tr>
<tr class="separator:a7807e83f8e11cf2b1c5c9e8d59fbea9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f8d68b05b9df19cbcfb035b3341583"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#ae2f8d68b05b9df19cbcfb035b3341583">push_back</a> (<a class="el" href="classetl_1_1stack__vector.html#ae1fdca98a052d969cb4702e7264acd8e">const_reference</a> element) -&gt; void</td></tr>
<tr class="memdesc:ae2f8d68b05b9df19cbcfb035b3341583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given element to the end of the container. The new element is initialized as a copy.  <a href="#ae2f8d68b05b9df19cbcfb035b3341583">More...</a><br /></td></tr>
<tr class="separator:ae2f8d68b05b9df19cbcfb035b3341583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58fb3a563c682897232b18410ccb44bd"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#a58fb3a563c682897232b18410ccb44bd">push_back</a> (<a class="el" href="classetl_1_1stack__vector.html#a1ca734bd8408cb6bddf90faf61cde4f3">value_type</a> &amp;&amp;element) -&gt; void</td></tr>
<tr class="memdesc:a58fb3a563c682897232b18410ccb44bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given element to the end of the container. The value is moved into the new element.  <a href="#a58fb3a563c682897232b18410ccb44bd">More...</a><br /></td></tr>
<tr class="separator:a58fb3a563c682897232b18410ccb44bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbf5b7a6e23da053a187b704e9ed2d4"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:aadbf5b7a6e23da053a187b704e9ed2d4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classetl_1_1stack__vector.html#aadbf5b7a6e23da053a187b704e9ed2d4">emplace_back</a> (Args &amp;&amp;... args) -&gt; <a class="el" href="classetl_1_1stack__vector.html#adfacec365ce3a796fd3292001cd50456">reference</a></td></tr>
<tr class="memdesc:aadbf5b7a6e23da053a187b704e9ed2d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a new element to the end of the container. The element is constructed using placement-new to construct the element in-place at the location provided by the container. The arguments args... are forwarded to the constructor as etl::forward&lt;Args&gt;(args)....  <a href="#aadbf5b7a6e23da053a187b704e9ed2d4">More...</a><br /></td></tr>
<tr class="separator:aadbf5b7a6e23da053a187b704e9ed2d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class ValueType, size_t Capacity&gt;<br />
class etl::stack_vector&lt; ValueType, Capacity &gt;</h3>

<dl><dt><b>Examples: </b></dt><dd><a class="el" href="algorithm_8cpp-example.html#_a0">algorithm.cpp</a>, <a class="el" href="numeric_8cpp-example.html#_a0">numeric.cpp</a>, and <a class="el" href="vector_8cpp-example.html#_a0">vector.cpp</a>.</dd>
</dl></div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a646b1d059790ed521c54df2b6298bd6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a646b1d059790ed521c54df2b6298bd6b">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::<a class="el" href="classetl_1_1stack__vector.html#a646b1d059790ed521c54df2b6298bd6b">const_iterator</a> =  ValueType const*</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2dbdecb1e3c014501d922997dbb13f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dbdecb1e3c014501d922997dbb13f52">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::<a class="el" href="classetl_1_1stack__vector.html#a2dbdecb1e3c014501d922997dbb13f52">const_pointer</a> =  ValueType const*</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae1fdca98a052d969cb4702e7264acd8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1fdca98a052d969cb4702e7264acd8e">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::<a class="el" href="classetl_1_1stack__vector.html#ae1fdca98a052d969cb4702e7264acd8e">const_reference</a> =  ValueType const&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4472b1b3a6cff3426a8cf04a32205e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4472b1b3a6cff3426a8cf04a32205e70">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::<a class="el" href="classetl_1_1stack__vector.html#a4472b1b3a6cff3426a8cf04a32205e70">difference_type</a> =  <a class="el" href="namespaceetl.html#a56e0abf50b318376b511f461e8baca33">etl::ptrdiff_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7795d3ad62d408d0776260e4731bdcdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7795d3ad62d408d0776260e4731bdcdb">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::<a class="el" href="classetl_1_1stack__vector.html#a7795d3ad62d408d0776260e4731bdcdb">iterator</a> =  ValueType*</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4437920bc54dad56381af5fcd1892f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4437920bc54dad56381af5fcd1892f60">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::<a class="el" href="classetl_1_1stack__vector.html#a4437920bc54dad56381af5fcd1892f60">pointer</a> =  ValueType*</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adfacec365ce3a796fd3292001cd50456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfacec365ce3a796fd3292001cd50456">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::<a class="el" href="classetl_1_1stack__vector.html#adfacec365ce3a796fd3292001cd50456">reference</a> =  ValueType&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e1e176acdd71046a45faf78c0046ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e1e176acdd71046a45faf78c0046ec3">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::<a class="el" href="classetl_1_1stack__vector.html#a4e1e176acdd71046a45faf78c0046ec3">size_type</a> =  <a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">etl::size_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ca734bd8408cb6bddf90faf61cde4f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca734bd8408cb6bddf90faf61cde4f3">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::<a class="el" href="classetl_1_1stack__vector.html#a1ca734bd8408cb6bddf90faf61cde4f3">value_type</a> =  ValueType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2750d30d33c6a5f19feedf1fd59a7001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2750d30d33c6a5f19feedf1fd59a7001">&#9670;&nbsp;</a></span>stack_vector() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::<a class="el" href="classetl_1_1stack__vector.html">stack_vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. Constructs an empty container. </p>

</div>
</div>
<a id="a09cba3fa3806220e983a0c61fb0049a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09cba3fa3806220e983a0c61fb0049a7">&#9670;&nbsp;</a></span>stack_vector() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::<a class="el" href="classetl_1_1stack__vector.html">stack_vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1stack__vector.html#a4e1e176acdd71046a45faf78c0046ec3">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with count default-inserted instances of T. No copies are made. </p>

</div>
</div>
<a id="aadcc74e1266dcf3cb58404d775069e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadcc74e1266dcf3cb58404d775069e5f">&#9670;&nbsp;</a></span>stack_vector() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::<a class="el" href="classetl_1_1stack__vector.html">stack_vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1stack__vector.html#a4e1e176acdd71046a45faf78c0046ec3">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classetl_1_1stack__vector.html#ae1fdca98a052d969cb4702e7264acd8e">const_reference</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with count copies of elements with value value. </p>

</div>
</div>
<a id="afcf79ee148b5175b49cee2dca0e3df71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcf79ee148b5175b49cee2dca0e3df71">&#9670;&nbsp;</a></span>stack_vector() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::<a class="el" href="classetl_1_1stack__vector.html">stack_vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1stack__vector.html">stack_vector</a>&lt; ValueType, Capacity &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. Constructs the container with the copy of the contents of other. </p>

</div>
</div>
<a id="ac17156b2cc758cf51899fe0f5c93c812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17156b2cc758cf51899fe0f5c93c812">&#9670;&nbsp;</a></span>stack_vector() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::<a class="el" href="classetl_1_1stack__vector.html">stack_vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1stack__vector.html">stack_vector</a>&lt; ValueType, Capacity &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. Constructs the container with the contents of other using move semantics. Allocator is obtained by move-construction from the allocator belonging to other. After the move, other is guaranteed to be <a class="el" href="classetl_1_1stack__vector.html#a2bc87e62b9bdf133d7ef34a836413f92" title="Checks if the container has no elements, i.e. whether begin() == end(). ">empty()</a>. </p>

</div>
</div>
<a id="afcaf9313662216accfadc7fb4f3a7476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcaf9313662216accfadc7fb4f3a7476">&#9670;&nbsp;</a></span>~stack_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::~<a class="el" href="classetl_1_1stack__vector.html">stack_vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructs the vector. The destructors of the elements are called and the used storage is deallocated. Note, that if the elements are pointers, the pointed-to objects are not destroyed. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a84e5eb3ddcd1a144d16b5e677179ad68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84e5eb3ddcd1a144d16b5e677179ad68">&#9670;&nbsp;</a></span>assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1stack__vector.html#a4e1e176acdd71046a45faf78c0046ec3">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classetl_1_1stack__vector.html#ae1fdca98a052d969cb4702e7264acd8e">const_reference</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents of the container. Replaces the contents with count copies of value value. </p>

</div>
</div>
<a id="afd5ae253abebbcee100d7addea9a0554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd5ae253abebbcee100d7addea9a0554">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1stack__vector.html#a4e1e176acdd71046a45faf78c0046ec3">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classetl_1_1stack__vector.html#adfacec365ce3a796fd3292001cd50456">reference</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location pos, with bounds checking. If pos is not within the range of the container, an exception of type etl::out_of_range is thrown. </p>

</div>
</div>
<a id="a548d9435366a786e26a7a6045ec0de41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a548d9435366a786e26a7a6045ec0de41">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1stack__vector.html#a4e1e176acdd71046a45faf78c0046ec3">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="classetl_1_1stack__vector.html#ae1fdca98a052d969cb4702e7264acd8e">const_reference</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location pos, with bounds checking. If pos is not within the range of the container, an exception of type etl::out_of_range is thrown. </p>

</div>
</div>
<a id="a4c65f48f57c9ef07d4ba3c5c8d353698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c65f48f57c9ef07d4ba3c5c8d353698">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classetl_1_1stack__vector.html#adfacec365ce3a796fd3292001cd50456">reference</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns reference to the last element in the container. Calling back on an empty container causes undefined behavior. </p>

</div>
</div>
<a id="adcef2403b3bee9a808a118d5ecfc9943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcef2403b3bee9a808a118d5ecfc9943">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classetl_1_1stack__vector.html#ae1fdca98a052d969cb4702e7264acd8e">const_reference</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns reference to the last element in the container. Calling back on an empty container causes undefined behavior. </p>

</div>
</div>
<a id="a879d448e68f2cb8caec8092d8bda2fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a879d448e68f2cb8caec8092d8bda2fcc">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classetl_1_1stack__vector.html#a7795d3ad62d408d0776260e4731bdcdb">iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the vector. If the vector is empty, the returned iterator will be equal to <a class="el" href="classetl_1_1stack__vector.html#a500b313a92360836b0b28485c34b9bfc" title="Returns an iterator to the element following the last element of the vector. This element acts as a p...">end()</a>. </p>

</div>
</div>
<a id="aaf7c22d339bbfa86f1c59d804574d3be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf7c22d339bbfa86f1c59d804574d3be">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classetl_1_1stack__vector.html#a646b1d059790ed521c54df2b6298bd6b">const_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the vector. If the vector is empty, the returned iterator will be equal to <a class="el" href="classetl_1_1stack__vector.html#a500b313a92360836b0b28485c34b9bfc" title="Returns an iterator to the element following the last element of the vector. This element acts as a p...">end()</a>. </p>

</div>
</div>
<a id="a4cd58f36a7dd0d960f19d45facdadf1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd58f36a7dd0d960f19d45facdadf1c">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classetl_1_1stack__vector.html#a4e1e176acdd71046a45faf78c0046ec3">size_type</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements that the container has currently allocated space for. </p>

</div>
</div>
<a id="a51e50a14971c7dc8f13281f08eef1422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e50a14971c7dc8f13281f08eef1422">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classetl_1_1stack__vector.html#a646b1d059790ed521c54df2b6298bd6b">const_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the vector. If the vector is empty, the returned iterator will be equal to <a class="el" href="classetl_1_1stack__vector.html#a500b313a92360836b0b28485c34b9bfc" title="Returns an iterator to the element following the last element of the vector. This element acts as a p...">end()</a>. </p>

</div>
</div>
<a id="ae3d9a8c8d64efc03f9a6b6e77b1410c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3d9a8c8d64efc03f9a6b6e77b1410c4">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classetl_1_1stack__vector.html#a646b1d059790ed521c54df2b6298bd6b">const_iterator</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the vector. This element acts as a placeholder; attempting to access it results in undefined behavior. </p>

</div>
</div>
<a id="a7807e83f8e11cf2b1c5c9e8d59fbea9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7807e83f8e11cf2b1c5c9e8d59fbea9f">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; void
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases all elements from the container. After this call, <a class="el" href="classetl_1_1stack__vector.html#adce1d5298e676ae4a4564dac2b000256" title="Returns the number of elements in the container, i.e. etl::distance(begin(), end()). ">size()</a> returns zero. </p>

</div>
</div>
<a id="a2f5ea8795ece00b43de069e4cdcd6ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f5ea8795ece00b43de069e4cdcd6ec7">&#9670;&nbsp;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classetl_1_1stack__vector.html#a4437920bc54dad56381af5fcd1892f60">pointer</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to the underlying array serving as element storage. The pointer is such that range [<a class="el" href="classetl_1_1stack__vector.html#a2f5ea8795ece00b43de069e4cdcd6ec7" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a>; <a class="el" href="classetl_1_1stack__vector.html#a2f5ea8795ece00b43de069e4cdcd6ec7" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a> + <a class="el" href="classetl_1_1stack__vector.html#adce1d5298e676ae4a4564dac2b000256" title="Returns the number of elements in the container, i.e. etl::distance(begin(), end()). ">size()</a>) is always a valid range, even if the container is empty (<a class="el" href="classetl_1_1stack__vector.html#a2f5ea8795ece00b43de069e4cdcd6ec7" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a> is not dereferenceable in that case). </p>

</div>
</div>
<a id="a2d885379be7f439d112b2b85f85dad9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d885379be7f439d112b2b85f85dad9d">&#9670;&nbsp;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classetl_1_1stack__vector.html#a2dbdecb1e3c014501d922997dbb13f52">const_pointer</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to the underlying array serving as element storage. The pointer is such that range [<a class="el" href="classetl_1_1stack__vector.html#a2f5ea8795ece00b43de069e4cdcd6ec7" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a>; <a class="el" href="classetl_1_1stack__vector.html#a2f5ea8795ece00b43de069e4cdcd6ec7" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a> + <a class="el" href="classetl_1_1stack__vector.html#adce1d5298e676ae4a4564dac2b000256" title="Returns the number of elements in the container, i.e. etl::distance(begin(), end()). ">size()</a>) is always a valid range, even if the container is empty (<a class="el" href="classetl_1_1stack__vector.html#a2f5ea8795ece00b43de069e4cdcd6ec7" title="Returns pointer to the underlying array serving as element storage. The pointer is such that range [d...">data()</a> is not dereferenceable in that case). </p>

</div>
</div>
<a id="aadbf5b7a6e23da053a187b704e9ed2d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadbf5b7a6e23da053a187b704e9ed2d4">&#9670;&nbsp;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classetl_1_1stack__vector.html#adfacec365ce3a796fd3292001cd50456">reference</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a new element to the end of the container. The element is constructed using placement-new to construct the element in-place at the location provided by the container. The arguments args... are forwarded to the constructor as etl::forward&lt;Args&gt;(args).... </p>

</div>
</div>
<a id="a2bc87e62b9bdf133d7ef34a836413f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bc87e62b9bdf133d7ef34a836413f92">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the container has no elements, i.e. whether <a class="el" href="classetl_1_1stack__vector.html#a879d448e68f2cb8caec8092d8bda2fcc" title="Returns an iterator to the first element of the vector. If the vector is empty, the returned iterator...">begin()</a> == <a class="el" href="classetl_1_1stack__vector.html#a500b313a92360836b0b28485c34b9bfc" title="Returns an iterator to the element following the last element of the vector. This element acts as a p...">end()</a>. </p>

</div>
</div>
<a id="a500b313a92360836b0b28485c34b9bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a500b313a92360836b0b28485c34b9bfc">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classetl_1_1stack__vector.html#a7795d3ad62d408d0776260e4731bdcdb">iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the vector. This element acts as a placeholder; attempting to access it results in undefined behavior. </p>

</div>
</div>
<a id="a0af5da1b65fee3149db5ce93ce1e345f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af5da1b65fee3149db5ce93ce1e345f">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classetl_1_1stack__vector.html#a646b1d059790ed521c54df2b6298bd6b">const_iterator</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the vector. This element acts as a placeholder; attempting to access it results in undefined behavior. </p>

</div>
</div>
<a id="a45fe1c02649b334984307dcf6fdd3d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45fe1c02649b334984307dcf6fdd3d7c">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classetl_1_1stack__vector.html#adfacec365ce3a796fd3292001cd50456">reference</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the container. Calling front on an empty container is undefined. </p>

</div>
</div>
<a id="aebe255e38ea6b1a4de2a810762de1822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe255e38ea6b1a4de2a810762de1822">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classetl_1_1stack__vector.html#ae1fdca98a052d969cb4702e7264acd8e">const_reference</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the container. Calling front on an empty container is undefined. </p>

</div>
</div>
<a id="ac38236c7c2de889c209b43d18bc4d604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac38236c7c2de889c209b43d18bc4d604">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classetl_1_1stack__vector.html#a4e1e176acdd71046a45faf78c0046ec3">size_type</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of elements the container is able to hold. </p>

</div>
</div>
<a id="af72901b511fbe64245b5d5d50009aefb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af72901b511fbe64245b5d5d50009aefb">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1stack__vector.html">stack_vector</a>&lt; ValueType, Capacity &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classetl_1_1stack__vector.html">stack_vector</a>&amp;
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents of the container. Copy assignment operator. Replaces the contents with a copy of the contents of other. </p>

</div>
</div>
<a id="a3e217a2f0481f574a17b2ccd1f89f08c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e217a2f0481f574a17b2ccd1f89f08c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1stack__vector.html">stack_vector</a>&lt; ValueType, Capacity &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classetl_1_1stack__vector.html">stack_vector</a>&amp;
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents of the container. Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in other is moved from other into this container). other is in a valid but unspecified state afterwards. </p>

</div>
</div>
<a id="a171c07254ef15cacd465f7ed67b2afb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a171c07254ef15cacd465f7ed67b2afb4">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1stack__vector.html#a4e1e176acdd71046a45faf78c0046ec3">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classetl_1_1stack__vector.html#adfacec365ce3a796fd3292001cd50456">reference</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location pos. No bounds checking is performed. </p>

</div>
</div>
<a id="ad722dce0d1b9ae2b59159c57c6ae5c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad722dce0d1b9ae2b59159c57c6ae5c82">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1stack__vector.html#a4e1e176acdd71046a45faf78c0046ec3">size_type</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="classetl_1_1stack__vector.html#ae1fdca98a052d969cb4702e7264acd8e">const_reference</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location pos. No bounds checking is performed. </p>

</div>
</div>
<a id="ae2f8d68b05b9df19cbcfb035b3341583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f8d68b05b9df19cbcfb035b3341583">&#9670;&nbsp;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1stack__vector.html#ae1fdca98a052d969cb4702e7264acd8e">const_reference</a>&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> -&gt; void
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given element to the end of the container. The new element is initialized as a copy. </p>

</div>
</div>
<a id="a58fb3a563c682897232b18410ccb44bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58fb3a563c682897232b18410ccb44bd">&#9670;&nbsp;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1stack__vector.html#a1ca734bd8408cb6bddf90faf61cde4f3">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> -&gt; void
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given element to the end of the container. The value is moved into the new element. </p>

</div>
</div>
<a id="adce1d5298e676ae4a4564dac2b000256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce1d5298e676ae4a4564dac2b000256">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType, size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classetl_1_1stack__vector.html">etl::stack_vector</a>&lt; ValueType, Capacity &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classetl_1_1stack__vector.html#a4e1e176acdd71046a45faf78c0046ec3">size_type</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the container, i.e. <a class="el" href="namespaceetl.html#aa5fe5f67d90d1f2c3c3d293099fe12e9" title="Returns the number of hops from first to last. ">etl::distance</a>(<a class="el" href="classetl_1_1stack__vector.html#a879d448e68f2cb8caec8092d8bda2fcc" title="Returns an iterator to the first element of the vector. If the vector is empty, the returned iterator...">begin()</a>, <a class="el" href="classetl_1_1stack__vector.html#a500b313a92360836b0b28485c34b9bfc" title="Returns an iterator to the element following the last element of the vector. This element acts as a p...">end()</a>). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>etl/<a class="el" href="vector_8hpp_source.html">vector.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
