<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>taetl: Class Hierarchy</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">taetl
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Class Hierarchy</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock">
<p><a href="inherits.html">Go to the graphical class hierarchy</a></p>
This inheritance list is sorted roughly, but not completely, alphabetically:</div><div class="directory">
<div class="levels">[detail level <span onclick="javascript:toggleLevel(1);">1</span><span onclick="javascript:toggleLevel(2);">2</span><span onclick="javascript:toggleLevel(3);">3</span>]</div><table class="directory">
<tr id="row_0_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1add__const.html" target="_self">etl::add_const&lt; T &gt;</a></td><td class="desc">Provides the member typedef type which is the same as T, except it has a cv-qualifier added (unless T is a function, a reference, or already has this cv-qualifier). Adds const </td></tr>
<tr id="row_1_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1add__cv.html" target="_self">etl::add_cv&lt; T &gt;</a></td><td class="desc">Provides the member typedef type which is the same as T, except it has a cv-qualifier added (unless T is a function, a reference, or already has this cv-qualifier). Adds both const and volatile </td></tr>
<tr id="row_2_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1add__volatile.html" target="_self">etl::add_volatile&lt; T &gt;</a></td><td class="desc">Provides the member typedef type which is the same as T, except it has a cv-qualifier added (unless T is a function, a reference, or already has this cv-qualifier). Adds volatile </td></tr>
<tr id="row_3_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1aligned__storage.html" target="_self">etl::aligned_storage&lt; Len, Align &gt;</a></td><td class="desc">Provides the nested type type, which is a trivial standard-layout type suitable for use as uninitialized storage for any object whose size is at most Len and whose alignment requirement is a divisor of Align </td></tr>
<tr id="row_4_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1array.html" target="_self">etl::array&lt; Type, Size &gt;</a></td><td class="desc">Array class with fixed size capacity </td></tr>
<tr id="row_5_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1array.html" target="_self">etl::array&lt; T, static_cast&lt; size_t &gt;(Z)+1 &gt;</a></td><td class="desc"></td></tr>
<tr id="row_6_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1array.html" target="_self">etl::array&lt; unsigned char, allocated_ &gt;</a></td><td class="desc"></td></tr>
<tr id="row_7_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1basic__string.html" target="_self">etl::basic_string&lt; CharType, Capacity &gt;</a></td><td class="desc">Basic_string class with fixed size capacity </td></tr>
<tr id="row_8_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1basic__string__view.html" target="_self">etl::basic_string_view&lt; CharType, Traits &gt;</a></td><td class="desc">The class template <a class="el" href="classetl_1_1basic__string__view.html" title="The class template basic_string_view describes an object that can refer to a constant contiguous sequ...">basic_string_view</a> describes an object that can refer to a constant contiguous sequence of char-like objects with the first element of the sequence at position zero. A typical implementation holds only two members: a pointer to constant CharType and a size </td></tr>
<tr id="row_9_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1bitset.html" target="_self">etl::bitset&lt; NumberOfBits &gt;</a></td><td class="desc">The class template bitset represents a fixed-size sequence of N bits. Bitsets can be manipulated by standard logic operators </td></tr>
<tr id="row_10_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1char__traits.html" target="_self">etl::char_traits&lt; charT &gt;</a></td><td class="desc">The <a class="el" href="structetl_1_1char__traits.html" title="The char_traits class is a traits class template that abstracts basic character and string operations...">char_traits</a> class is a traits class template that abstracts basic character and string operations for a given character type. The defined operation set is such that generic algorithms almost always can be implemented in terms of it. It is thus possible to use such algorithms with almost any possible character or string type, just by supplying a customized <a class="el" href="structetl_1_1char__traits.html" title="The char_traits class is a traits class template that abstracts basic character and string operations...">char_traits</a> class. The <a class="el" href="structetl_1_1char__traits.html" title="The char_traits class is a traits class template that abstracts basic character and string operations...">char_traits</a> class template serves as a basis for explicit instantiations. The user can provide a specialization for any custom character types. Several specializations are defined for the standard character types. If an operation on traits emits an exception, the behavior is undefined </td></tr>
<tr id="row_11_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html" target="_self">etl::char_traits&lt; char &gt;</a></td><td class="desc">Specializations of <a class="el" href="structetl_1_1char__traits.html" title="The char_traits class is a traits class template that abstracts basic character and string operations...">char_traits</a> for type char </td></tr>
<tr id="row_12_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1common__type.html" target="_self">etl::common_type&lt;... &gt;</a></td><td class="desc">Determines the common type among all types T..., that is the type all T... can be implicitly converted to. If such a type exists (as determined according to the rules below), the member type names that type. Otherwise, there is no member type. https://en.cppreference.com/w/cpp/types/common_type </td></tr>
<tr id="row_13_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_13_" class="arrow" onclick="toggleFolder('13_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1common__type.html" target="_self">etl::common_type&lt; common_type&lt; T1, T2 &gt;::type, R... &gt;</a></td><td class="desc"></td></tr>
<tr id="row_13_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1detail_1_1common__type__multi__impl_3_01void__t_3_01typename_01common__type_3_01T1_c112970aa4406b128acca994532075af.html" target="_self">etl::detail::common_type_multi_impl&lt; void_t&lt; typename common_type&lt; T1, T2 &gt;::type &gt;, T1, T2, R... &gt;</a></td><td class="desc"></td></tr>
<tr id="row_14_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1common__type_3_01etl_1_1chrono_1_1duration_3_01Rep1_00_01Period1_01_4_00_01etl_1_1cb97b81fdc5f26d47dec1bbf9c7339b38.html" target="_self">etl::common_type&lt; etl::chrono::duration&lt; Rep1, Period1 &gt;, etl::chrono::duration&lt; Rep2, Period2 &gt; &gt;</a></td><td class="desc">Exposes the type named type, which is the common type of two etl::chrono::durations, whose period is the greatest common divisor of Period1 and Period2 </td></tr>
<tr id="row_15_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_15_" class="arrow" onclick="toggleFolder('15_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1common__type.html" target="_self">etl::common_type&lt; T, T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_15_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1common__type_3_01T_01_4.html" target="_self">etl::common_type&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_16_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1detail_1_1common__type__2__impl.html" target="_self">etl::detail::common_type_2_impl&lt; T1, T2, class &gt;</a></td><td class="desc"></td></tr>
<tr id="row_17_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_17_" class="arrow" onclick="toggleFolder('17_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1detail_1_1common__type__2__impl.html" target="_self">etl::detail::common_type_2_impl&lt; etl::decay&lt; T1 &gt;::type, etl::decay&lt; T2 &gt;::type &gt;</a></td><td class="desc"></td></tr>
<tr id="row_17_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1common__type_3_01T1_00_01T2_01_4.html" target="_self">etl::common_type&lt; T1, T2 &gt;</a></td><td class="desc"></td></tr>
<tr id="row_18_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1detail_1_1common__type__2__impl_3_01T1_00_01T2_00_01void__t_3_01cond__t_3_01T1_00_01T2_01_4_01_4_01_4.html" target="_self">etl::detail::common_type_2_impl&lt; T1, T2, void_t&lt; cond_t&lt; T1, T2 &gt; &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_19_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1detail_1_1common__type__multi__impl.html" target="_self">etl::detail::common_type_multi_impl&lt; AlwaysVoid, T1, T2, R &gt;</a></td><td class="desc"></td></tr>
<tr id="row_20_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_20_" class="arrow" onclick="toggleFolder('20_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1detail_1_1common__type__multi__impl.html" target="_self">etl::detail::common_type_multi_impl&lt; void, T1, T2, R... &gt;</a></td><td class="desc"></td></tr>
<tr id="row_20_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1common__type_3_01T1_00_01T2_00_01R_8_8_8_01_4.html" target="_self">etl::common_type&lt; T1, T2, R... &gt;</a></td><td class="desc"></td></tr>
<tr id="row_21_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1conditional.html" target="_self">etl::conditional&lt; B, T, F &gt;</a></td><td class="desc">Provides member typedef type, which is defined as T if B is true at compile time, or as F if B is false </td></tr>
<tr id="row_22_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1conditional_3_01false_00_01T_00_01F_01_4.html" target="_self">etl::conditional&lt; false, T, F &gt;</a></td><td class="desc"></td></tr>
<tr id="row_23_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1net_1_1const__buffer.html" target="_self">etl::net::const_buffer</a></td><td class="desc"></td></tr>
<tr id="row_24_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1dsp_1_1constant.html" target="_self">etl::dsp::constant&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_25_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1crtp.html" target="_self">etl::crtp&lt; Type, CrtpTag &gt;</a></td><td class="desc"></td></tr>
<tr id="row_26_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_26_" class="arrow" onclick="toggleFolder('26_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1crtp.html" target="_self">etl::crtp&lt; StrongType, addable &gt;</a></td><td class="desc"></td></tr>
<tr id="row_26_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1skill_1_1addable.html" target="_self">etl::experimental::skill::addable&lt; StrongType &gt;</a></td><td class="desc"></td></tr>
<tr id="row_27_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_27_" class="arrow" onclick="toggleFolder('27_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1crtp.html" target="_self">etl::crtp&lt; StrongType, comparable &gt;</a></td><td class="desc"></td></tr>
<tr id="row_27_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1skill_1_1comparable.html" target="_self">etl::experimental::skill::comparable&lt; StrongType &gt;</a></td><td class="desc"></td></tr>
<tr id="row_28_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_28_" class="arrow" onclick="toggleFolder('28_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1crtp.html" target="_self">etl::crtp&lt; StrongType, divisible &gt;</a></td><td class="desc"></td></tr>
<tr id="row_28_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1skill_1_1divisible.html" target="_self">etl::experimental::skill::divisible&lt; StrongType &gt;</a></td><td class="desc"></td></tr>
<tr id="row_29_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_29_" class="arrow" onclick="toggleFolder('29_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1crtp.html" target="_self">etl::crtp&lt; StrongType, multipliable &gt;</a></td><td class="desc"></td></tr>
<tr id="row_29_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1skill_1_1multipliable.html" target="_self">etl::experimental::skill::multipliable&lt; StrongType &gt;</a></td><td class="desc"></td></tr>
<tr id="row_30_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_30_" class="arrow" onclick="toggleFolder('30_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1crtp.html" target="_self">etl::crtp&lt; StrongType, subtractable &gt;</a></td><td class="desc"></td></tr>
<tr id="row_30_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1skill_1_1subtractable.html" target="_self">etl::experimental::skill::subtractable&lt; StrongType &gt;</a></td><td class="desc"></td></tr>
<tr id="row_31_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1decay.html" target="_self">etl::decay&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_32_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1dsp_1_1delay.html" target="_self">etl::dsp::delay&lt; T, Z &gt;</a></td><td class="desc"></td></tr>
<tr id="row_33_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::den)&gt;</a></td><td class="desc"></td></tr>
<tr id="row_34_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::den)&gt;</a></td><td class="desc"></td></tr>
<tr id="row_35_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_35_" class="arrow" onclick="toggleFolder('35_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::den&lt; R2::num *R1::den)&gt;</a></td><td class="desc"></td></tr>
<tr id="row_35_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1ratio__less.html" target="_self">etl::ratio_less&lt; R1, R2 &gt;</a></td><td class="desc">Compares two ratio objects for equality at compile-time. If the ratio R1 is less than the ratio R2, provides the member constant value equal true. Otherwise, value is false </td></tr>
<tr id="row_36_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_36_" class="arrow" onclick="toggleFolder('36_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::den&lt;=R2::num *R1::den)&gt;</a></td><td class="desc"></td></tr>
<tr id="row_36_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1ratio__less__equal.html" target="_self">etl::ratio_less_equal&lt; R1, R2 &gt;</a></td><td class="desc">Compares two ratio objects for equality at compile-time. If the ratio R1 is less than or equal to the ratio R2, provides the member constant value equal true. Otherwise, value is false </td></tr>
<tr id="row_37_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1hardware_1_1mcp23017_1_1device.html" target="_self">etl::hardware::mcp23017::device&lt; Driver &gt;</a></td><td class="desc"></td></tr>
<tr id="row_38_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1chrono_1_1duration.html" target="_self">etl::chrono::duration&lt; Rep, Period &gt;</a></td><td class="desc">Class template <a class="el" href="classetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval. ">etl::chrono::duration</a> represents a time interval </td></tr>
<tr id="row_39_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1chrono_1_1duration__values.html" target="_self">etl::chrono::duration_values&lt; Rep &gt;</a></td><td class="desc">The <a class="el" href="structetl_1_1chrono_1_1duration__values.html" title="The etl::chrono::duration_values type defines three common durations. ">etl::chrono::duration_values</a> type defines three common durations </td></tr>
<tr id="row_40_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1enable__if.html" target="_self">etl::enable_if&lt; bool, Type &gt;</a></td><td class="desc">Define a member typedef only if a boolean constant is true </td></tr>
<tr id="row_41_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1enable__if_3_01true_00_01Type_01_4.html" target="_self">etl::enable_if&lt; true, Type &gt;</a></td><td class="desc"></td></tr>
<tr id="row_42_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1dsp_1_1feedback__drain.html" target="_self">etl::dsp::feedback_drain&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_43_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1dsp_1_1feedback__tap.html" target="_self">etl::dsp::feedback_tap&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_44_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1rtos_1_1forever.html" target="_self">etl::rtos::forever</a></td><td class="desc">Runs the task loop forever </td></tr>
<tr id="row_45_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1dsp_1_1detail_1_1fork__impl.html" target="_self">etl::dsp::detail::fork_impl&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_46_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1fpos.html" target="_self">etl::fpos&lt; State &gt;</a></td><td class="desc"></td></tr>
<tr id="row_47_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1function.html" target="_self">etl::function&lt; size_t, class &gt;</a></td><td class="desc"></td></tr>
<tr id="row_48_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1function__view.html" target="_self">etl::function_view&lt; class &gt;</a></td><td class="desc"></td></tr>
<tr id="row_49_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_49_" class="arrow" onclick="toggleFolder('49_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1function__view_3_01Result_07Arguments_8_8_8_08_4.html" target="_self">etl::function_view&lt; Result(Arguments...)&gt;</a></td><td class="desc"></td></tr>
<tr id="row_49_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1function_3_01Capacity_00_01Result_07Arguments_8_8_8_08_4.html" target="_self">etl::function&lt; Capacity, Result(Arguments...)&gt;</a></td><td class="desc"></td></tr>
<tr id="row_50_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1detail_1_1get__impl.html" target="_self">etl::detail::get_impl&lt; index, First, Rest &gt;</a></td><td class="desc"></td></tr>
<tr id="row_51_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1detail_1_1get__impl_3_010_00_01First_00_01Rest_8_8_8_01_4.html" target="_self">etl::detail::get_impl&lt; 0, First, Rest... &gt;</a></td><td class="desc"></td></tr>
<tr id="row_52_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1hardware_1_1stm32_1_1gpio__memory__layout.html" target="_self">etl::hardware::stm32::gpio_memory_layout</a></td><td class="desc"></td></tr>
<tr id="row_53_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1dsp_1_1identity.html" target="_self">etl::dsp::identity</a></td><td class="desc"></td></tr>
<tr id="row_54_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1in__place__index__t.html" target="_self">etl::in_place_index_t&lt; I &gt;</a></td><td class="desc">Disambiguation tags that can be passed to the constructors of etl::optional, etl::variant, and etl::any to indicate that the contained object should be constructed in-place, and (for the latter two) the type of the object to be constructed </td></tr>
<tr id="row_55_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1in__place__t.html" target="_self">etl::in_place_t</a></td><td class="desc">Disambiguation tags that can be passed to the constructors of etl::optional, etl::variant, and etl::any to indicate that the contained object should be constructed in-place, and (for the latter two) the type of the object to be constructed </td></tr>
<tr id="row_56_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1in__place__type__t.html" target="_self">etl::in_place_type_t&lt; T &gt;</a></td><td class="desc">Disambiguation tags that can be passed to the constructors of etl::optional, etl::variant, and etl::any to indicate that the contained object should be constructed in-place, and (for the latter two) the type of the object to be constructed </td></tr>
<tr id="row_57_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_57_" class="arrow" onclick="toggleFolder('57_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; Type, val &gt;</a></td><td class="desc"></td></tr>
<tr id="row_57_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1chrono_1_1detail_1_1is__duration.html" target="_self">etl::chrono::detail::is_duration&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_57_1_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1chrono_1_1detail_1_1is__duration_3_01etl_1_1chrono_1_1duration_3_01Rep_00_01Period_01_4_01_4.html" target="_self">etl::chrono::detail::is_duration&lt; etl::chrono::duration&lt; Rep, Period &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_57_2_" class="even" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_57_2_" class="arrow" onclick="toggleFolder('57_2_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1detail_1_1is__constructible__helper.html" target="_self">etl::detail::is_constructible_helper&lt; class, T, Args &gt;</a></td><td class="desc"></td></tr>
<tr id="row_57_2_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__default__constructible.html" target="_self">etl::is_default_constructible&lt; T &gt;</a></td><td class="desc">If <a class="el" href="structetl_1_1integral__constant.html#ac6a0d38654d5eeea44e25fea4eae7a55">etl::is_constructible&lt;T&gt;::value</a> is true, provides the member constant value equal to true, otherwise value is false </td></tr>
<tr id="row_57_2_1_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__move__constructible.html" target="_self">etl::is_move_constructible&lt; T &gt;</a></td><td class="desc">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#ac6a0d38654d5eeea44e25fea4eae7a55">etl::is_constructible&lt;T, T&amp;&amp;&gt;::value</a> </td></tr>
<tr id="row_57_3_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1detail_1_1is__constructible__helper_3_01void__t_3_01decltype_07T_07declval_3_01Argsa80037a39bb9e756040a068d64e78d77.html" target="_self">etl::detail::is_constructible_helper&lt; void_t&lt; decltype(T(declval&lt; Args &gt;()...))&gt;, T, Args... &gt;</a></td><td class="desc"></td></tr>
<tr id="row_57_4_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1detail_1_1is__member__function__pointer__helper.html" target="_self">etl::detail::is_member_function_pointer_helper&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_57_5_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1detail_1_1is__member__pointer__helper.html" target="_self">etl::detail::is_member_pointer_helper&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_57_6_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1detail_1_1is__member__pointer__helper_3_01T_01U_1_1_5_01_4.html" target="_self">etl::detail::is_member_pointer_helper&lt; T U::* &gt;</a></td><td class="desc"></td></tr>
<tr id="row_57_7_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1detail_1_1is__pointer__helper.html" target="_self">etl::detail::is_pointer_helper&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_57_8_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1detail_1_1is__pointer__helper_3_01T_01_5_01_4.html" target="_self">etl::detail::is_pointer_helper&lt; T * &gt;</a></td><td class="desc"></td></tr>
<tr id="row_57_9_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__array.html" target="_self">etl::is_array&lt; T &gt;</a></td><td class="desc">Checks whether T is an array type. Provides the member constant value which is equal to true, if T is an array type. Otherwise, value is equal to false </td></tr>
<tr id="row_57_10_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__array_3_01T[]_4.html" target="_self">etl::is_array&lt; T[]&gt;</a></td><td class="desc"></td></tr>
<tr id="row_57_11_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__array_3_01T[N]_4.html" target="_self">etl::is_array&lt; T[N]&gt;</a></td><td class="desc"></td></tr>
<tr id="row_57_12_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__const.html" target="_self">etl::is_const&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_57_13_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__const_3_01const_01T_01_4.html" target="_self">etl::is_const&lt; const T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_57_14_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__error__code__enum.html" target="_self">etl::is_error_code_enum&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_57_15_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__error__condition__enum.html" target="_self">etl::is_error_condition_enum&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_57_16_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__error__condition__enum_3_01errc_01_4.html" target="_self">etl::is_error_condition_enum&lt; errc &gt;</a></td><td class="desc"></td></tr>
<tr id="row_57_17_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__reference.html" target="_self">etl::is_reference&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_57_18_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__reference_3_01T_01_6_01_4.html" target="_self">etl::is_reference&lt; T &amp; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_57_19_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__reference_3_01T_01_6_6_01_4.html" target="_self">etl::is_reference&lt; T &amp;&amp; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_57_20_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__same.html" target="_self">etl::is_same&lt; T, U &gt;</a></td><td class="desc">If T and U name the same type (taking into account const/volatile qualifications), provides the member constant value equal to true. Otherwise value is false </td></tr>
<tr id="row_57_21_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__same_3_01T_00_01T_01_4.html" target="_self">etl::is_same&lt; T, T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_57_22_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1ratio__greater.html" target="_self">etl::ratio_greater&lt; R1, R2 &gt;</a></td><td class="desc">Compares two ratio objects for equality at compile-time. If the ratio R1 is greater than the ratio R2, provides the member constant value equal true. Otherwise, value is false </td></tr>
<tr id="row_57_23_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1ratio__greater__equal.html" target="_self">etl::ratio_greater_equal&lt; R1, R2 &gt;</a></td><td class="desc">Compares two ratio objects for equality at compile-time. If the ratio R1 is greater than or equal to the ratio R2, provides the member constant value equal true. Otherwise, value is false </td></tr>
<tr id="row_57_24_" class="even" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_57_24_" class="arrow" onclick="toggleFolder('57_24_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1detail_1_1is__member__function__pointer__helper.html" target="_self">etl::detail::is_member_function_pointer_helper&lt; etl::remove_cv&lt; T &gt;::type &gt;</a></td><td class="desc"></td></tr>
<tr id="row_57_24_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__member__function__pointer.html" target="_self">etl::is_member_function_pointer&lt; T &gt;</a></td><td class="desc">Checks whether T is a non-static member function pointer. Provides the member constant value which is equal to true, if T is a non-static member function pointer type. Otherwise, value is equal to false </td></tr>
<tr id="row_57_25_" class="even" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_57_25_" class="arrow" onclick="toggleFolder('57_25_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1detail_1_1is__member__pointer__helper.html" target="_self">etl::detail::is_member_pointer_helper&lt; etl::remove_cv&lt; T &gt;::type &gt;</a></td><td class="desc"></td></tr>
<tr id="row_57_25_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__member__pointer.html" target="_self">etl::is_member_pointer&lt; T &gt;</a></td><td class="desc">If T is pointer to non-static member object or a pointer to non-static member function, provides the member constant value equal true. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__member__pointer.html" title="If T is pointer to non-static member object or a pointer to non-static member function, provides the member constant value equal true. For any other type, value is false. The behavior of a program that adds specializations for is_member_pointer or is_member_pointer_v (since C++17) is undefined. ">is_member_pointer</a> or is_member_pointer_v (since C++17) is undefined </td></tr>
<tr id="row_57_26_" class="even" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_57_26_" class="arrow" onclick="toggleFolder('57_26_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1detail_1_1is__pointer__helper.html" target="_self">etl::detail::is_pointer_helper&lt; remove_cv&lt; T &gt;::type &gt;</a></td><td class="desc"></td></tr>
<tr id="row_57_26_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__pointer.html" target="_self">etl::is_pointer&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_57_27_" class="even" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_57_27_" class="arrow" onclick="toggleFolder('57_27_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__same.html" target="_self">etl::is_same&lt; nullptr_t, remove_cv_t&lt; T &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_57_27_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__null__pointer.html" target="_self">etl::is_null_pointer&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_57_28_" class="even" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_57_28_" class="arrow" onclick="toggleFolder('57_28_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__same.html" target="_self">etl::is_same&lt; void, remove_cv&lt; T &gt;::type &gt;</a></td><td class="desc"></td></tr>
<tr id="row_57_28_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__void.html" target="_self">etl::is_void&lt; T &gt;</a></td><td class="desc">Define a member typedef only if a boolean constant is true </td></tr>
<tr id="row_58_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_58_" class="arrow" onclick="toggleFolder('58_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; bool, !etl::is_const&lt; const T &gt;::value &amp;&amp;!etl::is_reference&lt; T &gt;::value &gt;</a></td><td class="desc"></td></tr>
<tr id="row_58_0_" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_58_0_" class="arrow" onclick="toggleFolder('58_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__function.html" target="_self">etl::is_function&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_58_0_0_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1detail_1_1is__member__function__pointer__helper_3_01T_01U_1_1_5_01_4.html" target="_self">etl::detail::is_member_function_pointer_helper&lt; T U::* &gt;</a></td><td class="desc"></td></tr>
<tr id="row_59_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_59_" class="arrow" onclick="toggleFolder('59_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; bool, !etl::is_fundamental&lt; T &gt;::value &gt;</a></td><td class="desc"></td></tr>
<tr id="row_59_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__compound.html" target="_self">etl::is_compound&lt; T &gt;</a></td><td class="desc">If T is a compound type (that is, array, function, object pointer, function pointer, member object pointer, member function pointer, reference, class, union, or enumeration, including any cv-qualified variants), provides the member constant value equal true. For any other type, value is false </td></tr>
<tr id="row_60_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_60_" class="arrow" onclick="toggleFolder('60_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; bool, !etl::ratio_equal_v&lt; R1, R2 &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_60_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1ratio__not__equal.html" target="_self">etl::ratio_not_equal&lt; R1, R2 &gt;</a></td><td class="desc">Compares two ratio objects for equality at compile-time. If the ratios R1 and R2 are not equal, provides the member constant value equal true. Otherwise, value is false </td></tr>
<tr id="row_61_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_61_" class="arrow" onclick="toggleFolder('61_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; bool, etl::is_arithmetic&lt; T &gt;::value||etl::is_enum&lt; T &gt;::value||etl::is_pointer&lt; T &gt;::value||etl::is_member_pointer&lt; T &gt;::value||etl::is_null_pointer&lt; T &gt;::value &gt;</a></td><td class="desc"></td></tr>
<tr id="row_61_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__scalar.html" target="_self">etl::is_scalar&lt; T &gt;</a></td><td class="desc">If T is a scalar type (that is a possibly cv-qualified arithmetic, pointer, pointer to member, enumeration, or <a class="el" href="namespaceetl.html#adf4272f3f16bf2234ac8248db615f133">etl::nullptr_t</a> type), provides the member constant value equal true. For any other type, value is false </td></tr>
<tr id="row_62_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_62_" class="arrow" onclick="toggleFolder('62_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; bool, etl::is_integral&lt; T &gt;::value||etl::is_floating_point&lt; T &gt;::value &gt;</a></td><td class="desc"></td></tr>
<tr id="row_62_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__arithmetic.html" target="_self">etl::is_arithmetic&lt; T &gt;</a></td><td class="desc">If T is an arithmetic type (that is, an integral type or a floating-point type) or a cv-qualified version thereof, provides the member constant value equal true. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__arithmetic.html" title="If T is an arithmetic type (that is, an integral type or a floating-point type) or a cv-qualified ver...">is_arithmetic</a> or is_arithmetic_v (since C++17) is undefined </td></tr>
<tr id="row_63_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_63_" class="arrow" onclick="toggleFolder('63_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; bool, etl::is_member_pointer&lt; T &gt;::value &amp;&amp;!etl::is_member_function_pointer&lt; T &gt;::value &gt;</a></td><td class="desc"></td></tr>
<tr id="row_63_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__member__object__pointer.html" target="_self">etl::is_member_object_pointer&lt; T &gt;</a></td><td class="desc">Checks whether T is a non-static member object pointer. Provides the member constant value which is equal to true, if T is a non-static member object pointer type. Otherwise, value is equal to false </td></tr>
<tr id="row_64_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_64_" class="arrow" onclick="toggleFolder('64_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; bool, etl::is_same&lt; float, etl::remove_cv&lt; Rep &gt;::type &gt;::value||etl::is_same&lt; double, etl::remove_cv&lt; Rep &gt;::type &gt;::value||etl::is_same&lt; long double, etl::remove_cv&lt; Rep &gt;::type &gt;::value &gt;</a></td><td class="desc"></td></tr>
<tr id="row_64_0_" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_64_0_" class="arrow" onclick="toggleFolder('64_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__floating__point.html" target="_self">etl::is_floating_point&lt; Rep &gt;</a></td><td class="desc"></td></tr>
<tr id="row_64_0_0_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1chrono_1_1treat__as__floating__point.html" target="_self">etl::chrono::treat_as_floating_point&lt; Rep &gt;</a></td><td class="desc">The <a class="el" href="structetl_1_1chrono_1_1treat__as__floating__point.html" title="The etl::chrono::treat_as_floating_point trait helps determine if a duration can be converted to anot...">etl::chrono::treat_as_floating_point</a> trait helps determine if a duration can be converted to another duration with a different tick period </td></tr>
<tr id="row_65_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_65_" class="arrow" onclick="toggleFolder('65_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; bool, etl::is_same&lt; float, etl::remove_cv&lt; T &gt;::type &gt;::value||etl::is_same&lt; double, etl::remove_cv&lt; T &gt;::type &gt;::value||etl::is_same&lt; long double, etl::remove_cv&lt; T &gt;::type &gt;::value &gt;</a></td><td class="desc"></td></tr>
<tr id="row_65_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__floating__point.html" target="_self">etl::is_floating_point&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_66_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_66_" class="arrow" onclick="toggleFolder('66_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; bool, etl::is_scalar&lt; T &gt;::value||etl::is_array&lt; T &gt;::value||etl::is_union&lt; T &gt;::value||etl::is_class&lt; T &gt;::value &gt;</a></td><td class="desc"></td></tr>
<tr id="row_66_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__object.html" target="_self">etl::is_object&lt; T &gt;</a></td><td class="desc">If T is an object type (that is any possibly cv-qualified type other than function, reference, or void types), provides the member constant value equal true. For any other type, value is false </td></tr>
<tr id="row_67_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_67_" class="arrow" onclick="toggleFolder('67_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; bool, is_integral_v&lt; T &gt; &amp;&amp;(!is_same_v&lt; T, bool &gt; &amp;&amp;!is_same_v&lt; T, char &gt; &amp;&amp;!is_same_v&lt; T, char16_t &gt; &amp;&amp;!is_same_v&lt; T, char32_t &gt; &amp;&amp;!is_same_v&lt; T, wchar_t &gt;)&gt;</a></td><td class="desc"></td></tr>
<tr id="row_67_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1detail_1_1is__integer__and__not__char.html" target="_self">etl::detail::is_integer_and_not_char&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_68_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_68_" class="arrow" onclick="toggleFolder('68_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; bool, is_unsigned_v&lt; T &gt; &amp;&amp;(!is_same_v&lt; T, bool &gt; &amp;&amp;!is_same_v&lt; T, char &gt; &amp;&amp;!is_same_v&lt; T, char16_t &gt; &amp;&amp;!is_same_v&lt; T, char32_t &gt; &amp;&amp;!is_same_v&lt; T, wchar_t &gt;)&gt;</a></td><td class="desc"></td></tr>
<tr id="row_68_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1detail_1_1is__unsigned__integer.html" target="_self">etl::detail::is_unsigned_integer&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_69_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_69_" class="arrow" onclick="toggleFolder('69_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; bool, R1::num==R2::num &amp;&amp;R1::den==R2::den &gt;</a></td><td class="desc"></td></tr>
<tr id="row_69_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1ratio__equal.html" target="_self">etl::ratio_equal&lt; R1, R2 &gt;</a></td><td class="desc">Compares two ratio objects for equality at compile-time. If the ratios R1 and R2 are equal, provides the member constant value equal true. Otherwise, value is false </td></tr>
<tr id="row_70_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_70_" class="arrow" onclick="toggleFolder('70_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; bool, TAETL_IS_CLASS(T)&gt;</a></td><td class="desc"></td></tr>
<tr id="row_70_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__class.html" target="_self">etl::is_class&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_71_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_71_" class="arrow" onclick="toggleFolder('71_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; bool, TAETL_IS_ENUM(T)&gt;</a></td><td class="desc"></td></tr>
<tr id="row_71_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__enum.html" target="_self">etl::is_enum&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_72_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_72_" class="arrow" onclick="toggleFolder('72_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; bool, TAETL_IS_NOTHROW_CONSTRUCTABLE(T)&gt;</a></td><td class="desc"></td></tr>
<tr id="row_72_0_" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_72_0_" class="arrow" onclick="toggleFolder('72_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__constructible.html" target="_self">etl::is_nothrow_constructible&lt; T &gt;</a></td><td class="desc">The variable definition does not call any operation that is not trivial. For the purposes of this check, the call to <a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292" title="Converts any type T to a reference type, making it possible to use member functions in decltype expre...">etl::declval</a> is considered trivial </td></tr>
<tr id="row_72_0_0_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__default__constructible.html" target="_self">etl::is_nothrow_default_constructible&lt; T &gt;</a></td><td class="desc">If <a class="el" href="structetl_1_1integral__constant.html#ac6a0d38654d5eeea44e25fea4eae7a55">etl::is_nothrow_constructible&lt;T&gt;::value</a> is true, provides the member constant value equal to true, otherwise value is false </td></tr>
<tr id="row_73_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_73_" class="arrow" onclick="toggleFolder('73_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; bool, TAETL_IS_TRIVIAL_CONSTRUCTABLE(T)&gt;</a></td><td class="desc"></td></tr>
<tr id="row_73_0_" class="even" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_73_0_" class="arrow" onclick="toggleFolder('73_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__trivially__constructible.html" target="_self">etl::is_trivially_constructible&lt; T &gt;</a></td><td class="desc">The variable definition does not call any operation that is not trivial. For the purposes of this check, the call to <a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292" title="Converts any type T to a reference type, making it possible to use member functions in decltype expre...">etl::declval</a> is considered trivial </td></tr>
<tr id="row_73_0_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__trivially__default__constructible.html" target="_self">etl::is_trivially_default_constructible&lt; T &gt;</a></td><td class="desc">If <a class="el" href="structetl_1_1integral__constant.html#ac6a0d38654d5eeea44e25fea4eae7a55">etl::is_trivially_constructible&lt;T&gt;::value</a> is true, provides the member constant value equal to true, otherwise value is false </td></tr>
<tr id="row_74_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_74_" class="arrow" onclick="toggleFolder('74_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; bool, TAETL_IS_UNION(T)&gt;</a></td><td class="desc"></td></tr>
<tr id="row_74_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__union.html" target="_self">etl::is_union&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_75_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_75_" class="arrow" onclick="toggleFolder('75_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; bool,(decltype(detail::test_returnable&lt; To &gt;(0))::value &amp;&amp;decltype(detail::test_nonvoid_convertible&lt; From, To &gt;(0))::value)||(etl::is_void&lt; From &gt;::value &amp;&amp;etl::is_void&lt; To &gt;::value)&gt;</a></td><td class="desc"></td></tr>
<tr id="row_75_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__convertible.html" target="_self">etl::is_convertible&lt; From, To &gt;</a></td><td class="desc">If the imaginary function definition To test() { return <a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292" title="Converts any type T to a reference type, making it possible to use member functions in decltype expre...">etl::declval&lt;From&gt;()</a>; } is well-formed, (that is, either <a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292" title="Converts any type T to a reference type, making it possible to use member functions in decltype expre...">etl::declval&lt;From&gt;()</a> can be converted to To using implicit conversions, or both From and To are possibly cv-qualified void), provides the member constant value equal to true. Otherwise value is false. For the purposes of this check, the use of <a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292" title="Converts any type T to a reference type, making it possible to use member functions in decltype expre...">etl::declval</a> in the return statement is not considered an odr-use. Access checks are performed as if from a context unrelated to either type. Only the validity of the immediate context of the expression in the return statement (including conversions to the return type) is considered </td></tr>
<tr id="row_76_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_76_" class="arrow" onclick="toggleFolder('76_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; etl::size_t, 0 &gt;</a></td><td class="desc"></td></tr>
<tr id="row_76_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1rank.html" target="_self">etl::rank&lt; T &gt;</a></td><td class="desc">If Type is an array type, provides the member constant value equal to the number of dimensions of the array. For any other type, value is 0. The behavior of a program that adds specializations for rank or rank_v is undefined </td></tr>
<tr id="row_77_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_77_" class="arrow" onclick="toggleFolder('77_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; etl::size_t, rank&lt; T &gt;::value+1 &gt;</a></td><td class="desc"></td></tr>
<tr id="row_77_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1rank_3_01T[]_4.html" target="_self">etl::rank&lt; T[]&gt;</a></td><td class="desc"></td></tr>
<tr id="row_77_1_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1rank_3_01T[N]_4.html" target="_self">etl::rank&lt; T[N]&gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__fundamental.html" target="_self">etl::is_fundamental&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_79_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__lvalue__reference.html" target="_self">etl::is_lvalue_reference&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_80_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__rvalue__reference.html" target="_self">etl::is_rvalue_reference&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_81_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1hardware_1_1stm32_1_1isr.html" target="_self">etl::hardware::stm32::isr</a></td><td class="desc"></td></tr>
<tr id="row_82_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1less.html" target="_self">etl::less&lt; Type &gt;</a></td><td class="desc"></td></tr>
<tr id="row_83_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1make__unsigned.html" target="_self">etl::make_unsigned&lt; typename &gt;</a></td><td class="desc">If T is an integral (except bool) or enumeration type, provides the member typedef type which is the unsigned integer type corresponding to T, with the same cv-qualifiers. If T is signed or unsigned char, short, int, long, long long; the unsigned type from this list corresponding to T is provided. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1make__unsigned.html" title="If T is an integral (except bool) or enumeration type, provides the member typedef type which is the ...">make_unsigned</a> is undefined </td></tr>
<tr id="row_84_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1make__unsigned_3_01signed_01char_01_4.html" target="_self">etl::make_unsigned&lt; signed char &gt;</a></td><td class="desc"></td></tr>
<tr id="row_85_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1make__unsigned_3_01signed_01int_01_4.html" target="_self">etl::make_unsigned&lt; signed int &gt;</a></td><td class="desc"></td></tr>
<tr id="row_86_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1make__unsigned_3_01signed_01long_01_4.html" target="_self">etl::make_unsigned&lt; signed long &gt;</a></td><td class="desc"></td></tr>
<tr id="row_87_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1make__unsigned_3_01signed_01long_01long_01_4.html" target="_self">etl::make_unsigned&lt; signed long long &gt;</a></td><td class="desc"></td></tr>
<tr id="row_88_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1make__unsigned_3_01signed_01short_01_4.html" target="_self">etl::make_unsigned&lt; signed short &gt;</a></td><td class="desc"></td></tr>
<tr id="row_89_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1make__unsigned_3_01unsigned_01char_01_4.html" target="_self">etl::make_unsigned&lt; unsigned char &gt;</a></td><td class="desc"></td></tr>
<tr id="row_90_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1make__unsigned_3_01unsigned_01int_01_4.html" target="_self">etl::make_unsigned&lt; unsigned int &gt;</a></td><td class="desc"></td></tr>
<tr id="row_91_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1make__unsigned_3_01unsigned_01long_01_4.html" target="_self">etl::make_unsigned&lt; unsigned long &gt;</a></td><td class="desc"></td></tr>
<tr id="row_92_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1make__unsigned_3_01unsigned_01long_01long_01_4.html" target="_self">etl::make_unsigned&lt; unsigned long long &gt;</a></td><td class="desc"></td></tr>
<tr id="row_93_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1make__unsigned_3_01unsigned_01short_01_4.html" target="_self">etl::make_unsigned&lt; unsigned short &gt;</a></td><td class="desc"></td></tr>
<tr id="row_94_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_94_" class="arrow" onclick="toggleFolder('94_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1map.html" target="_self">etl::map&lt; KeyType, ValueType, Compare &gt;</a></td><td class="desc"></td></tr>
<tr id="row_94_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1make_1_1map.html" target="_self">etl::make::map&lt; KeyType, ValueType, Capacity, Compare &gt;</a></td><td class="desc"></td></tr>
<tr id="row_95_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1max__align__t.html" target="_self">etl::max_align_t</a></td><td class="desc"></td></tr>
<tr id="row_96_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1net_1_1mutable__buffer.html" target="_self">etl::net::mutable_buffer</a></td><td class="desc"></td></tr>
<tr id="row_97_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1rtos_1_1never.html" target="_self">etl::rtos::never</a></td><td class="desc">Runs the task loop 0 times </td></tr>
<tr id="row_98_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1numeric__limits.html" target="_self">etl::numeric_limits&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_99_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1numeric__limits_3_01bool_01_4.html" target="_self">etl::numeric_limits&lt; bool &gt;</a></td><td class="desc"></td></tr>
<tr id="row_100_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1numeric__limits_3_01char_01_4.html" target="_self">etl::numeric_limits&lt; char &gt;</a></td><td class="desc"></td></tr>
<tr id="row_101_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1numeric__limits_3_01double_01_4.html" target="_self">etl::numeric_limits&lt; double &gt;</a></td><td class="desc"></td></tr>
<tr id="row_102_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1numeric__limits_3_01float_01_4.html" target="_self">etl::numeric_limits&lt; float &gt;</a></td><td class="desc"></td></tr>
<tr id="row_103_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1numeric__limits_3_01int_01_4.html" target="_self">etl::numeric_limits&lt; int &gt;</a></td><td class="desc"></td></tr>
<tr id="row_104_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1numeric__limits_3_01long_01_4.html" target="_self">etl::numeric_limits&lt; long &gt;</a></td><td class="desc"></td></tr>
<tr id="row_105_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1numeric__limits_3_01short_01_4.html" target="_self">etl::numeric_limits&lt; short &gt;</a></td><td class="desc"></td></tr>
<tr id="row_106_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1numeric__limits_3_01signed_01char_01_4.html" target="_self">etl::numeric_limits&lt; signed char &gt;</a></td><td class="desc"></td></tr>
<tr id="row_107_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1numeric__limits_3_01unsigned_01char_01_4.html" target="_self">etl::numeric_limits&lt; unsigned char &gt;</a></td><td class="desc"></td></tr>
<tr id="row_108_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1numeric__limits_3_01unsigned_01int_01_4.html" target="_self">etl::numeric_limits&lt; unsigned int &gt;</a></td><td class="desc"></td></tr>
<tr id="row_109_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1numeric__limits_3_01unsigned_01long_01_4.html" target="_self">etl::numeric_limits&lt; unsigned long &gt;</a></td><td class="desc"></td></tr>
<tr id="row_110_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1numeric__limits_3_01unsigned_01short_01_4.html" target="_self">etl::numeric_limits&lt; unsigned short &gt;</a></td><td class="desc"></td></tr>
<tr id="row_111_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1pair.html" target="_self">etl::pair&lt; T1, T2 &gt;</a></td><td class="desc">Etl::pair is a class template that provides a way to store two heterogeneous objects as a single unit. A pair is a specific case of a <a class="el" href="structetl_1_1tuple.html">etl::tuple</a> with two elements. If neither T1 nor T2 is a possibly cv-qualified class type with non-trivial destructor, or array thereof, the destructor of pair is trivial. https://en.cppreference.com/w/cpp/utility/pair </td></tr>
<tr id="row_112_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1piecewise__construct__t.html" target="_self">etl::piecewise_construct_t</a></td><td class="desc">Etl::piecewise_construct_t is an empty class tag type used to disambiguate between different functions that take two tuple arguments </td></tr>
<tr id="row_113_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1dsp_1_1pipe.html" target="_self">etl::dsp::pipe&lt; L, R &gt;</a></td><td class="desc"></td></tr>
<tr id="row_114_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1hardware_1_1stm32_1_1port.html" target="_self">etl::hardware::stm32::port</a></td><td class="desc"></td></tr>
<tr id="row_115_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1rtos_1_1queue.html" target="_self">etl::rtos::queue&lt; ValueType, Size &gt;</a></td><td class="desc"></td></tr>
<tr id="row_116_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1ratio.html" target="_self">etl::ratio&lt; Num, Denom &gt;</a></td><td class="desc">The class template provides compile-time rational arithmetic support. Each instantiation of this template exactly represents any finite rational number as long as its numerator Num and denominator Denom are representable as compile-time constants of type intmax_t </td></tr>
<tr id="row_117_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__const.html" target="_self">etl::remove_const&lt; Type &gt;</a></td><td class="desc">Provides the member typedef type which is the same as T, except that its topmost cv-qualifiers are removed. Removes the topmost const </td></tr>
<tr id="row_118_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__const_3_01Type_01const_01_4.html" target="_self">etl::remove_const&lt; Type const &gt;</a></td><td class="desc"></td></tr>
<tr id="row_119_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__cv.html" target="_self">etl::remove_cv&lt; Type &gt;</a></td><td class="desc">Provides the member typedef type which is the same as T, except that its topmost cv-qualifiers are removed. Removes the topmost const, or the topmost volatile, or both, if present </td></tr>
<tr id="row_120_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__extent.html" target="_self">etl::remove_extent&lt; T &gt;</a></td><td class="desc">If T is an array of some type X, provides the member typedef type equal to X, otherwise type is T. Note that if T is a multidimensional array, only the first dimension is removed. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1remove__extent.html" title="If T is an array of some type X, provides the member typedef type equal to X, otherwise type is T...">remove_extent</a> is undefined </td></tr>
<tr id="row_121_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__extent_3_01T[]_4.html" target="_self">etl::remove_extent&lt; T[]&gt;</a></td><td class="desc"></td></tr>
<tr id="row_122_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__extent_3_01T[N]_4.html" target="_self">etl::remove_extent&lt; T[N]&gt;</a></td><td class="desc"></td></tr>
<tr id="row_123_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__reference.html" target="_self">etl::remove_reference&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_124_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__reference_3_01T_01_6_01_4.html" target="_self">etl::remove_reference&lt; T &amp; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_125_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__reference_3_01T_01_6_6_01_4.html" target="_self">etl::remove_reference&lt; T &amp;&amp; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_126_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__volatile.html" target="_self">etl::remove_volatile&lt; Type &gt;</a></td><td class="desc">Provides the member typedef type which is the same as T, except that its topmost cv-qualifiers are removed. Removes the topmost volatile </td></tr>
<tr id="row_127_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__volatile_3_01Type_01volatile_01_4.html" target="_self">etl::remove_volatile&lt; Type volatile &gt;</a></td><td class="desc"></td></tr>
<tr id="row_128_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1scoped__lock.html" target="_self">etl::scoped_lock&lt; MutexType &gt;</a></td><td class="desc">RAII based lock </td></tr>
<tr id="row_129_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1skill.html" target="_self">etl::experimental::skill</a></td><td class="desc"></td></tr>
<tr id="row_130_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_130_" class="arrow" onclick="toggleFolder('130_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>Skills</b></td><td class="desc"></td></tr>
<tr id="row_130_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1strong__type.html" target="_self">etl::experimental::strong_type&lt; ValueType, Tag, Skills &gt;</a></td><td class="desc">Wraps a built-in type </td></tr>
<tr id="row_131_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1small__ptr.html" target="_self">etl::small_ptr&lt; Type, BaseAddress, StorageType &gt;</a></td><td class="desc">Compressed pointer to specified size. Intended to be used as a drop in replacement for native pointers </td></tr>
<tr id="row_132_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1span.html" target="_self">etl::span&lt; ElementType, Extent &gt;</a></td><td class="desc">A non-owning view over a contiguous sequence of objects </td></tr>
<tr id="row_133_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1rtos_1_1times.html" target="_self">etl::rtos::times&lt; Count &gt;</a></td><td class="desc">Runs the task loop Count times </td></tr>
<tr id="row_134_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_134_" class="arrow" onclick="toggleFolder('134_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>try_add_lvalue_reference</b></td><td class="desc"></td></tr>
<tr id="row_134_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1add__lvalue__reference.html" target="_self">etl::add_lvalue_reference&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_135_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_135_" class="arrow" onclick="toggleFolder('135_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>try_add_pointer</b></td><td class="desc"></td></tr>
<tr id="row_135_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1add__pointer.html" target="_self">etl::add_pointer&lt; T &gt;</a></td><td class="desc">If T is a reference type, then provides the member typedef type which is a pointer to the referred type. Otherwise, if T names an object type, a function type that is not cv- or ref-qualified, or a (possibly cv-qualified) void type, provides the member typedef type which is the type T*. Otherwise (if T is a cv- or ref-qualified function type), provides the member typedef type which is the type T. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1add__pointer.html" title="If T is a reference type, then provides the member typedef type which is a pointer to the referred ty...">add_pointer</a> is undefined </td></tr>
<tr id="row_136_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_136_" class="arrow" onclick="toggleFolder('136_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>try_add_rvalue_reference</b></td><td class="desc"></td></tr>
<tr id="row_136_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1add__rvalue__reference.html" target="_self">etl::add_rvalue_reference&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_137_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1tuple.html" target="_self">etl::tuple&lt; First, Rest &gt;</a></td><td class="desc"></td></tr>
<tr id="row_138_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1tuple_3_01First_01_4.html" target="_self">etl::tuple&lt; First &gt;</a></td><td class="desc"></td></tr>
<tr id="row_139_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1tuple.html" target="_self">etl::tuple&lt; T... &gt;</a></td><td class="desc"></td></tr>
<tr id="row_140_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1aligned__storage_1_1type.html" target="_self">etl::aligned_storage&lt; Len, Align &gt;::type</a></td><td class="desc"></td></tr>
<tr id="row_141_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_141_" class="arrow" onclick="toggleFolder('141_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>type</b></td><td class="desc"></td></tr>
<tr id="row_141_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__unsigned.html" target="_self">etl::is_unsigned&lt; T &gt;</a></td><td class="desc">If T is an arithmetic type, provides the member constant value equal to true if T(0) &lt; T(-1): this results in true for the unsigned integer types and the type bool and in false for the signed integer types and the floating-point types. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__unsigned.html" title="If T is an arithmetic type, provides the member constant value equal to true if T(0) &lt; T(-1): this re...">is_unsigned</a> or is_unsigned_v (since C++17) is undefined </td></tr>
<tr id="row_142_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_142_" class="arrow" onclick="toggleFolder('142_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>type</b></td><td class="desc"></td></tr>
<tr id="row_142_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__signed.html" target="_self">etl::is_signed&lt; T &gt;</a></td><td class="desc">If T is an arithmetic type, provides the member constant value equal to true if T(-1) &lt; T(0): this results in true for the floating-point types and the signed integer types, and in false for the unsigned integer types and the type bool. For any other type, value is false </td></tr>
<tr id="row_143_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_143_" class="arrow" onclick="toggleFolder('143_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>type</b></td><td class="desc"></td></tr>
<tr id="row_143_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__integral.html" target="_self">etl::is_integral&lt; Type &gt;</a></td><td class="desc"></td></tr>
<tr id="row_144_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1type__identity.html" target="_self">etl::type_identity&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_145_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_145_" class="arrow" onclick="toggleFolder('145_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1vector.html" target="_self">etl::vector&lt; ValueType &gt;</a></td><td class="desc"></td></tr>
<tr id="row_145_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1make_1_1vector.html" target="_self">etl::make::vector&lt; ValueType, Size &gt;</a></td><td class="desc"></td></tr>
</table>
</div><!-- directory -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
