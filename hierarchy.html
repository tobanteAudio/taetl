<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>taetl: Class Hierarchy</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">taetl
   &#160;<span id="projectnumber">0.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Class Hierarchy</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock">
<p><a href="inherits.html">Go to the graphical class hierarchy</a></p>
This inheritance list is sorted roughly, but not completely, alphabetically:</div><div class="directory">
<div class="levels">[detail level <span onclick="javascript:toggleLevel(1);">1</span><span onclick="javascript:toggleLevel(2);">2</span><span onclick="javascript:toggleLevel(3);">3</span><span onclick="javascript:toggleLevel(4);">4</span><span onclick="javascript:toggleLevel(5);">5</span><span onclick="javascript:toggleLevel(6);">6</span><span onclick="javascript:toggleLevel(7);">7</span>]</div><table class="directory">
<tr id="row_0_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1add__const.html" target="_self">etl::add_const&lt; T &gt;</a></td><td class="desc">Provides the member typedef type which is the same as T, except it has a cv-qualifier added (unless T is a function, a reference, or already has this cv-qualifier). Adds const </td></tr>
<tr id="row_1_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1add__cv.html" target="_self">etl::add_cv&lt; T &gt;</a></td><td class="desc">Provides the member typedef type which is the same as T, except it has a cv-qualifier added (unless T is a function, a reference, or already has this cv-qualifier). Adds both const and volatile </td></tr>
<tr id="row_2_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1add__volatile.html" target="_self">etl::add_volatile&lt; T &gt;</a></td><td class="desc">Provides the member typedef type which is the same as T, except it has a cv-qualifier added (unless T is a function, a reference, or already has this cv-qualifier). Adds volatile </td></tr>
<tr id="row_3_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1adopt__lock__t.html" target="_self">etl::adopt_lock_t</a></td><td class="desc">Empty class tag types used to specify locking strategy for <a class="el" href="classetl_1_1lock__guard.html" title="The class lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a ...">etl::lock_guard</a>, <a class="el" href="classetl_1_1scoped__lock.html" title="RAII based lock. ">etl::scoped_lock</a>, etl::unique_lock, and etl::shared_lock </td></tr>
<tr id="row_4_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1aligned__storage.html" target="_self">etl::aligned_storage&lt; Len, Align &gt;</a></td><td class="desc">Provides the nested type type, which is a trivial standard-layout type suitable for use as uninitialized storage for any object whose size is at most Len and whose alignment requirement is a divisor of Align </td></tr>
<tr id="row_5_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1aligned__storage.html" target="_self">etl::aligned_storage&lt; sizeof(pair_t), alignof(pair_t)&gt;</a></td><td class="desc"></td></tr>
<tr id="row_6_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1array.html" target="_self">etl::array&lt; Type, Size &gt;</a></td><td class="desc">Etl::array is a container that encapsulates fixed size arrays </td></tr>
<tr id="row_7_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1array.html" target="_self">etl::array&lt; T, static_cast&lt; size_t &gt;(Z)+1 &gt;</a></td><td class="desc"></td></tr>
<tr id="row_8_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1array.html" target="_self">etl::array&lt; unsigned char, allocated_ &gt;</a></td><td class="desc"></td></tr>
<tr id="row_9_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_9_" class="arrow" onclick="toggleFolder('9_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>B1</b></td><td class="desc"></td></tr>
<tr id="row_9_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1conjunction_3_01B1_01_4.html" target="_self">etl::conjunction&lt; B1 &gt;</a></td><td class="desc"></td></tr>
<tr id="row_9_1_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1disjunction_3_01B1_01_4.html" target="_self">etl::disjunction&lt; B1 &gt;</a></td><td class="desc"></td></tr>
<tr id="row_10_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1back__insert__iterator.html" target="_self">etl::back_insert_iterator&lt; Container &gt;</a></td><td class="desc">Etl::back_insert_iterator is a LegacyOutputIterator that appends to a container for which it was constructed. The container's push_back() member function is called whenever the iterator (whether dereferenced or not) is assigned to. Incrementing the <a class="el" href="classetl_1_1back__insert__iterator.html" title="etl::back_insert_iterator is a LegacyOutputIterator that appends to a container for which it was cons...">etl::back_insert_iterator</a> is a no-op </td></tr>
<tr id="row_11_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1basic__static__string.html" target="_self">etl::basic_static_string&lt; CharType, Capacity &gt;</a></td><td class="desc">Basic_static_string class with fixed size capacity </td></tr>
<tr id="row_12_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1basic__string__view.html" target="_self">etl::basic_string_view&lt; CharType, Traits &gt;</a></td><td class="desc">The class template <a class="el" href="classetl_1_1basic__string__view.html" title="The class template basic_string_view describes an object that can refer to a constant contiguous sequ...">basic_string_view</a> describes an object that can refer to a constant contiguous sequence of char-like objects with the first element of the sequence at position zero. A typical implementation holds only two members: a pointer to constant CharType and a size </td></tr>
<tr id="row_13_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1bit__and.html" target="_self">etl::bit_and&lt; T &gt;</a></td><td class="desc">Function object for performing bitwise AND. Effectively calls operator&amp; on type T </td></tr>
<tr id="row_14_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1bit__and_3_01void_01_4.html" target="_self">etl::bit_and&lt; void &gt;</a></td><td class="desc">Function object for performing bitwise AND. Effectively calls operator&amp; on type T. The standard library provides a specialization of <a class="el" href="structetl_1_1bit__and.html" title="Function object for performing bitwise AND. Effectively calls operator&amp; on type T. ">etl::bit_and</a> when T is not specified, which leaves the parameter types and return type to be deduced </td></tr>
<tr id="row_15_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1bit__not.html" target="_self">etl::bit_not&lt; T &gt;</a></td><td class="desc">Function object for performing bitwise NOT. Effectively calls operator~ on type T </td></tr>
<tr id="row_16_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1bit__not_3_01void_01_4.html" target="_self">etl::bit_not&lt; void &gt;</a></td><td class="desc">Function object for performing bitwise NOT. Effectively calls operator~ on type T. The standard library provides a specialization of <a class="el" href="structetl_1_1bit__not.html" title="Function object for performing bitwise NOT. Effectively calls operator~ on type T. ">etl::bit_not</a> when T is not specified, which leaves the parameter types and return type to be deduced </td></tr>
<tr id="row_17_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1bit__or.html" target="_self">etl::bit_or&lt; T &gt;</a></td><td class="desc">Function object for performing bitwise OR. Effectively calls operator| on type T </td></tr>
<tr id="row_18_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1bit__or_3_01void_01_4.html" target="_self">etl::bit_or&lt; void &gt;</a></td><td class="desc">Function object for performing bitwise OR. Effectively calls operator| on type T. The standard library provides a specialization of <a class="el" href="structetl_1_1bit__or.html" title="Function object for performing bitwise OR. Effectively calls operator| on type T. ...">etl::bit_or</a> when T is not specified, which leaves the parameter types and return type to be deduced </td></tr>
<tr id="row_19_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1bit__xor.html" target="_self">etl::bit_xor&lt; T &gt;</a></td><td class="desc">Function object for performing bitwise XOR. Effectively calls operator^ on type T </td></tr>
<tr id="row_20_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1bit__xor_3_01void_01_4.html" target="_self">etl::bit_xor&lt; void &gt;</a></td><td class="desc">Function object for performing bitwise XOR. Effectively calls operator^ on type T. The standard library provides a specialization of <a class="el" href="structetl_1_1bit__xor.html" title="Function object for performing bitwise XOR. Effectively calls operator^ on type T. ">etl::bit_xor</a> when T is not specified, which leaves the parameter types and return type to be deduced </td></tr>
<tr id="row_21_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1bitset.html" target="_self">etl::bitset&lt; NumberOfBits &gt;</a></td><td class="desc">The class template bitset represents a fixed-size sequence of N bits. Bitsets can be manipulated by standard logic operators </td></tr>
<tr id="row_22_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1char__traits.html" target="_self">etl::char_traits&lt; charT &gt;</a></td><td class="desc">The <a class="el" href="structetl_1_1char__traits.html" title="The char_traits class is a traits class template that abstracts basic character and string operations...">char_traits</a> class is a traits class template that abstracts basic character and string operations for a given character type. The defined operation set is such that generic algorithms almost always can be implemented in terms of it. It is thus possible to use such algorithms with almost any possible character or string type, just by supplying a customized <a class="el" href="structetl_1_1char__traits.html" title="The char_traits class is a traits class template that abstracts basic character and string operations...">char_traits</a> class. The <a class="el" href="structetl_1_1char__traits.html" title="The char_traits class is a traits class template that abstracts basic character and string operations...">char_traits</a> class template serves as a basis for explicit instantiations. The user can provide a specialization for any custom character types. Several specializations are defined for the standard character types. If an operation on traits emits an exception, the behavior is undefined </td></tr>
<tr id="row_23_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html" target="_self">etl::char_traits&lt; char &gt;</a></td><td class="desc">Specializations of <a class="el" href="structetl_1_1char__traits.html" title="The char_traits class is a traits class template that abstracts basic character and string operations...">char_traits</a> for type char </td></tr>
<tr id="row_24_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1common__type.html" target="_self">etl::common_type&lt;... &gt;</a></td><td class="desc">Determines the common type among all types T..., that is the type all T... can be implicitly converted to. If such a type exists (as determined according to the rules below), the member type names that type. Otherwise, there is no member type. https://en.cppreference.com/w/cpp/types/common_type </td></tr>
<tr id="row_25_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1common__type.html" target="_self">etl::common_type&lt; common_type&lt; T1, T2 &gt;::type, R... &gt;</a></td><td class="desc"></td></tr>
<tr id="row_26_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1common__type_3_01etl_1_1chrono_1_1duration_3_01Rep1_00_01Period1_01_4_00_01etl_1_1cb97b81fdc5f26d47dec1bbf9c7339b38.html" target="_self">etl::common_type&lt; etl::chrono::duration&lt; Rep1, Period1 &gt;, etl::chrono::duration&lt; Rep2, Period2 &gt; &gt;</a></td><td class="desc">Exposes the type named type, which is the common type of two etl::chrono::durations, whose period is the greatest common divisor of Period1 and Period2 </td></tr>
<tr id="row_27_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_27_" class="arrow" onclick="toggleFolder('27_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1common__type.html" target="_self">etl::common_type&lt; T, T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_27_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1common__type_3_01T_01_4.html" target="_self">etl::common_type&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_28_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_28_" class="arrow" onclick="toggleFolder('28_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::common_type_2_impl&lt; etl::decay&lt; T1 &gt;::type, etl::decay&lt; T2 &gt;::type &gt;</b></td><td class="desc"></td></tr>
<tr id="row_28_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1common__type_3_01T1_00_01T2_01_4.html" target="_self">etl::common_type&lt; T1, T2 &gt;</a></td><td class="desc"></td></tr>
<tr id="row_29_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_29_" class="arrow" onclick="toggleFolder('29_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::common_type_multi_impl&lt; void, T1, T2, R... &gt;</b></td><td class="desc"></td></tr>
<tr id="row_29_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1common__type_3_01T1_00_01T2_00_01R_8_8_8_01_4.html" target="_self">etl::common_type&lt; T1, T2, R... &gt;</a></td><td class="desc"></td></tr>
<tr id="row_30_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1conditional.html" target="_self">etl::conditional&lt; B, T, F &gt;</a></td><td class="desc">Provides member typedef type, which is defined as T if B is true at compile time, or as F if B is false </td></tr>
<tr id="row_31_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1conditional_3_01false_00_01T_00_01F_01_4.html" target="_self">etl::conditional&lt; false, T, F &gt;</a></td><td class="desc"></td></tr>
<tr id="row_32_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_32_" class="arrow" onclick="toggleFolder('32_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>conditional_t</b></td><td class="desc"></td></tr>
<tr id="row_32_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1conjunction_3_01B1_00_01Bn_8_8_8_01_4.html" target="_self">etl::conjunction&lt; B1, Bn... &gt;</a></td><td class="desc"></td></tr>
<tr id="row_32_1_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1disjunction_3_01B1_00_01Bn_8_8_8_01_4.html" target="_self">etl::disjunction&lt; B1, Bn... &gt;</a></td><td class="desc"></td></tr>
<tr id="row_33_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1net_1_1const__buffer.html" target="_self">etl::net::const_buffer</a></td><td class="desc"></td></tr>
<tr id="row_34_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1dsp_1_1constant.html" target="_self">etl::dsp::constant&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_35_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1crtp.html" target="_self">etl::crtp&lt; Type, CrtpTag &gt;</a></td><td class="desc"></td></tr>
<tr id="row_36_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_36_" class="arrow" onclick="toggleFolder('36_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1crtp.html" target="_self">etl::crtp&lt; StrongType, addable &gt;</a></td><td class="desc"></td></tr>
<tr id="row_36_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1skill_1_1addable.html" target="_self">etl::experimental::skill::addable&lt; StrongType &gt;</a></td><td class="desc"></td></tr>
<tr id="row_37_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_37_" class="arrow" onclick="toggleFolder('37_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1crtp.html" target="_self">etl::crtp&lt; StrongType, comparable &gt;</a></td><td class="desc"></td></tr>
<tr id="row_37_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1skill_1_1comparable.html" target="_self">etl::experimental::skill::comparable&lt; StrongType &gt;</a></td><td class="desc"></td></tr>
<tr id="row_38_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_38_" class="arrow" onclick="toggleFolder('38_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1crtp.html" target="_self">etl::crtp&lt; StrongType, divisible &gt;</a></td><td class="desc"></td></tr>
<tr id="row_38_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1skill_1_1divisible.html" target="_self">etl::experimental::skill::divisible&lt; StrongType &gt;</a></td><td class="desc"></td></tr>
<tr id="row_39_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_39_" class="arrow" onclick="toggleFolder('39_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1crtp.html" target="_self">etl::crtp&lt; StrongType, multipliable &gt;</a></td><td class="desc"></td></tr>
<tr id="row_39_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1skill_1_1multipliable.html" target="_self">etl::experimental::skill::multipliable&lt; StrongType &gt;</a></td><td class="desc"></td></tr>
<tr id="row_40_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_40_" class="arrow" onclick="toggleFolder('40_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1crtp.html" target="_self">etl::crtp&lt; StrongType, subtractable &gt;</a></td><td class="desc"></td></tr>
<tr id="row_40_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1skill_1_1subtractable.html" target="_self">etl::experimental::skill::subtractable&lt; StrongType &gt;</a></td><td class="desc"></td></tr>
<tr id="row_41_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1decay.html" target="_self">etl::decay&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_42_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1default__delete.html" target="_self">etl::default_delete&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_43_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1default__delete_3_01T[]_4.html" target="_self">etl::default_delete&lt; T[]&gt;</a></td><td class="desc"></td></tr>
<tr id="row_44_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1default__searcher.html" target="_self">etl::default_searcher&lt; ForwardIter, Predicate &gt;</a></td><td class="desc">Default searcher. A class suitable for use with Searcher overload of <a class="el" href="namespaceetl.html#a7813a73d80057255ef78a69804f2f361" title="Searches for the first occurrence of the sequence of elements [s_first, s_last) in the range [first...">etl::search</a> that delegates the search operation to the pre-C++17 standard library's <a class="el" href="namespaceetl.html#a7813a73d80057255ef78a69804f2f361" title="Searches for the first occurrence of the sequence of elements [s_first, s_last) in the range [first...">etl::search</a> </td></tr>
<tr id="row_45_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1defer__lock__t.html" target="_self">etl::defer_lock_t</a></td><td class="desc">Empty class tag types used to specify locking strategy for <a class="el" href="classetl_1_1lock__guard.html" title="The class lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a ...">etl::lock_guard</a>, <a class="el" href="classetl_1_1scoped__lock.html" title="RAII based lock. ">etl::scoped_lock</a>, etl::unique_lock, and etl::shared_lock </td></tr>
<tr id="row_46_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1dsp_1_1delay.html" target="_self">etl::dsp::delay&lt; T, Z &gt;</a></td><td class="desc"></td></tr>
<tr id="row_47_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::den)&gt;</a></td><td class="desc"></td></tr>
<tr id="row_48_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::den)&gt;</a></td><td class="desc"></td></tr>
<tr id="row_49_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_49_" class="arrow" onclick="toggleFolder('49_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::den&lt; R2::num *R1::den)&gt;</a></td><td class="desc"></td></tr>
<tr id="row_49_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1ratio__less.html" target="_self">etl::ratio_less&lt; R1, R2 &gt;</a></td><td class="desc">Compares two ratio objects for equality at compile-time. If the ratio R1 is less than the ratio R2, provides the member constant value equal true. Otherwise, value is false </td></tr>
<tr id="row_50_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_50_" class="arrow" onclick="toggleFolder('50_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::den&lt;=R2::num *R1::den)&gt;</a></td><td class="desc"></td></tr>
<tr id="row_50_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1ratio__less__equal.html" target="_self">etl::ratio_less_equal&lt; R1, R2 &gt;</a></td><td class="desc">Compares two ratio objects for equality at compile-time. If the ratio R1 is less than or equal to the ratio R2, provides the member constant value equal true. Otherwise, value is false </td></tr>
<tr id="row_51_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1hardware_1_1mcp23017_1_1device.html" target="_self">etl::hardware::mcp23017::device&lt; Driver &gt;</a></td><td class="desc"></td></tr>
<tr id="row_52_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1divides.html" target="_self">etl::divides&lt; T &gt;</a></td><td class="desc">Function object for performing division. Effectively calls operator/ on two instances of type T </td></tr>
<tr id="row_53_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1divides_3_01void_01_4.html" target="_self">etl::divides&lt; void &gt;</a></td><td class="desc">Function object for performing division. Effectively calls operator/ on two instances of type T. The standard library provides a specialization of <a class="el" href="structetl_1_1divides.html" title="Function object for performing division. Effectively calls operator/ on two instances of type T...">etl::divides</a> when T is not specified, which leaves the parameter types and return type to be deduced </td></tr>
<tr id="row_54_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1chrono_1_1duration.html" target="_self">etl::chrono::duration&lt; Rep, Period &gt;</a></td><td class="desc">Class template <a class="el" href="classetl_1_1chrono_1_1duration.html" title="Class template etl::chrono::duration represents a time interval. ">etl::chrono::duration</a> represents a time interval </td></tr>
<tr id="row_55_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1chrono_1_1duration__values.html" target="_self">etl::chrono::duration_values&lt; Rep &gt;</a></td><td class="desc">The <a class="el" href="structetl_1_1chrono_1_1duration__values.html" title="The etl::chrono::duration_values type defines three common durations. ">etl::chrono::duration_values</a> type defines three common durations </td></tr>
<tr id="row_56_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1enable__if.html" target="_self">etl::enable_if&lt; bool, Type &gt;</a></td><td class="desc">Define a member typedef only if a boolean constant is true </td></tr>
<tr id="row_57_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1enable__if_3_01true_00_01Type_01_4.html" target="_self">etl::enable_if&lt; true, Type &gt;</a></td><td class="desc"></td></tr>
<tr id="row_58_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1equal__to.html" target="_self">etl::equal_to&lt; T &gt;</a></td><td class="desc">Function object for performing comparisons. Unless specialised, invokes operator== on type T </td></tr>
<tr id="row_59_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1equal__to_3_01void_01_4.html" target="_self">etl::equal_to&lt; void &gt;</a></td><td class="desc">Function object for performing comparisons. Unless specialised, invokes operator== on type T. The standard library provides a specialization of <a class="el" href="structetl_1_1equal__to.html" title="Function object for performing comparisons. Unless specialised, invokes operator== on type T...">etl::equal_to</a> when T is not specified, which leaves the parameter types and return type to be deduced </td></tr>
<tr id="row_60_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1dsp_1_1feedback__drain.html" target="_self">etl::dsp::feedback_drain&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_61_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1dsp_1_1feedback__tap.html" target="_self">etl::dsp::feedback_tap&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_62_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1rtos_1_1forever.html" target="_self">etl::rtos::forever</a></td><td class="desc">Runs the task loop forever </td></tr>
<tr id="row_63_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1fpos.html" target="_self">etl::fpos&lt; State &gt;</a></td><td class="desc"></td></tr>
<tr id="row_64_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1front__insert__iterator.html" target="_self">etl::front_insert_iterator&lt; Container &gt;</a></td><td class="desc">Etl::front_insert_iterator is an LegacyOutputIterator that prepends elements to a container for which it was constructed. The container's push_front() member function is called whenever the iterator (whether dereferenced or not) is assigned to. Incrementing the <a class="el" href="classetl_1_1front__insert__iterator.html" title="etl::front_insert_iterator is an LegacyOutputIterator that prepends elements to a container for which...">etl::front_insert_iterator</a> is a no-op </td></tr>
<tr id="row_65_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1function.html" target="_self">etl::function&lt; size_t, class &gt;</a></td><td class="desc"></td></tr>
<tr id="row_66_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1function__view.html" target="_self">etl::function_view&lt; class &gt;</a></td><td class="desc"></td></tr>
<tr id="row_67_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_67_" class="arrow" onclick="toggleFolder('67_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1function__view_3_01Result_07Arguments_8_8_8_08_4.html" target="_self">etl::function_view&lt; Result(Arguments...)&gt;</a></td><td class="desc"></td></tr>
<tr id="row_67_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1function_3_01Capacity_00_01Result_07Arguments_8_8_8_08_4.html" target="_self">etl::function&lt; Capacity, Result(Arguments...)&gt;</a></td><td class="desc"></td></tr>
<tr id="row_68_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1hardware_1_1stm32_1_1gpio__memory__layout.html" target="_self">etl::hardware::stm32::gpio_memory_layout</a></td><td class="desc"></td></tr>
<tr id="row_69_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1greater.html" target="_self">etl::greater&lt; T &gt;</a></td><td class="desc">Function object for performing comparisons. Unless specialised, invokes operator&gt; on type T </td></tr>
<tr id="row_70_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1greater_3_01void_01_4.html" target="_self">etl::greater&lt; void &gt;</a></td><td class="desc">Function object for performing comparisons. Unless specialised, invokes operator&gt; on type T. The standard library provides a specialization of <a class="el" href="structetl_1_1greater.html" title="Function object for performing comparisons. Unless specialised, invokes operator&gt; on type T...">etl::greater</a> when T is not specified, which leaves the parameter types and return type to be deduced </td></tr>
<tr id="row_71_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1greater__equal.html" target="_self">etl::greater_equal&lt; T &gt;</a></td><td class="desc">Function object for performing comparisons. Unless specialised, invokes operator&gt;= on type T </td></tr>
<tr id="row_72_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1greater__equal_3_01void_01_4.html" target="_self">etl::greater_equal&lt; void &gt;</a></td><td class="desc">Function object for performing comparisons. Unless specialised, invokes operator&gt; on type T. The standard library provides a specialization of <a class="el" href="structetl_1_1greater__equal.html" title="Function object for performing comparisons. Unless specialised, invokes operator&gt;= on type T...">etl::greater_equal</a> when T is not specified, which leaves the parameter types and return type to be deduced </td></tr>
<tr id="row_73_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1dsp_1_1identity.html" target="_self">etl::dsp::identity</a></td><td class="desc"></td></tr>
<tr id="row_74_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1in__place__index__t.html" target="_self">etl::in_place_index_t&lt; I &gt;</a></td><td class="desc">Disambiguation tags that can be passed to the constructors of <a class="el" href="classetl_1_1optional.html">etl::optional</a>, <a class="el" href="classetl_1_1variant.html" title="The class template etl::variant represents a type-safe union. An instance of etl::variant at any give...">etl::variant</a>, and etl::any to indicate that the contained object should be constructed in-place, and (for the latter two) the type of the object to be constructed </td></tr>
<tr id="row_75_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1in__place__t.html" target="_self">etl::in_place_t</a></td><td class="desc">Disambiguation tags that can be passed to the constructors of <a class="el" href="classetl_1_1optional.html">etl::optional</a>, <a class="el" href="classetl_1_1variant.html" title="The class template etl::variant represents a type-safe union. An instance of etl::variant at any give...">etl::variant</a>, and etl::any to indicate that the contained object should be constructed in-place, and (for the latter two) the type of the object to be constructed </td></tr>
<tr id="row_76_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1in__place__type__t.html" target="_self">etl::in_place_type_t&lt; T &gt;</a></td><td class="desc">Disambiguation tags that can be passed to the constructors of <a class="el" href="classetl_1_1optional.html">etl::optional</a>, <a class="el" href="classetl_1_1variant.html" title="The class template etl::variant represents a type-safe union. An instance of etl::variant at any give...">etl::variant</a>, and etl::any to indicate that the contained object should be constructed in-place, and (for the latter two) the type of the object to be constructed </td></tr>
<tr id="row_77_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_77_" class="arrow" onclick="toggleFolder('77_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1input__iterator__tag.html" target="_self">etl::input_iterator_tag</a></td><td class="desc">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories </td></tr>
<tr id="row_77_0_" class="even" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_77_0_" class="arrow" onclick="toggleFolder('77_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1forward__iterator__tag.html" target="_self">etl::forward_iterator_tag</a></td><td class="desc">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories </td></tr>
<tr id="row_77_0_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span id="arr_77_0_0_" class="arrow" onclick="toggleFolder('77_0_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1bidirectional__iterator__tag.html" target="_self">etl::bidirectional_iterator_tag</a></td><td class="desc">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories </td></tr>
<tr id="row_77_0_0_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span id="arr_77_0_0_0_" class="arrow" onclick="toggleFolder('77_0_0_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1random__access__iterator__tag.html" target="_self">etl::random_access_iterator_tag</a></td><td class="desc">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories </td></tr>
<tr id="row_77_0_0_0_0_" class="even" style="display:none;"><td class="entry"><span style="width:80px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1contiguous__iterator__tag.html" target="_self">etl::contiguous_iterator_tag</a></td><td class="desc">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories </td></tr>
<tr id="row_78_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_78_" class="arrow" onclick="toggleFolder('78_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; Type, val &gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1conjunction.html" target="_self">etl::conjunction&lt;... &gt;</a></td><td class="desc">Forms the logical conjunction of the type traits B..., effectively performing a logical AND on the sequence of traits </td></tr>
<tr id="row_78_1_" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_78_1_" class="arrow" onclick="toggleFolder('78_1_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::is_constructible_helper&lt; class, T, Args &gt;</b></td><td class="desc"></td></tr>
<tr id="row_78_1_0_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__copy__constructible.html" target="_self">etl::is_copy_constructible&lt; T &gt;</a></td><td class="desc">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to etl::is_constructible&lt;T, const T&amp;&gt;::value </td></tr>
<tr id="row_78_1_1_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__default__constructible.html" target="_self">etl::is_default_constructible&lt; T &gt;</a></td><td class="desc">If etl::is_constructible&lt;T&gt;::value is true, provides the member constant value equal to true, otherwise value is false </td></tr>
<tr id="row_78_1_2_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__move__constructible.html" target="_self">etl::is_move_constructible&lt; T &gt;</a></td><td class="desc">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to etl::is_constructible&lt;T, T&amp;&amp;&gt;::value </td></tr>
<tr id="row_78_2_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1disjunction.html" target="_self">etl::disjunction&lt;... &gt;</a></td><td class="desc">Forms the logical disjunction of the type traits B..., effectively performing a logical OR on the sequence of traits </td></tr>
<tr id="row_78_3_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1has__virtual__destructor.html" target="_self">etl::has_virtual_destructor&lt; T &gt;</a></td><td class="desc">Https://en.cppreference.com/w/cpp/types/has_virtual_destructor </td></tr>
<tr id="row_78_4_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__abstract.html" target="_self">etl::is_abstract&lt; T &gt;</a></td><td class="desc">Is_abstract </td></tr>
<tr id="row_78_5_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__aggregate.html" target="_self">etl::is_aggregate&lt; T &gt;</a></td><td class="desc">Is_aggregate </td></tr>
<tr id="row_78_6_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__arithmetic.html" target="_self">etl::is_arithmetic&lt; T &gt;</a></td><td class="desc">If T is an arithmetic type (that is, an integral type or a floating-point type) or a cv-qualified version thereof, provides the member constant value equal true. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__arithmetic.html" title="If T is an arithmetic type (that is, an integral type or a floating-point type) or a cv-qualified ver...">is_arithmetic</a> or is_arithmetic_v (since C++17) is undefined </td></tr>
<tr id="row_78_7_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__array.html" target="_self">etl::is_array&lt; T &gt;</a></td><td class="desc">Checks whether T is an array type. Provides the member constant value which is equal to true, if T is an array type. Otherwise, value is equal to false </td></tr>
<tr id="row_78_8_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__array_3_01T[]_4.html" target="_self">etl::is_array&lt; T[]&gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_9_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__array_3_01T[N]_4.html" target="_self">etl::is_array&lt; T[N]&gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_10_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__assignable.html" target="_self">etl::is_assignable&lt; T, U &gt;</a></td><td class="desc">If the expression <a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292" title="Converts any type T to a reference type, making it possible to use member functions in decltype expre...">etl::declval&lt;T&gt;()</a> = <a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292" title="Converts any type T to a reference type, making it possible to use member functions in decltype expre...">etl::declval&lt;U&gt;()</a> is well-formed in unevaluated context, provides the member constant value equal true. Otherwise, value is false. Access checks are performed as if from a context unrelated to either type </td></tr>
<tr id="row_78_11_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__base__of.html" target="_self">etl::is_base_of&lt; Base, Derived &gt;</a></td><td class="desc">If Derived is derived from Base or if both are the same non-union class (in both cases ignoring cv-qualification), provides the member constant value equal to true. Otherwise value is false </td></tr>
<tr id="row_78_12_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__bounded__array.html" target="_self">etl::is_bounded_array&lt; T &gt;</a></td><td class="desc">Checks whether T is an array type of known bound. Provides the member constant value which is equal to true, if T is an array type of known bound. Otherwise, value is equal to false </td></tr>
<tr id="row_78_13_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__bounded__array_3_01T[N]_4.html" target="_self">etl::is_bounded_array&lt; T[N]&gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_14_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__class.html" target="_self">etl::is_class&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_15_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__compound.html" target="_self">etl::is_compound&lt; T &gt;</a></td><td class="desc">If T is a compound type (that is, array, function, object pointer, function pointer, member object pointer, member function pointer, reference, class, union, or enumeration, including any cv-qualified variants), provides the member constant value equal true. For any other type, value is false </td></tr>
<tr id="row_78_16_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__const.html" target="_self">etl::is_const&lt; T &gt;</a></td><td class="desc">If T is a const-qualified type (that is, const, or const volatile), provides the member constant value equal to true. For any other type, value is false </td></tr>
<tr id="row_78_17_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__const_3_01const_01T_01_4.html" target="_self">etl::is_const&lt; const T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_18_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__destructible_3_01Type[]_4.html" target="_self">etl::is_destructible&lt; Type[]&gt;</a></td><td class="desc">Https://en.cppreference.com/w/cpp/types/is_destructible </td></tr>
<tr id="row_78_19_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__destructible_3_01void_01_4.html" target="_self">etl::is_destructible&lt; void &gt;</a></td><td class="desc">Https://en.cppreference.com/w/cpp/types/is_destructible </td></tr>
<tr id="row_78_20_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__enum.html" target="_self">etl::is_enum&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_21_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__error__code__enum.html" target="_self">etl::is_error_code_enum&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_22_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__error__condition__enum.html" target="_self">etl::is_error_condition_enum&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_23_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__error__condition__enum_3_01errc_01_4.html" target="_self">etl::is_error_condition_enum&lt; errc &gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_24_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__final.html" target="_self">etl::is_final&lt; T &gt;</a></td><td class="desc">If T is a final class (that is, a class declared with the final specifier), provides the member constant value equal true. For any other type, value is false. If T is a class type, T shall be a complete type; otherwise, the behavior is undefined </td></tr>
<tr id="row_78_25_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__floating__point.html" target="_self">etl::is_floating_point&lt; T &gt;</a></td><td class="desc">Checks whether T is a floating-point type. Provides the member constant value which is equal to true, if T is the type float, double, long double, including any cv-qualified variants. Otherwise, value is equal to false </td></tr>
<tr id="row_78_26_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__function.html" target="_self">etl::is_function&lt; T &gt;</a></td><td class="desc">Checks whether T is a function type. Types like <a class="el" href="classetl_1_1function.html">etl::function</a>, lambdas, classes with overloaded operator() and pointers to functions don't count as function types. Provides the member constant value which is equal to true, if T is a function type. Otherwise, value is equal to false </td></tr>
<tr id="row_78_27_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__fundamental.html" target="_self">etl::is_fundamental&lt; T &gt;</a></td><td class="desc">If T is a fundamental type (that is, arithmetic type, void, or nullptr_t), provides the member constant value equal true. For any other type, value is false </td></tr>
<tr id="row_78_28_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__integral.html" target="_self">etl::is_integral&lt; Type &gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_29_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__lvalue__reference.html" target="_self">etl::is_lvalue_reference&lt; T &gt;</a></td><td class="desc">Checks whether T is a lvalue reference type. Provides the member constant value which is equal to true, if T is a lvalue reference type. Otherwise, value is equal to false </td></tr>
<tr id="row_78_30_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__lvalue__reference_3_01T_01_6_01_4.html" target="_self">etl::is_lvalue_reference&lt; T &amp; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_31_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__member__object__pointer.html" target="_self">etl::is_member_object_pointer&lt; T &gt;</a></td><td class="desc">Checks whether T is a non-static member object pointer. Provides the member constant value which is equal to true, if T is a non-static member object pointer type. Otherwise, value is equal to false </td></tr>
<tr id="row_78_32_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__constructible.html" target="_self">etl::is_nothrow_constructible&lt; T, Args &gt;</a></td><td class="desc">The variable definition does not call any operation that is not trivial. For the purposes of this check, the call to <a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292" title="Converts any type T to a reference type, making it possible to use member functions in decltype expre...">etl::declval</a> is considered trivial </td></tr>
<tr id="row_78_33_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__destructible_3_01Type_01_6_01_4.html" target="_self">etl::is_nothrow_destructible&lt; Type &amp; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_34_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__destructible_3_01Type_01_6_6_01_4.html" target="_self">etl::is_nothrow_destructible&lt; Type &amp;&amp; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_35_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__object.html" target="_self">etl::is_object&lt; T &gt;</a></td><td class="desc">If T is an object type (that is any possibly cv-qualified type other than function, reference, or void types), provides the member constant value equal true. For any other type, value is false </td></tr>
<tr id="row_78_36_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__polymorphic.html" target="_self">etl::is_polymorphic&lt; T &gt;</a></td><td class="desc">Is_polymorphic </td></tr>
<tr id="row_78_37_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__reference.html" target="_self">etl::is_reference&lt; T &gt;</a></td><td class="desc">If T is a reference type (lvalue reference or rvalue reference), provides the member constant value equal true. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__reference.html" title="If T is a reference type (lvalue reference or rvalue reference), provides the member constant value e...">is_reference</a> or is_reference_v is undefined </td></tr>
<tr id="row_78_38_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__reference_3_01T_01_6_01_4.html" target="_self">etl::is_reference&lt; T &amp; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_39_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__reference_3_01T_01_6_6_01_4.html" target="_self">etl::is_reference&lt; T &amp;&amp; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_40_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__rvalue__reference.html" target="_self">etl::is_rvalue_reference&lt; T &gt;</a></td><td class="desc">Checks whether T is a rvalue reference type. Provides the member constant value which is equal to true, if T is a rvalue reference type. Otherwise, value is equal to false </td></tr>
<tr id="row_78_41_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__rvalue__reference_3_01T_01_6_6_01_4.html" target="_self">etl::is_rvalue_reference&lt; T &amp;&amp; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_42_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__same.html" target="_self">etl::is_same&lt; T, U &gt;</a></td><td class="desc">If T and U name the same type (taking into account const/volatile qualifications), provides the member constant value equal to true. Otherwise value is false </td></tr>
<tr id="row_78_43_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__same_3_01T_00_01T_01_4.html" target="_self">etl::is_same&lt; T, T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_44_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__scalar.html" target="_self">etl::is_scalar&lt; T &gt;</a></td><td class="desc">If T is a scalar type (that is a possibly cv-qualified arithmetic, pointer, pointer to member, enumeration, or <a class="el" href="namespaceetl.html#adf4272f3f16bf2234ac8248db615f133">etl::nullptr_t</a> type), provides the member constant value equal true. For any other type, value is false </td></tr>
<tr id="row_78_45_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__swappable.html" target="_self">etl::is_swappable&lt; T &gt;</a></td><td class="desc">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to etl::is_swappable_with&lt;T&amp;, T&amp;&gt;::value </td></tr>
<tr id="row_78_46_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__trivial.html" target="_self">etl::is_trivial&lt; T &gt;</a></td><td class="desc">If T is TrivialType (that is, a scalar type, a trivially copyable class with a trivial default constructor, or array of such type/class, possibly cv-qualified), provides the member constant value equal to true. For any other type, value is false </td></tr>
<tr id="row_78_47_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__trivially__assignable.html" target="_self">etl::is_trivially_assignable&lt; T, U &gt;</a></td><td class="desc">If the expression <a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292" title="Converts any type T to a reference type, making it possible to use member functions in decltype expre...">etl::declval&lt;T&gt;()</a> = <a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292" title="Converts any type T to a reference type, making it possible to use member functions in decltype expre...">etl::declval&lt;U&gt;()</a> is well-formed in unevaluated context, provides the member constant value equal true. Otherwise, value is false. Access checks are performed as if from a context unrelated to either type </td></tr>
<tr id="row_78_48_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__trivially__constructible.html" target="_self">etl::is_trivially_constructible&lt; T, Args &gt;</a></td><td class="desc">The variable definition does not call any operation that is not trivial. For the purposes of this check, the call to <a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292" title="Converts any type T to a reference type, making it possible to use member functions in decltype expre...">etl::declval</a> is considered trivial </td></tr>
<tr id="row_78_49_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1is__trivially__copyable_3_01T_01_5_01_4.html" target="_self">etl::is_trivially_copyable&lt; T * &gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_50_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__trivially__destructible.html" target="_self">etl::is_trivially_destructible&lt; T &gt;</a></td><td class="desc">Https://en.cppreference.com/w/cpp/types/is_destructible </td></tr>
<tr id="row_78_51_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__unbounded__array.html" target="_self">etl::is_unbounded_array&lt; T &gt;</a></td><td class="desc">Checks whether T is an array type of unknown bound. Provides the member constant value which is equal to true, if T is an array type of unknown bound. Otherwise, value is equal to false </td></tr>
<tr id="row_78_52_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__unbounded__array_3_01T[]_4.html" target="_self">etl::is_unbounded_array&lt; T[]&gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_53_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__union.html" target="_self">etl::is_union&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_54_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__volatile.html" target="_self">etl::is_volatile&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_55_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__volatile_3_01volatile_01T_01_4.html" target="_self">etl::is_volatile&lt; volatile T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_56_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1negation.html" target="_self">etl::negation&lt; B &gt;</a></td><td class="desc">Forms the logical negation of the type trait B </td></tr>
<tr id="row_78_57_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1ratio__greater.html" target="_self">etl::ratio_greater&lt; R1, R2 &gt;</a></td><td class="desc">Compares two ratio objects for equality at compile-time. If the ratio R1 is greater than the ratio R2, provides the member constant value equal true. Otherwise, value is false </td></tr>
<tr id="row_78_58_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1ratio__greater__equal.html" target="_self">etl::ratio_greater_equal&lt; R1, R2 &gt;</a></td><td class="desc">Compares two ratio objects for equality at compile-time. If the ratio R1 is greater than or equal to the ratio R2, provides the member constant value equal true. Otherwise, value is false </td></tr>
<tr id="row_78_59_" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_78_59_" class="arrow" onclick="toggleFolder('78_59_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__assignable.html" target="_self">etl::is_assignable&lt; etl::add_lvalue_reference&lt; T &gt;::type, etl::add_lvalue_reference&lt; const T &gt;::type &gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_59_0_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__copy__assignable.html" target="_self">etl::is_copy_assignable&lt; T &gt;</a></td><td class="desc">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#ac6a0d38654d5eeea44e25fea4eae7a55">etl::is_assignable&lt;T&amp;, const T&amp;&gt;::value</a> </td></tr>
<tr id="row_78_60_" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_78_60_" class="arrow" onclick="toggleFolder('78_60_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__assignable.html" target="_self">etl::is_assignable&lt; etl::add_lvalue_reference&lt; T &gt;::type, etl::add_rvalue_reference&lt; T &gt;::type &gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_60_0_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__move__assignable.html" target="_self">etl::is_move_assignable&lt; T &gt;</a></td><td class="desc">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#ac6a0d38654d5eeea44e25fea4eae7a55">etl::is_assignable&lt;T&amp;, T&amp;&amp;&gt;::value</a> </td></tr>
<tr id="row_78_61_" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_78_61_" class="arrow" onclick="toggleFolder('78_61_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::is_empty_helper&lt; T &gt;</b></td><td class="desc"></td></tr>
<tr id="row_78_61_0_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__empty.html" target="_self">etl::is_empty&lt; T &gt;</a></td><td class="desc">F T is an empty type (that is, a non-union class type with no non-static data members other than bit-fields of size 0, no virtual functions, no virtual base classes, and no non-empty base classes), provides the member constant value equal to true. For any other type, value is false </td></tr>
<tr id="row_78_62_" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_78_62_" class="arrow" onclick="toggleFolder('78_62_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__floating__point.html" target="_self">etl::is_floating_point&lt; Rep &gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_62_0_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1chrono_1_1treat__as__floating__point.html" target="_self">etl::chrono::treat_as_floating_point&lt; Rep &gt;</a></td><td class="desc">The <a class="el" href="structetl_1_1chrono_1_1treat__as__floating__point.html" title="The etl::chrono::treat_as_floating_point trait helps determine if a duration can be converted to anot...">etl::chrono::treat_as_floating_point</a> trait helps determine if a duration can be converted to another duration with a different tick period </td></tr>
<tr id="row_78_63_" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_78_63_" class="arrow" onclick="toggleFolder('78_63_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::is_member_function_pointer_helper&lt; etl::remove_cv_t&lt; T &gt; &gt;</b></td><td class="desc"></td></tr>
<tr id="row_78_63_0_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__member__function__pointer.html" target="_self">etl::is_member_function_pointer&lt; T &gt;</a></td><td class="desc">Checks whether T is a non-static member function pointer. Provides the member constant value which is equal to true, if T is a non-static member function pointer type. Otherwise, value is equal to false </td></tr>
<tr id="row_78_64_" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_78_64_" class="arrow" onclick="toggleFolder('78_64_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::is_member_pointer_helper&lt; etl::remove_cv_t&lt; T &gt; &gt;</b></td><td class="desc"></td></tr>
<tr id="row_78_64_0_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__member__pointer.html" target="_self">etl::is_member_pointer&lt; T &gt;</a></td><td class="desc">If T is pointer to non-static member object or a pointer to non-static member function, provides the member constant value equal true. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__member__pointer.html" title="If T is pointer to non-static member object or a pointer to non-static member function, provides the member constant value equal true. For any other type, value is false. The behavior of a program that adds specializations for is_member_pointer or is_member_pointer_v (since C++17) is undefined. ">is_member_pointer</a> or is_member_pointer_v (since C++17) is undefined </td></tr>
<tr id="row_78_65_" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_78_65_" class="arrow" onclick="toggleFolder('78_65_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__constructible.html" target="_self">etl::is_nothrow_constructible&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_65_0_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__default__constructible.html" target="_self">etl::is_nothrow_default_constructible&lt; T &gt;</a></td><td class="desc">If <a class="el" href="structetl_1_1integral__constant.html#ac6a0d38654d5eeea44e25fea4eae7a55">etl::is_nothrow_constructible&lt;T&gt;::value</a> is true, provides the member constant value equal to true, otherwise value is false </td></tr>
<tr id="row_78_66_" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_78_66_" class="arrow" onclick="toggleFolder('78_66_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__constructible.html" target="_self">etl::is_nothrow_constructible&lt; T, etl::add_lvalue_reference_t&lt; etl::add_const_t&lt; T &gt; &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_66_0_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__copy__constructible.html" target="_self">etl::is_nothrow_copy_constructible&lt; T &gt;</a></td><td class="desc">Same as copy, but uses etl::is_nothrow_constructible&lt;T, const T&amp;&gt; </td></tr>
<tr id="row_78_67_" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_78_67_" class="arrow" onclick="toggleFolder('78_67_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__constructible.html" target="_self">etl::is_nothrow_constructible&lt; T, etl::add_rvalue_reference_t&lt; T &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_67_0_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__move__constructible.html" target="_self">etl::is_nothrow_move_constructible&lt; T &gt;</a></td><td class="desc">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#ac6a0d38654d5eeea44e25fea4eae7a55">etl::is_nothrow_constructible&lt;T, T&amp;&amp;&gt;::value</a> </td></tr>
<tr id="row_78_68_" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_78_68_" class="arrow" onclick="toggleFolder('78_68_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::is_nothrow_swappable_helper&lt; is_swappable&lt; T &gt;::value, T &gt;</b></td><td class="desc"></td></tr>
<tr id="row_78_68_0_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__swappable.html" target="_self">etl::is_nothrow_swappable&lt; T &gt;</a></td><td class="desc">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to etl::is_nothrow_swappable_with&lt;T&amp;, T&amp;&gt;::value </td></tr>
<tr id="row_78_69_" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_78_69_" class="arrow" onclick="toggleFolder('78_69_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::is_pointer_helper&lt; remove_cv&lt; T &gt;::type &gt;</b></td><td class="desc"></td></tr>
<tr id="row_78_69_0_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__pointer.html" target="_self">etl::is_pointer&lt; T &gt;</a></td><td class="desc">Checks whether T is a pointer to object or a pointer to function (but not a pointer to member/member function). Provides the member constant value which is equal to true, if T is a object/function pointer type. Otherwise, value is equal to false </td></tr>
<tr id="row_78_70_" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_78_70_" class="arrow" onclick="toggleFolder('78_70_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__same.html" target="_self">etl::is_same&lt; nullptr_t, remove_cv_t&lt; T &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_70_0_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__null__pointer.html" target="_self">etl::is_null_pointer&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_71_" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_78_71_" class="arrow" onclick="toggleFolder('78_71_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__same.html" target="_self">etl::is_same&lt; void, remove_cv&lt; T &gt;::type &gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_71_0_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__void.html" target="_self">etl::is_void&lt; T &gt;</a></td><td class="desc">Define a member typedef only if a boolean constant is true </td></tr>
<tr id="row_78_72_" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_78_72_" class="arrow" onclick="toggleFolder('78_72_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__trivially__assignable.html" target="_self">etl::is_trivially_assignable&lt; etl::add_lvalue_reference&lt; T &gt;::type, etl::add_lvalue_reference&lt; const T &gt;::type &gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_72_0_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__trivially__copy__assignable.html" target="_self">etl::is_trivially_copy_assignable&lt; T &gt;</a></td><td class="desc">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#ac6a0d38654d5eeea44e25fea4eae7a55">etl::is_trivially_assignable&lt;T&amp;, const T&amp;&gt;::value</a> </td></tr>
<tr id="row_78_73_" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_78_73_" class="arrow" onclick="toggleFolder('78_73_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__trivially__assignable.html" target="_self">etl::is_trivially_assignable&lt; etl::add_lvalue_reference&lt; T &gt;::type, etl::add_rvalue_reference&lt; T &gt;::type &gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_73_0_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__trivially__move__assignable.html" target="_self">etl::is_trivially_move_assignable&lt; T &gt;</a></td><td class="desc">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#ac6a0d38654d5eeea44e25fea4eae7a55">etl::is_assignable&lt;T&amp;, T&amp;&amp;&gt;::value</a> </td></tr>
<tr id="row_78_74_" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_78_74_" class="arrow" onclick="toggleFolder('78_74_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__trivially__constructible.html" target="_self">etl::is_trivially_constructible&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_74_0_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__trivially__default__constructible.html" target="_self">etl::is_trivially_default_constructible&lt; T &gt;</a></td><td class="desc">If <a class="el" href="structetl_1_1integral__constant.html#ac6a0d38654d5eeea44e25fea4eae7a55">etl::is_trivially_constructible&lt;T&gt;::value</a> is true, provides the member constant value equal to true, otherwise value is false </td></tr>
<tr id="row_78_75_" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_78_75_" class="arrow" onclick="toggleFolder('78_75_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__trivially__constructible.html" target="_self">etl::is_trivially_constructible&lt; T, etl::add_lvalue_reference_t&lt; etl::add_const_t&lt; T &gt; &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_75_0_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__trivially__copy__constructible.html" target="_self">etl::is_trivially_copy_constructible&lt; T &gt;</a></td><td class="desc">Same as copy, but uses etl::is_trivially_constructible&lt;T, const T&amp;&gt; </td></tr>
<tr id="row_78_76_" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_78_76_" class="arrow" onclick="toggleFolder('78_76_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__trivially__constructible.html" target="_self">etl::is_trivially_constructible&lt; T, etl::add_rvalue_reference_t&lt; T &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_78_76_0_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__trivially__move__constructible.html" target="_self">etl::is_trivially_move_constructible&lt; T &gt;</a></td><td class="desc">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#ac6a0d38654d5eeea44e25fea4eae7a55">etl::is_trivially_constructible&lt;T, T&amp;&amp;&gt;::value</a> </td></tr>
<tr id="row_79_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_79_" class="arrow" onclick="toggleFolder('79_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; bool, !etl::ratio_equal_v&lt; R1, R2 &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_79_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1ratio__not__equal.html" target="_self">etl::ratio_not_equal&lt; R1, R2 &gt;</a></td><td class="desc">Compares two ratio objects for equality at compile-time. If the ratios R1 and R2 are not equal, provides the member constant value equal true. Otherwise, value is false </td></tr>
<tr id="row_80_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_80_" class="arrow" onclick="toggleFolder('80_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; bool, is_assignable_v&lt; etl::add_lvalue_reference&lt; T &gt;::type, etl::add_lvalue_reference&lt; const T &gt;::type &gt; &amp;&amp;detail::is_nothrow_assignable_helper&lt; etl::add_lvalue_reference&lt; T &gt;::type, etl::add_lvalue_reference&lt; const T &gt;::type &gt;::value &gt;</a></td><td class="desc"></td></tr>
<tr id="row_80_0_" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_80_0_" class="arrow" onclick="toggleFolder('80_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__assignable.html" target="_self">etl::is_nothrow_assignable&lt; etl::add_lvalue_reference&lt; T &gt;::type, etl::add_lvalue_reference&lt; const T &gt;::type &gt;</a></td><td class="desc"></td></tr>
<tr id="row_80_0_0_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__copy__assignable.html" target="_self">etl::is_nothrow_copy_assignable&lt; T &gt;</a></td><td class="desc">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#ac6a0d38654d5eeea44e25fea4eae7a55">etl::is_nothrow_assignable&lt;T&amp;, const T&amp;&gt;::value</a> </td></tr>
<tr id="row_81_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_81_" class="arrow" onclick="toggleFolder('81_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; bool, is_assignable_v&lt; etl::add_lvalue_reference&lt; T &gt;::type, etl::add_rvalue_reference&lt; T &gt;::type &gt; &amp;&amp;detail::is_nothrow_assignable_helper&lt; etl::add_lvalue_reference&lt; T &gt;::type, etl::add_rvalue_reference&lt; T &gt;::type &gt;::value &gt;</a></td><td class="desc"></td></tr>
<tr id="row_81_0_" class="even" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_81_0_" class="arrow" onclick="toggleFolder('81_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__assignable.html" target="_self">etl::is_nothrow_assignable&lt; etl::add_lvalue_reference&lt; T &gt;::type, etl::add_rvalue_reference&lt; T &gt;::type &gt;</a></td><td class="desc"></td></tr>
<tr id="row_81_0_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__move__assignable.html" target="_self">etl::is_nothrow_move_assignable&lt; T &gt;</a></td><td class="desc">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#ac6a0d38654d5eeea44e25fea4eae7a55">etl::is_assignable&lt;T&amp;, T&amp;&amp;&gt;::value</a> </td></tr>
<tr id="row_82_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_82_" class="arrow" onclick="toggleFolder('82_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; bool, is_assignable_v&lt; T, U &gt; &amp;&amp;detail::is_nothrow_assignable_helper&lt; T, U &gt;::value &gt;</a></td><td class="desc"></td></tr>
<tr id="row_82_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__assignable.html" target="_self">etl::is_nothrow_assignable&lt; T, U &gt;</a></td><td class="desc">If the expression <a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292" title="Converts any type T to a reference type, making it possible to use member functions in decltype expre...">etl::declval&lt;T&gt;()</a> = <a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292" title="Converts any type T to a reference type, making it possible to use member functions in decltype expre...">etl::declval&lt;U&gt;()</a> is well-formed in unevaluated context, provides the member constant value equal true. Otherwise, value is false. Access checks are performed as if from a context unrelated to either type </td></tr>
<tr id="row_83_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; bool, is_integral_v&lt; T &gt; &amp;&amp;(!is_same_v&lt; T, bool &gt; &amp;&amp;!is_same_v&lt; T, char &gt; &amp;&amp;!is_same_v&lt; T, char16_t &gt; &amp;&amp;!is_same_v&lt; T, char32_t &gt; &amp;&amp;!is_same_v&lt; T, wchar_t &gt;)&gt;</a></td><td class="desc"></td></tr>
<tr id="row_84_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; bool, is_unsigned_v&lt; T &gt; &amp;&amp;(!is_same_v&lt; T, bool &gt; &amp;&amp;!is_same_v&lt; T, char &gt; &amp;&amp;!is_same_v&lt; T, char16_t &gt; &amp;&amp;!is_same_v&lt; T, char32_t &gt; &amp;&amp;!is_same_v&lt; T, wchar_t &gt;)&gt;</a></td><td class="desc"></td></tr>
<tr id="row_85_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_85_" class="arrow" onclick="toggleFolder('85_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; bool, R1::num==R2::num &amp;&amp;R1::den==R2::den &gt;</a></td><td class="desc"></td></tr>
<tr id="row_85_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1ratio__equal.html" target="_self">etl::ratio_equal&lt; R1, R2 &gt;</a></td><td class="desc">Compares two ratio objects for equality at compile-time. If the ratios R1 and R2 are equal, provides the member constant value equal true. Otherwise, value is false </td></tr>
<tr id="row_86_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_86_" class="arrow" onclick="toggleFolder('86_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; bool,(decltype(detail::test_returnable&lt; To &gt;(0))::value &amp;&amp;decltype(detail::test_nonvoid_convertible&lt; From, To &gt;(0))::value)||(etl::is_void&lt; From &gt;::value &amp;&amp;etl::is_void&lt; To &gt;::value)&gt;</a></td><td class="desc"></td></tr>
<tr id="row_86_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__convertible.html" target="_self">etl::is_convertible&lt; From, To &gt;</a></td><td class="desc">If the imaginary function definition To test() { return <a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292" title="Converts any type T to a reference type, making it possible to use member functions in decltype expre...">etl::declval&lt;From&gt;()</a>; } is well-formed, (that is, either <a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292" title="Converts any type T to a reference type, making it possible to use member functions in decltype expre...">etl::declval&lt;From&gt;()</a> can be converted to To using implicit conversions, or both From and To are possibly cv-qualified void), provides the member constant value equal to true. Otherwise value is false. For the purposes of this check, the use of <a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292" title="Converts any type T to a reference type, making it possible to use member functions in decltype expre...">etl::declval</a> in the return statement is not considered an odr-use. Access checks are performed as if from a context unrelated to either type. Only the validity of the immediate context of the expression in the return statement (including conversions to the return type) is considered </td></tr>
<tr id="row_87_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_87_" class="arrow" onclick="toggleFolder('87_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; etl::size_t, 0 &gt;</a></td><td class="desc"></td></tr>
<tr id="row_87_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1extent.html" target="_self">etl::extent&lt; T, N &gt;</a></td><td class="desc"></td></tr>
<tr id="row_87_1_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1extent_3_01T[]_00_010_01_4.html" target="_self">etl::extent&lt; T[], 0 &gt;</a></td><td class="desc"></td></tr>
<tr id="row_87_2_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1rank.html" target="_self">etl::rank&lt; T &gt;</a></td><td class="desc">If Type is an array type, provides the member constant value equal to the number of dimensions of the array. For any other type, value is 0. The behavior of a program that adds specializations for rank or rank_v is undefined </td></tr>
<tr id="row_87_3_" class="even" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_87_3_" class="arrow" onclick="toggleFolder('87_3_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1extent.html" target="_self">etl::extent&lt; T, N - 1 &gt;</a></td><td class="desc"></td></tr>
<tr id="row_87_3_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1extent_3_01T[]_00_01N_01_4.html" target="_self">etl::extent&lt; T[], N &gt;</a></td><td class="desc"></td></tr>
<tr id="row_87_3_1_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1extent_3_01T[I]_00_01N_01_4.html" target="_self">etl::extent&lt; T[I], N &gt;</a></td><td class="desc"></td></tr>
<tr id="row_88_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_88_" class="arrow" onclick="toggleFolder('88_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; etl::size_t, I &gt;</a></td><td class="desc"></td></tr>
<tr id="row_88_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1extent_3_01T[I]_00_010_01_4.html" target="_self">etl::extent&lt; T[I], 0 &gt;</a></td><td class="desc"></td></tr>
<tr id="row_89_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_89_" class="arrow" onclick="toggleFolder('89_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; etl::size_t, N &gt;</a></td><td class="desc"></td></tr>
<tr id="row_89_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1tuple__size_3_01etl_1_1array_3_01T_00_01N_01_4_01_4.html" target="_self">etl::tuple_size&lt; etl::array&lt; T, N &gt; &gt;</a></td><td class="desc">Provides access to the number of elements in an <a class="el" href="structetl_1_1array.html" title="etl::array is a container that encapsulates fixed size arrays. ">etl::array</a> as a compile-time constant expression </td></tr>
<tr id="row_90_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_90_" class="arrow" onclick="toggleFolder('90_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; etl::size_t, rank&lt; T &gt;::value+1 &gt;</a></td><td class="desc"></td></tr>
<tr id="row_90_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1rank_3_01T[]_4.html" target="_self">etl::rank&lt; T[]&gt;</a></td><td class="desc"></td></tr>
<tr id="row_90_1_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1rank_3_01T[N]_4.html" target="_self">etl::rank&lt; T[N]&gt;</a></td><td class="desc"></td></tr>
<tr id="row_91_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_91_" class="arrow" onclick="toggleFolder('91_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; etl::size_t, sizeof...(Types)&gt;</a></td><td class="desc"></td></tr>
<tr id="row_91_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1tuple__size_3_01etl_1_1tuple_3_01Types_8_8_8_01_4_01_4.html" target="_self">etl::tuple_size&lt; etl::tuple&lt; Types... &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_92_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_92_" class="arrow" onclick="toggleFolder('92_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; etl::size_t, tuple_size&lt; T &gt;::value &gt;</a></td><td class="desc"></td></tr>
<tr id="row_92_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1tuple__size_3_01const_01T_01_4.html" target="_self">etl::tuple_size&lt; const T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_92_1_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1tuple__size_3_01const_01volatile_01T_01_4.html" target="_self">etl::tuple_size&lt; const volatile T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_92_2_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1tuple__size_3_01volatile_01T_01_4.html" target="_self">etl::tuple_size&lt; volatile T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_93_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_93_" class="arrow" onclick="toggleFolder('93_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1integral__constant.html" target="_self">etl::integral_constant&lt; size_t, alignof(T)&gt;</a></td><td class="desc"></td></tr>
<tr id="row_93_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1alignment__of.html" target="_self">etl::alignment_of&lt; T &gt;</a></td><td class="desc">Alignment_of </td></tr>
<tr id="row_94_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_94_" class="arrow" onclick="toggleFolder('94_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::is_destructible_safe&lt; T &gt;</b></td><td class="desc"></td></tr>
<tr id="row_94_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__destructible.html" target="_self">etl::is_destructible&lt; T &gt;</a></td><td class="desc">Https://en.cppreference.com/w/cpp/types/is_destructible </td></tr>
<tr id="row_95_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_95_" class="arrow" onclick="toggleFolder('95_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::is_nothrow_destructible_helper&lt; is_destructible&lt; Type &gt;::value, Type &gt;</b></td><td class="desc"></td></tr>
<tr id="row_95_0_" class="even" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_95_0_" class="arrow" onclick="toggleFolder('95_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__destructible.html" target="_self">etl::is_nothrow_destructible&lt; Type &gt;</a></td><td class="desc">Https://en.cppreference.com/w/cpp/types/is_destructible </td></tr>
<tr id="row_95_0_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__nothrow__destructible_3_01Type[N]_4.html" target="_self">etl::is_nothrow_destructible&lt; Type[N]&gt;</a></td><td class="desc"></td></tr>
<tr id="row_96_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1is__trivially__copyable.html" target="_self">etl::is_trivially_copyable&lt; T &gt;</a></td><td class="desc">If T is a TriviallyCopyable type, provides the member constant value equal to true. For any other type, value is false. The only trivially copyable types are scalar types, trivially copyable classes, and arrays of such types/classes (possibly cv-qualified) </td></tr>
<tr id="row_97_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1hardware_1_1stm32_1_1isr.html" target="_self">etl::hardware::stm32::isr</a></td><td class="desc"></td></tr>
<tr id="row_98_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1iterator__traits.html" target="_self">etl::iterator_traits&lt; Iter &gt;</a></td><td class="desc">Etl::iterator_traits is the type trait class that provides uniform interface to the properties of LegacyIterator types. This makes it possible to implement algorithms only in terms of iterators </td></tr>
<tr id="row_99_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1iterator__traits_3_01T_01_5_01_4.html" target="_self">etl::iterator_traits&lt; T * &gt;</a></td><td class="desc">Etl::iterator_traits is the type trait class that provides uniform interface to the properties of LegacyIterator types. This makes it possible to implement algorithms only in terms of iterators </td></tr>
<tr id="row_100_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1less.html" target="_self">etl::less&lt; T &gt;</a></td><td class="desc">Function object for performing comparisons. Unless specialised, invokes operator&lt; on type T </td></tr>
<tr id="row_101_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1less_3_01void_01_4.html" target="_self">etl::less&lt; void &gt;</a></td><td class="desc">Function object for performing comparisons. Unless specialised, invokes operator&lt; on type T. The standard library provides a specialization of <a class="el" href="structetl_1_1less.html" title="Function object for performing comparisons. Unless specialised, invokes operator&lt; on type T...">etl::less</a> when T is not specified, which leaves the parameter types and return type to be deduced </td></tr>
<tr id="row_102_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1less__equal.html" target="_self">etl::less_equal&lt; T &gt;</a></td><td class="desc">Function object for performing comparisons. Unless specialised, invokes operator&lt;= on type T </td></tr>
<tr id="row_103_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1less__equal_3_01void_01_4.html" target="_self">etl::less_equal&lt; void &gt;</a></td><td class="desc">Function object for performing comparisons. Unless specialised, invokes operator&lt; on type T. The standard library provides a specialization of <a class="el" href="structetl_1_1less__equal.html" title="Function object for performing comparisons. Unless specialised, invokes operator&lt;= on type T...">etl::less_equal</a> when T is not specified, which leaves the parameter types and return type to be deduced </td></tr>
<tr id="row_104_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1lock__guard.html" target="_self">etl::lock_guard&lt; MutexT &gt;</a></td><td class="desc">The class <a class="el" href="classetl_1_1lock__guard.html" title="The class lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a ...">lock_guard</a> is a mutex wrapper that provides a convenient RAII-style mechanism for owning a mutex for the duration of a scoped block. When a <a class="el" href="classetl_1_1lock__guard.html" title="The class lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a ...">lock_guard</a> object is created, it attempts to take ownership of the mutex it is given. When control leaves the scope in which the <a class="el" href="classetl_1_1lock__guard.html" title="The class lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a ...">lock_guard</a> object was created, the <a class="el" href="classetl_1_1lock__guard.html" title="The class lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a ...">lock_guard</a> is destructed and the mutex is released. The <a class="el" href="classetl_1_1lock__guard.html" title="The class lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a ...">lock_guard</a> class is non-copyable </td></tr>
<tr id="row_105_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1logical__and.html" target="_self">etl::logical_and&lt; T &gt;</a></td><td class="desc">Function object for performing logical AND (logical conjunction). Effectively calls operator&amp;&amp; on type T </td></tr>
<tr id="row_106_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1logical__and_3_01void_01_4.html" target="_self">etl::logical_and&lt; void &gt;</a></td><td class="desc">Function object for performing logical AND (logical conjunction). Effectively calls operator&amp;&amp; on type T. The standard library provides a specialization of <a class="el" href="structetl_1_1logical__and.html" title="Function object for performing logical AND (logical conjunction). Effectively calls operator&amp;&amp; on typ...">etl::logical_and</a> when T is not specified, which leaves the parameter types and return type to be deduced </td></tr>
<tr id="row_107_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1logical__not.html" target="_self">etl::logical_not&lt; T &gt;</a></td><td class="desc">Function object for performing logical NOT (logical negation). Effectively calls operator! for type T </td></tr>
<tr id="row_108_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1logical__not_3_01void_01_4.html" target="_self">etl::logical_not&lt; void &gt;</a></td><td class="desc">Function object for performing logical NOT (logical negation). Effectively calls operator! for type T. The standard library provides a specialization of <a class="el" href="structetl_1_1logical__not.html" title="Function object for performing logical NOT (logical negation). Effectively calls operator! for type T...">etl::logical_not</a> when T is not specified, which leaves the parameter types and return type to be deduced </td></tr>
<tr id="row_109_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1logical__or.html" target="_self">etl::logical_or&lt; T &gt;</a></td><td class="desc">Function object for performing logical OR (logical disjunction). Effectively calls operator|| on type T </td></tr>
<tr id="row_110_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1logical__or_3_01void_01_4.html" target="_self">etl::logical_or&lt; void &gt;</a></td><td class="desc">Function object for performing logical OR (logical disjunction). Effectively calls operator|| on type T. The standard library provides a specialization of <a class="el" href="structetl_1_1logical__or.html" title="Function object for performing logical OR (logical disjunction). Effectively calls operator|| on type...">etl::logical_or</a> when T is not specified, which leaves the parameter types and return type to be deduced </td></tr>
<tr id="row_111_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_111_" class="arrow" onclick="toggleFolder('111_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::make_signed_helper&lt; Type &gt;</b></td><td class="desc"></td></tr>
<tr id="row_111_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1make__signed.html" target="_self">etl::make_signed&lt; Type &gt;</a></td><td class="desc">If T is an integral (except bool) or enumeration type, provides the member typedef type which is the unsigned integer type corresponding to T, with the same cv-qualifiers. If T is signed or unsigned char, short, int, long, long long; the unsigned type from this list corresponding to T is provided. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1make__signed.html" title="If T is an integral (except bool) or enumeration type, provides the member typedef type which is the ...">make_signed</a> is undefined </td></tr>
<tr id="row_112_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_112_" class="arrow" onclick="toggleFolder('112_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::make_unsigned_helper&lt; Type &gt;</b></td><td class="desc"></td></tr>
<tr id="row_112_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1make__unsigned.html" target="_self">etl::make_unsigned&lt; Type &gt;</a></td><td class="desc">If T is an integral (except bool) or enumeration type, provides the member typedef type which is the unsigned integer type corresponding to T, with the same cv-qualifiers. If T is signed or unsigned char, short, int, long, long long; the unsigned type from this list corresponding to T is provided. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1make__unsigned.html" title="If T is an integral (except bool) or enumeration type, provides the member typedef type which is the ...">make_unsigned</a> is undefined </td></tr>
<tr id="row_113_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1map__view.html" target="_self">etl::map_view&lt; KeyType, ValueType, Compare &gt;</a></td><td class="desc">Interface base class for <a class="el" href="classetl_1_1map.html" title="etl::map is a sorted associative container that contains key-value pairs with unique keys...">etl::map</a>. Use this class for function parameters. To create an instance, use <a class="el" href="classetl_1_1map.html" title="etl::map is a sorted associative container that contains key-value pairs with unique keys...">etl::map</a> </td></tr>
<tr id="row_114_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_114_" class="arrow" onclick="toggleFolder('114_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1map__view.html" target="_self">etl::map_view&lt; KeyT, ValueT, Compare &gt;</a></td><td class="desc"></td></tr>
<tr id="row_114_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1map.html" target="_self">etl::map&lt; KeyT, ValueT, Size, Compare &gt;</a></td><td class="desc">Etl::map is a sorted associative container that contains key-value pairs with unique keys. Keys are sorted by using the comparison function Compare. Search, removal, and insertion operations have logarithmic complexity. Uses an inline key-value pair array as storage </td></tr>
<tr id="row_115_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1max__align__t.html" target="_self">etl::max_align_t</a></td><td class="desc"></td></tr>
<tr id="row_116_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1minus.html" target="_self">etl::minus&lt; T &gt;</a></td><td class="desc">Function object for performing subtraction. Effectively calls operator- on two instances of type T </td></tr>
<tr id="row_117_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1minus_3_01void_01_4.html" target="_self">etl::minus&lt; void &gt;</a></td><td class="desc">Function object for performing subtraction. Effectively calls operator- on two instances of type T. The standard library provides a specialization of <a class="el" href="structetl_1_1minus.html" title="Function object for performing subtraction. Effectively calls operator- on two instances of type T...">etl::minus</a> when T is not specified, which leaves the parameter types and return type to be deduced </td></tr>
<tr id="row_118_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1modulus.html" target="_self">etl::modulus&lt; T &gt;</a></td><td class="desc">Function object for computing remainders of divisions. Implements operator% for type T </td></tr>
<tr id="row_119_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1modulus_3_01void_01_4.html" target="_self">etl::modulus&lt; void &gt;</a></td><td class="desc">Function object for computing remainders of divisions. Implements operator% for type T. The standard library provides a specialization of <a class="el" href="structetl_1_1modulus.html" title="Function object for computing remainders of divisions. Implements operator% for type T...">etl::modulus</a> when T is not specified, which leaves the parameter types and return type to be deduced </td></tr>
<tr id="row_120_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1monostate.html" target="_self">etl::monostate</a></td><td class="desc">Unit type intended for use as a well-behaved empty alternative in <a class="el" href="classetl_1_1variant.html" title="The class template etl::variant represents a type-safe union. An instance of etl::variant at any give...">etl::variant</a>. In particular, a variant of non-default-constructible types may list <a class="el" href="structetl_1_1monostate.html" title="Unit type intended for use as a well-behaved empty alternative in etl::variant. In particular...">etl::monostate</a> as its first alternative: this makes the variant itself default-constructible </td></tr>
<tr id="row_121_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1multiplies.html" target="_self">etl::multiplies&lt; T &gt;</a></td><td class="desc">Function object for performing multiplication. Effectively calls operator* on two instances of type T </td></tr>
<tr id="row_122_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1multiplies_3_01void_01_4.html" target="_self">etl::multiplies&lt; void &gt;</a></td><td class="desc">Function object for performing multiplication. Effectively calls operator* on two instances of type T. The standard library provides a specialization of <a class="el" href="structetl_1_1multiplies.html" title="Function object for performing multiplication. Effectively calls operator* on two instances of type T...">etl::multiplies</a> when T is not specified, which leaves the parameter types and return type to be deduced </td></tr>
<tr id="row_123_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1net_1_1mutable__buffer.html" target="_self">etl::net::mutable_buffer</a></td><td class="desc"></td></tr>
<tr id="row_124_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1negate.html" target="_self">etl::negate&lt; T &gt;</a></td><td class="desc">Function object for performing negation. Effectively calls operator- on an instance of type T </td></tr>
<tr id="row_125_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1negate_3_01void_01_4.html" target="_self">etl::negate&lt; void &gt;</a></td><td class="desc">Function object for performing negation. Effectively calls operator- on an instance of type T. The standard library provides a specialization of <a class="el" href="structetl_1_1negate.html" title="Function object for performing negation. Effectively calls operator- on an instance of type T...">etl::negate</a> when T is not specified, which leaves the parameter types and return type to be deduced </td></tr>
<tr id="row_126_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1rtos_1_1never.html" target="_self">etl::rtos::never</a></td><td class="desc">Runs the task loop 0 times </td></tr>
<tr id="row_127_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1not__equal__to.html" target="_self">etl::not_equal_to&lt; T &gt;</a></td><td class="desc">Function object for performing comparisons. Unless specialised, invokes operator!= on type T </td></tr>
<tr id="row_128_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1not__equal__to_3_01void_01_4.html" target="_self">etl::not_equal_to&lt; void &gt;</a></td><td class="desc">Function object for performing comparisons. Unless specialised, invokes operator!= on type T. The standard library provides a specialization of <a class="el" href="structetl_1_1not__equal__to.html" title="Function object for performing comparisons. Unless specialised, invokes operator!= on type T...">etl::not_equal_to</a> when T is not specified, which leaves the parameter types and return type to be deduced </td></tr>
<tr id="row_129_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1nullopt__t.html" target="_self">etl::nullopt_t</a></td><td class="desc">Etl::nullopt_t is an empty class type used to indicate optional type with uninitialized state. In particular, <a class="el" href="classetl_1_1optional.html">etl::optional</a> has a constructor with <a class="el" href="structetl_1_1nullopt__t.html" title="etl::nullopt_t is an empty class type used to indicate optional type with uninitialized state...">nullopt_t</a> as a single argument, which creates an optional that does not contain a value </td></tr>
<tr id="row_130_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1numeric__limits.html" target="_self">etl::numeric_limits&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_131_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1numeric__limits_3_01bool_01_4.html" target="_self">etl::numeric_limits&lt; bool &gt;</a></td><td class="desc"></td></tr>
<tr id="row_132_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1numeric__limits_3_01char_01_4.html" target="_self">etl::numeric_limits&lt; char &gt;</a></td><td class="desc"></td></tr>
<tr id="row_133_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1numeric__limits_3_01double_01_4.html" target="_self">etl::numeric_limits&lt; double &gt;</a></td><td class="desc"></td></tr>
<tr id="row_134_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1numeric__limits_3_01float_01_4.html" target="_self">etl::numeric_limits&lt; float &gt;</a></td><td class="desc"></td></tr>
<tr id="row_135_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1numeric__limits_3_01int_01_4.html" target="_self">etl::numeric_limits&lt; int &gt;</a></td><td class="desc"></td></tr>
<tr id="row_136_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1numeric__limits_3_01long_01_4.html" target="_self">etl::numeric_limits&lt; long &gt;</a></td><td class="desc"></td></tr>
<tr id="row_137_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1numeric__limits_3_01short_01_4.html" target="_self">etl::numeric_limits&lt; short &gt;</a></td><td class="desc"></td></tr>
<tr id="row_138_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1numeric__limits_3_01signed_01char_01_4.html" target="_self">etl::numeric_limits&lt; signed char &gt;</a></td><td class="desc"></td></tr>
<tr id="row_139_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1numeric__limits_3_01unsigned_01char_01_4.html" target="_self">etl::numeric_limits&lt; unsigned char &gt;</a></td><td class="desc"></td></tr>
<tr id="row_140_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1numeric__limits_3_01unsigned_01int_01_4.html" target="_self">etl::numeric_limits&lt; unsigned int &gt;</a></td><td class="desc"></td></tr>
<tr id="row_141_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1numeric__limits_3_01unsigned_01long_01_4.html" target="_self">etl::numeric_limits&lt; unsigned long &gt;</a></td><td class="desc"></td></tr>
<tr id="row_142_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1numeric__limits_3_01unsigned_01short_01_4.html" target="_self">etl::numeric_limits&lt; unsigned short &gt;</a></td><td class="desc"></td></tr>
<tr id="row_143_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_143_" class="arrow" onclick="toggleFolder('143_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::optional_destruct_base&lt; ValueType &gt;</b></td><td class="desc"></td></tr>
<tr id="row_143_0_" class="even" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_143_0_" class="arrow" onclick="toggleFolder('143_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::optional_storage_base&lt; ValueType &gt;</b></td><td class="desc"></td></tr>
<tr id="row_143_0_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span id="arr_143_0_0_" class="arrow" onclick="toggleFolder('143_0_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::optional_copy_base&lt; ValueType &gt;</b></td><td class="desc"></td></tr>
<tr id="row_143_0_0_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span id="arr_143_0_0_0_" class="arrow" onclick="toggleFolder('143_0_0_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::optional_move_base&lt; ValueType &gt;</b></td><td class="desc"></td></tr>
<tr id="row_143_0_0_0_0_" class="even" style="display:none;"><td class="entry"><span style="width:64px;display:inline-block;">&#160;</span><span id="arr_143_0_0_0_0_" class="arrow" onclick="toggleFolder('143_0_0_0_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::optional_copy_assign_base&lt; ValueType &gt;</b></td><td class="desc"></td></tr>
<tr id="row_143_0_0_0_0_0_" class="even" style="display:none;"><td class="entry"><span style="width:80px;display:inline-block;">&#160;</span><span id="arr_143_0_0_0_0_0_" class="arrow" onclick="toggleFolder('143_0_0_0_0_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::optional_move_assign_base&lt; ValueType &gt;</b></td><td class="desc"></td></tr>
<tr id="row_143_0_0_0_0_0_0_" class="even" style="display:none;"><td class="entry"><span style="width:112px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1optional.html" target="_self">etl::optional&lt; ValueType &gt;</a></td><td class="desc"></td></tr>
<tr id="row_144_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1output__iterator__tag.html" target="_self">etl::output_iterator_tag</a></td><td class="desc">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories </td></tr>
<tr id="row_145_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1pair.html" target="_self">etl::pair&lt; T1, T2 &gt;</a></td><td class="desc">Etl::pair is a class template that provides a way to store two heterogeneous objects as a single unit. A pair is a specific case of a <a class="el" href="structetl_1_1tuple.html">etl::tuple</a> with two elements. If neither T1 nor T2 is a possibly cv-qualified class type with non-trivial destructor, or array thereof, the destructor of pair is trivial </td></tr>
<tr id="row_146_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1piecewise__construct__t.html" target="_self">etl::piecewise_construct_t</a></td><td class="desc">Etl::piecewise_construct_t is an empty class tag type used to disambiguate between different functions that take two tuple arguments </td></tr>
<tr id="row_147_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1dsp_1_1pipe.html" target="_self">etl::dsp::pipe&lt; L, R &gt;</a></td><td class="desc"></td></tr>
<tr id="row_148_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1plus.html" target="_self">etl::plus&lt; T &gt;</a></td><td class="desc">Function object for performing addition. Effectively calls operator+ on two instances of type T </td></tr>
<tr id="row_149_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1plus_3_01void_01_4.html" target="_self">etl::plus&lt; void &gt;</a></td><td class="desc">Function object for performing addition. Effectively calls operator+ on two instances of type T. The standard library provides a specialization of <a class="el" href="structetl_1_1plus.html" title="Function object for performing addition. Effectively calls operator+ on two instances of type T...">etl::plus</a> when T is not specified, which leaves the parameter types and return type to be deduced </td></tr>
<tr id="row_150_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1hardware_1_1stm32_1_1port.html" target="_self">etl::hardware::stm32::port</a></td><td class="desc"></td></tr>
<tr id="row_151_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1rtos_1_1queue.html" target="_self">etl::rtos::queue&lt; ValueType, Size &gt;</a></td><td class="desc"></td></tr>
<tr id="row_152_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1ratio.html" target="_self">etl::ratio&lt; Num, Denom &gt;</a></td><td class="desc">The class template provides compile-time rational arithmetic support. Each instantiation of this template exactly represents any finite rational number as long as its numerator Num and denominator Denom are representable as compile-time constants of type intmax_t </td></tr>
<tr id="row_153_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__all__extents.html" target="_self">etl::remove_all_extents&lt; T &gt;</a></td><td class="desc">If T is a multidimensional array of some type X, provides the member typedef type equal to X, otherwise type is T. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1remove__all__extents.html" title="If T is a multidimensional array of some type X, provides the member typedef type equal to X...">remove_all_extents</a> is undefined </td></tr>
<tr id="row_154_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__all__extents_3_01T[]_4.html" target="_self">etl::remove_all_extents&lt; T[]&gt;</a></td><td class="desc">If T is a multidimensional array of some type X, provides the member typedef type equal to X, otherwise type is T. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1remove__all__extents.html" title="If T is a multidimensional array of some type X, provides the member typedef type equal to X...">remove_all_extents</a> is undefined </td></tr>
<tr id="row_155_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__all__extents_3_01T[N]_4.html" target="_self">etl::remove_all_extents&lt; T[N]&gt;</a></td><td class="desc">If T is a multidimensional array of some type X, provides the member typedef type equal to X, otherwise type is T. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1remove__all__extents.html" title="If T is a multidimensional array of some type X, provides the member typedef type equal to X...">remove_all_extents</a> is undefined </td></tr>
<tr id="row_156_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__const.html" target="_self">etl::remove_const&lt; Type &gt;</a></td><td class="desc">Provides the member typedef type which is the same as T, except that its topmost cv-qualifiers are removed. Removes the topmost const </td></tr>
<tr id="row_157_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__const_3_01Type_01const_01_4.html" target="_self">etl::remove_const&lt; Type const &gt;</a></td><td class="desc"></td></tr>
<tr id="row_158_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__cv.html" target="_self">etl::remove_cv&lt; Type &gt;</a></td><td class="desc">Provides the member typedef type which is the same as T, except that its topmost cv-qualifiers are removed. Removes the topmost const, or the topmost volatile, or both, if present </td></tr>
<tr id="row_159_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__cvref.html" target="_self">etl::remove_cvref&lt; T &gt;</a></td><td class="desc">If the type T is a reference type, provides the member typedef type which is the type referred to by T with its topmost cv-qualifiers removed. Otherwise type is T with its topmost cv-qualifiers removed </td></tr>
<tr id="row_160_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__extent.html" target="_self">etl::remove_extent&lt; T &gt;</a></td><td class="desc">If T is an array of some type X, provides the member typedef type equal to X, otherwise type is T. Note that if T is a multidimensional array, only the first dimension is removed. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1remove__extent.html" title="If T is an array of some type X, provides the member typedef type equal to X, otherwise type is T...">remove_extent</a> is undefined </td></tr>
<tr id="row_161_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__extent_3_01T[]_4.html" target="_self">etl::remove_extent&lt; T[]&gt;</a></td><td class="desc"></td></tr>
<tr id="row_162_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__extent_3_01T[N]_4.html" target="_self">etl::remove_extent&lt; T[N]&gt;</a></td><td class="desc"></td></tr>
<tr id="row_163_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__pointer.html" target="_self">etl::remove_pointer&lt; T &gt;</a></td><td class="desc">Provides the member typedef type which is the type pointed to by T, or, if T is not a pointer, then type is the same as T. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1remove__pointer.html" title="Provides the member typedef type which is the type pointed to by T, or, if T is not a pointer...">remove_pointer</a> is undefined </td></tr>
<tr id="row_164_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__pointer_3_01T_01_5_01_4.html" target="_self">etl::remove_pointer&lt; T * &gt;</a></td><td class="desc"></td></tr>
<tr id="row_165_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__pointer_3_01T_01_5const_01_4.html" target="_self">etl::remove_pointer&lt; T *const &gt;</a></td><td class="desc"></td></tr>
<tr id="row_166_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__pointer_3_01T_01_5const_01volatile_01_4.html" target="_self">etl::remove_pointer&lt; T *const volatile &gt;</a></td><td class="desc"></td></tr>
<tr id="row_167_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__pointer_3_01T_01_5volatile_01_4.html" target="_self">etl::remove_pointer&lt; T *volatile &gt;</a></td><td class="desc"></td></tr>
<tr id="row_168_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__reference.html" target="_self">etl::remove_reference&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_169_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__reference_3_01T_01_6_01_4.html" target="_self">etl::remove_reference&lt; T &amp; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_170_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__reference_3_01T_01_6_6_01_4.html" target="_self">etl::remove_reference&lt; T &amp;&amp; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_171_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__volatile.html" target="_self">etl::remove_volatile&lt; Type &gt;</a></td><td class="desc">Provides the member typedef type which is the same as T, except that its topmost cv-qualifiers are removed. Removes the topmost volatile </td></tr>
<tr id="row_172_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1remove__volatile_3_01Type_01volatile_01_4.html" target="_self">etl::remove_volatile&lt; Type volatile &gt;</a></td><td class="desc"></td></tr>
<tr id="row_173_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1scope__guard.html" target="_self">etl::scope_guard&lt; FuncT, PolicyT &gt;</a></td><td class="desc"></td></tr>
<tr id="row_174_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_174_" class="arrow" onclick="toggleFolder('174_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1scope__guard.html" target="_self">etl::scope_guard&lt; FuncT, detail::scope_exit_impl &gt;</a></td><td class="desc"></td></tr>
<tr id="row_174_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1scope__exit.html" target="_self">etl::scope_exit&lt; FuncT &gt;</a></td><td class="desc"></td></tr>
<tr id="row_175_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1scoped__lock.html" target="_self">etl::scoped_lock&lt; MutexT &gt;</a></td><td class="desc">RAII based lock </td></tr>
<tr id="row_176_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_176_" class="arrow" onclick="toggleFolder('176_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::sfinae_assign_base&lt; CanCopy, CanMove &gt;</b></td><td class="desc"></td></tr>
<tr id="row_176_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1optional.html" target="_self">etl::optional&lt; ValueType &gt;</a></td><td class="desc"></td></tr>
<tr id="row_177_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_177_" class="arrow" onclick="toggleFolder('177_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>etl::detail::sfinae_ctor_base&lt; CanCopy, CanMove &gt;</b></td><td class="desc"></td></tr>
<tr id="row_177_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1optional.html" target="_self">etl::optional&lt; ValueType &gt;</a></td><td class="desc"></td></tr>
<tr id="row_178_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1skill.html" target="_self">etl::experimental::skill</a></td><td class="desc"></td></tr>
<tr id="row_179_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_179_" class="arrow" onclick="toggleFolder('179_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>Skills</b></td><td class="desc"></td></tr>
<tr id="row_179_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1experimental_1_1strong__type.html" target="_self">etl::experimental::strong_type&lt; ValueType, Tag, Skills &gt;</a></td><td class="desc">Wraps a built-in type </td></tr>
<tr id="row_180_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1small__ptr.html" target="_self">etl::small_ptr&lt; Type, BaseAddress, StorageType &gt;</a></td><td class="desc">Compressed pointer to specified size. Intended to be used as a drop in replacement for native pointers </td></tr>
<tr id="row_181_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1span.html" target="_self">etl::span&lt; ElementType, Extent &gt;</a></td><td class="desc">A non-owning view over a contiguous sequence of objects </td></tr>
<tr id="row_182_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_182_" class="arrow" onclick="toggleFolder('182_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>storage_type</b></td><td class="desc"></td></tr>
<tr id="row_182_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1static__vector.html" target="_self">etl::static_vector&lt; T, Capacity &gt;</a></td><td class="desc">Dynamically-resizable fixed-capacity vector </td></tr>
<tr id="row_183_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1rtos_1_1times.html" target="_self">etl::rtos::times&lt; Count &gt;</a></td><td class="desc">Runs the task loop Count times </td></tr>
<tr id="row_184_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_184_" class="arrow" onclick="toggleFolder('184_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>try_add_lvalue_reference</b></td><td class="desc"></td></tr>
<tr id="row_184_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1add__lvalue__reference.html" target="_self">etl::add_lvalue_reference&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_185_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_185_" class="arrow" onclick="toggleFolder('185_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>try_add_pointer</b></td><td class="desc"></td></tr>
<tr id="row_185_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1add__pointer.html" target="_self">etl::add_pointer&lt; T &gt;</a></td><td class="desc">If T is a reference type, then provides the member typedef type which is a pointer to the referred type. Otherwise, if T names an object type, a function type that is not cv- or ref-qualified, or a (possibly cv-qualified) void type, provides the member typedef type which is the type T*. Otherwise (if T is a cv- or ref-qualified function type), provides the member typedef type which is the type T. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1add__pointer.html" title="If T is a reference type, then provides the member typedef type which is a pointer to the referred ty...">add_pointer</a> is undefined </td></tr>
<tr id="row_186_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_186_" class="arrow" onclick="toggleFolder('186_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>try_add_rvalue_reference</b></td><td class="desc"></td></tr>
<tr id="row_186_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1add__rvalue__reference.html" target="_self">etl::add_rvalue_reference&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_187_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1try__to__lock__t.html" target="_self">etl::try_to_lock_t</a></td><td class="desc">Empty class tag types used to specify locking strategy for <a class="el" href="classetl_1_1lock__guard.html" title="The class lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a ...">etl::lock_guard</a>, <a class="el" href="classetl_1_1scoped__lock.html" title="RAII based lock. ">etl::scoped_lock</a>, etl::unique_lock, and etl::shared_lock </td></tr>
<tr id="row_188_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1tuple.html" target="_self">etl::tuple&lt; First, Rest &gt;</a></td><td class="desc"></td></tr>
<tr id="row_189_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1tuple_3_01First_01_4.html" target="_self">etl::tuple&lt; First &gt;</a></td><td class="desc"></td></tr>
<tr id="row_190_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1tuple__element.html" target="_self">etl::tuple_element&lt; I, T &gt;</a></td><td class="desc">Provides compile-time indexed access to the type of the elements of the array using tuple-like interface </td></tr>
<tr id="row_191_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1tuple__element_3_01I_00_01etl_1_1array_3_01T_00_01N_01_4_01_4.html" target="_self">etl::tuple_element&lt; I, etl::array&lt; T, N &gt; &gt;</a></td><td class="desc">Provides compile-time indexed access to the type of the elements of the array using tuple-like interface </td></tr>
<tr id="row_192_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1tuple__size.html" target="_self">etl::tuple_size&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_193_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_193_" class="arrow" onclick="toggleFolder('193_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>type</b></td><td class="desc"></td></tr>
<tr id="row_193_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__unsigned.html" target="_self">etl::is_unsigned&lt; T &gt;</a></td><td class="desc">If T is an arithmetic type, provides the member constant value equal to true if T(0) &lt; T(-1): this results in true for the unsigned integer types and the type bool and in false for the signed integer types and the floating-point types. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__unsigned.html" title="If T is an arithmetic type, provides the member constant value equal to true if T(0) &lt; T(-1): this re...">is_unsigned</a> or is_unsigned_v (since C++17) is undefined </td></tr>
<tr id="row_194_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1aligned__storage_1_1type.html" target="_self">etl::aligned_storage&lt; Len, Align &gt;::type</a></td><td class="desc"></td></tr>
<tr id="row_195_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_195_" class="arrow" onclick="toggleFolder('195_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><b>type</b></td><td class="desc"></td></tr>
<tr id="row_195_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1is__signed.html" target="_self">etl::is_signed&lt; T &gt;</a></td><td class="desc">If T is an arithmetic type, provides the member constant value equal to true if T(-1) &lt; T(0): this results in true for the floating-point types and the signed integer types, and in false for the unsigned integer types and the type bool. For any other type, value is false </td></tr>
<tr id="row_196_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1type__identity.html" target="_self">etl::type_identity&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_197_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classetl_1_1variant.html" target="_self">etl::variant&lt; Types &gt;</a></td><td class="desc">The class template <a class="el" href="classetl_1_1variant.html" title="The class template etl::variant represents a type-safe union. An instance of etl::variant at any give...">etl::variant</a> represents a type-safe union. An instance of <a class="el" href="classetl_1_1variant.html" title="The class template etl::variant represents a type-safe union. An instance of etl::variant at any give...">etl::variant</a> at any given time either holds a value of one of its alternative types </td></tr>
<tr id="row_198_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1variant__alternative.html" target="_self">etl::variant_alternative&lt; I, T &gt;</a></td><td class="desc">Provides compile-time indexed access to the types of the alternatives of the possibly cv-qualified variant, combining cv-qualifications of the variant (if any) with the cv-qualifications of the alternative </td></tr>
<tr id="row_199_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1variant__alternative_3_01I_00_01const_01T_01_4.html" target="_self">etl::variant_alternative&lt; I, const T &gt;</a></td><td class="desc">Provides compile-time indexed access to the types of the alternatives of the possibly cv-qualified variant, combining cv-qualifications of the variant (if any) with the cv-qualifications of the alternative </td></tr>
<tr id="row_200_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structetl_1_1variant__alternative_3_01I_00_01variant_3_01Types_8_8_8_01_4_01_4.html" target="_self">etl::variant_alternative&lt; I, variant&lt; Types... &gt; &gt;</a></td><td class="desc">Provides compile-time indexed access to the types of the alternatives of the possibly cv-qualified variant, combining cv-qualifications of the variant (if any) with the cv-qualifications of the alternative </td></tr>
</table>
</div><!-- directory -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
