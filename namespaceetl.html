<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>taetl: etl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">taetl
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">etl Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace for the etl library.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceetl_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceetl_1_1dsp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1dsp.html">dsp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceetl_1_1experimental"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1experimental.html">experimental</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceetl_1_1hardware"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1hardware.html">hardware</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceetl_1_1make"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1make.html">make</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceetl_1_1net"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1net.html">net</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceetl_1_1rtos"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1rtos.html">rtos</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__lvalue__reference.html">add_lvalue_reference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__rvalue__reference.html">add_rvalue_reference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1array.html">array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">array class with fixed size capacity.  <a href="classetl_1_1array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1basic__string.html">basic_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classetl_1_1basic__string.html" title="basic_string class with fixed size capacity. ">basic_string</a> class with fixed size capacity.  <a href="classetl_1_1basic__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1bitset.html">bitset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class template bitset represents a fixed-size sequence of N bits. Bitsets can be manipulated by standard logic operators.  <a href="classetl_1_1bitset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1conditional.html">conditional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides member typedef type, which is defined as T if B is true at compile time, or as F if B is false.  <a href="structetl_1_1conditional.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1conditional_3_01false_00_01T_00_01F_01_4.html">conditional&lt; false, T, F &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1crtp.html">crtp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1enable__if.html">enable_if</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a member typedef only if a boolean constant is true.  <a href="structetl_1_1enable__if.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1enable__if_3_01true_00_01Type_01_4.html">enable_if&lt; true, Type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1function.html">function</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1function_3_01Result_07Arguments_8_8_8_08_4.html">function&lt; Result(Arguments...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1integral__constant.html">integral_constant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__arithmetic.html">is_arithmetic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an arithmetic type (that is, an integral type or a floating-point type) or a cv-qualified version thereof, provides the member constant value equal true. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__arithmetic.html" title="If T is an arithmetic type (that is, an integral type or a floating-point type) or a cv-qualified ver...">is_arithmetic</a> or is_arithmetic_v (since C++17) is undefined.  <a href="structetl_1_1is__arithmetic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__array.html">is_array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__array_3_01T[]_4.html">is_array&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__array_3_01T[N]_4.html">is_array&lt; T[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__class.html">is_class</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__enum.html">is_enum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__floating__point.html">is_floating_point</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__integral.html">is_integral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__null__pointer.html">is_null_pointer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__pointer.html">is_pointer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__same.html">is_same</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T and U name the same type (taking into account const/volatile qualifications), provides the member constant value equal to true. Otherwise value is false.  <a href="structetl_1_1is__same.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__same_3_01T_00_01T_01_4.html">is_same&lt; T, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__union.html">is_union</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__unsigned.html">is_unsigned</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an arithmetic type, provides the member constant value equal to true if T(0) &lt; T(-1): this results in true for the unsigned integer types and the type bool and in false for the signed integer types and the floating-point types. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__unsigned.html" title="If T is an arithmetic type, provides the member constant value equal to true if T(0) &lt; T(-1): this re...">is_unsigned</a> or is_unsigned_v (since C++17) is undefined.  <a href="structetl_1_1is__unsigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__void.html">is_void</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a member typedef only if a boolean constant is true.  <a href="structetl_1_1is__void.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1less.html">less</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1make__unsigned.html">make_unsigned</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an integral (except bool) or enumeration type, provides the member typedef type which is the unsigned integer type corresponding to T, with the same cv-qualifiers. If T is signed or unsigned char, short, int, long, long long; the unsigned type from this list corresponding to T is provided. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1make__unsigned.html" title="If T is an integral (except bool) or enumeration type, provides the member typedef type which is the ...">make_unsigned</a> is undefined.  <a href="structetl_1_1make__unsigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1make__unsigned_3_01signed_01char_01_4.html">make_unsigned&lt; signed char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1make__unsigned_3_01signed_01int_01_4.html">make_unsigned&lt; signed int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1make__unsigned_3_01signed_01long_01_4.html">make_unsigned&lt; signed long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1make__unsigned_3_01signed_01long_01long_01_4.html">make_unsigned&lt; signed long long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1make__unsigned_3_01signed_01short_01_4.html">make_unsigned&lt; signed short &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1make__unsigned_3_01unsigned_01char_01_4.html">make_unsigned&lt; unsigned char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1make__unsigned_3_01unsigned_01int_01_4.html">make_unsigned&lt; unsigned int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1make__unsigned_3_01unsigned_01long_01_4.html">make_unsigned&lt; unsigned long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1make__unsigned_3_01unsigned_01long_01long_01_4.html">make_unsigned&lt; unsigned long long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1make__unsigned_3_01unsigned_01short_01_4.html">make_unsigned&lt; unsigned short &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1map.html">map</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1numeric__limits.html">numeric_limits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1numeric__limits_3_01bool_01_4.html">numeric_limits&lt; bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1numeric__limits_3_01double_01_4.html">numeric_limits&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1numeric__limits_3_01float_01_4.html">numeric_limits&lt; float &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pair.html">pair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1rank.html">rank</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Type is an array type, provides the member constant value equal to the number of dimensions of the array. For any other type, value is 0. The behavior of a program that adds specializations for rank or rank_v is undefined.  <a href="structetl_1_1rank.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1rank_3_01T[]_4.html">rank&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1rank_3_01T[N]_4.html">rank&lt; T[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ratio.html">ratio</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class template provides compile-time rational arithmetic support. Each instantiation of this template exactly represents any finite rational number as long as its numerator Num and denominator Denom are representable as compile-time constants of type intmax_t.  <a href="structetl_1_1ratio.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__const.html">remove_const</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__const_3_01Type_01const_01_4.html">remove_const&lt; Type const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__cv.html">remove_cv</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__reference.html">remove_reference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__reference_3_01T_01_6_01_4.html">remove_reference&lt; T &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__reference_3_01T_01_6_6_01_4.html">remove_reference&lt; T &amp;&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__volatile.html">remove_volatile</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__volatile_3_01Type_01volatile_01_4.html">remove_volatile&lt; Type volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1scoped__lock.html">scoped_lock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII based lock.  <a href="classetl_1_1scoped__lock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple.html">tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple_3_01First_01_4.html">tuple&lt; First &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1type__identity.html">type_identity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1vector.html">vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:afd99b481983335f785f7713b9bb4f436"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afd99b481983335f785f7713b9bb4f436">int8_t</a> = <a class="el" href="namespaceetl.html#afd99b481983335f785f7713b9bb4f436">int8_t</a></td></tr>
<tr class="separator:afd99b481983335f785f7713b9bb4f436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffe3c07a4dbbe98792f1936145c6876"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3ffe3c07a4dbbe98792f1936145c6876">int16_t</a> = <a class="el" href="namespaceetl.html#a3ffe3c07a4dbbe98792f1936145c6876">int16_t</a></td></tr>
<tr class="separator:a3ffe3c07a4dbbe98792f1936145c6876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae779a40ac9323d2b0729f8bb95cf0fd1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae779a40ac9323d2b0729f8bb95cf0fd1">int32_t</a> = <a class="el" href="namespaceetl.html#ae779a40ac9323d2b0729f8bb95cf0fd1">int32_t</a></td></tr>
<tr class="separator:ae779a40ac9323d2b0729f8bb95cf0fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4b499f2d2820b8af24be768343759b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adc4b499f2d2820b8af24be768343759b">int64_t</a> = <a class="el" href="namespaceetl.html#adc4b499f2d2820b8af24be768343759b">int64_t</a></td></tr>
<tr class="separator:adc4b499f2d2820b8af24be768343759b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001f884b28f990ecdc3543a19440befb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a001f884b28f990ecdc3543a19440befb">uint8_t</a> = <a class="el" href="namespaceetl.html#a001f884b28f990ecdc3543a19440befb">uint8_t</a></td></tr>
<tr class="separator:a001f884b28f990ecdc3543a19440befb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61de6f15f82704d69a80d859a757298"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af61de6f15f82704d69a80d859a757298">uint16_t</a> = <a class="el" href="namespaceetl.html#af61de6f15f82704d69a80d859a757298">uint16_t</a></td></tr>
<tr class="separator:af61de6f15f82704d69a80d859a757298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e6df1710afc95336b7bee2714144b2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac8e6df1710afc95336b7bee2714144b2">uint32_t</a> = <a class="el" href="namespaceetl.html#ac8e6df1710afc95336b7bee2714144b2">uint32_t</a></td></tr>
<tr class="separator:ac8e6df1710afc95336b7bee2714144b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc782f054552345b4cd2428dbc92a4ca"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afc782f054552345b4cd2428dbc92a4ca">uint64_t</a> = <a class="el" href="namespaceetl.html#afc782f054552345b4cd2428dbc92a4ca">uint64_t</a></td></tr>
<tr class="separator:afc782f054552345b4cd2428dbc92a4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178a2082210268baa21de6920cf2de96"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a178a2082210268baa21de6920cf2de96">intmax_t</a> = <a class="el" href="namespaceetl.html#a178a2082210268baa21de6920cf2de96">intmax_t</a></td></tr>
<tr class="separator:a178a2082210268baa21de6920cf2de96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f7969d130419941da3aeccefc32e6a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a91f7969d130419941da3aeccefc32e6a">uintmax_t</a> = <a class="el" href="namespaceetl.html#a91f7969d130419941da3aeccefc32e6a">uintmax_t</a></td></tr>
<tr class="separator:a91f7969d130419941da3aeccefc32e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac853a6316b146d25fdfbb5865821cedd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">size_t</a> = <a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">size_t</a></td></tr>
<tr class="separator:ac853a6316b146d25fdfbb5865821cedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e0abf50b318376b511f461e8baca33"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a56e0abf50b318376b511f461e8baca33">ptrdiff_t</a> = <a class="el" href="namespaceetl.html#a56e0abf50b318376b511f461e8baca33">ptrdiff_t</a></td></tr>
<tr class="separator:a56e0abf50b318376b511f461e8baca33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4272f3f16bf2234ac8248db615f133"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adf4272f3f16bf2234ac8248db615f133">nullptr_t</a> = decltype(nullptr)</td></tr>
<tr class="separator:adf4272f3f16bf2234ac8248db615f133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf333951ccdff3b01dc321ac566bfecd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abf333951ccdff3b01dc321ac566bfecd">atto</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1, 1000000000000000000 &gt;</td></tr>
<tr class="separator:abf333951ccdff3b01dc321ac566bfecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c3ad429659821374780e0448855ef8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a24c3ad429659821374780e0448855ef8">femto</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1, 1000000000000000 &gt;</td></tr>
<tr class="separator:a24c3ad429659821374780e0448855ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf951c7004991770fcef76d2959007b0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#acf951c7004991770fcef76d2959007b0">pico</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1, 1000000000000 &gt;</td></tr>
<tr class="separator:acf951c7004991770fcef76d2959007b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49eea6db84c720b602fbe4ec3ad44c79"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a49eea6db84c720b602fbe4ec3ad44c79">nano</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1, 1000000000 &gt;</td></tr>
<tr class="separator:a49eea6db84c720b602fbe4ec3ad44c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c9c1103e0bf6709642f55f9a31cb8e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a79c9c1103e0bf6709642f55f9a31cb8e">micro</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1, 1000000 &gt;</td></tr>
<tr class="separator:a79c9c1103e0bf6709642f55f9a31cb8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a92d262bf043c1ef824a60d171019e8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8a92d262bf043c1ef824a60d171019e8">milli</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1, 1000 &gt;</td></tr>
<tr class="separator:a8a92d262bf043c1ef824a60d171019e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d8c20c69482c794a0cfb9e4428ca8d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a95d8c20c69482c794a0cfb9e4428ca8d">centi</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1, 100 &gt;</td></tr>
<tr class="separator:a95d8c20c69482c794a0cfb9e4428ca8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f2e2c10ab4b06ed261d1e4a8358895"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a59f2e2c10ab4b06ed261d1e4a8358895">deci</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1, 10 &gt;</td></tr>
<tr class="separator:a59f2e2c10ab4b06ed261d1e4a8358895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae5b099e4ead54343e6304a6371985b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#acae5b099e4ead54343e6304a6371985b">deca</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 10, 1 &gt;</td></tr>
<tr class="separator:acae5b099e4ead54343e6304a6371985b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba04e5fa0d29bc9f6a9f3fa4f9ff3dbb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aba04e5fa0d29bc9f6a9f3fa4f9ff3dbb">hecto</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 100, 1 &gt;</td></tr>
<tr class="separator:aba04e5fa0d29bc9f6a9f3fa4f9ff3dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e306410036af95bf5ea4fc02bed266"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a28e306410036af95bf5ea4fc02bed266">kilo</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1000, 1 &gt;</td></tr>
<tr class="separator:a28e306410036af95bf5ea4fc02bed266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918391ebf4a95eeb6fa0ad99c936252d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a918391ebf4a95eeb6fa0ad99c936252d">mega</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1000000, 1 &gt;</td></tr>
<tr class="separator:a918391ebf4a95eeb6fa0ad99c936252d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0c06d80bc66be0b8807cee66b576f0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1b0c06d80bc66be0b8807cee66b576f0">giga</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1000000000, 1 &gt;</td></tr>
<tr class="separator:a1b0c06d80bc66be0b8807cee66b576f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4d429035abc6729b30e3406a1703a1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2c4d429035abc6729b30e3406a1703a1">tera</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1000000000000, 1 &gt;</td></tr>
<tr class="separator:a2c4d429035abc6729b30e3406a1703a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37756654b5a747b646eb948d539193c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa37756654b5a747b646eb948d539193c">peta</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1000000000000000, 1 &gt;</td></tr>
<tr class="separator:aa37756654b5a747b646eb948d539193c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1a1ee1ab1b90d8dcf30d783f938ada"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5f1a1ee1ab1b90d8dcf30d783f938ada">exa</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1000000000000000000, 1 &gt;</td></tr>
<tr class="separator:a5f1a1ee1ab1b90d8dcf30d783f938ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515e08f8ce11f32a154acd83b2fe6b00"><td class="memTemplParams" colspan="2">template&lt;class R1 , class R2 &gt; </td></tr>
<tr class="memitem:a515e08f8ce11f32a154acd83b2fe6b00"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a515e08f8ce11f32a154acd83b2fe6b00">ratio_add</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; R1::num *R2::den+R2::num *R1::den, R1::den *R2::den &gt;</td></tr>
<tr class="memdesc:a515e08f8ce11f32a154acd83b2fe6b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alias template <a class="el" href="namespaceetl.html#a515e08f8ce11f32a154acd83b2fe6b00" title="The alias template etl::ratio_add denotes the result of adding two exact rational fractions represent...">etl::ratio_add</a> denotes the result of adding two exact rational fractions represented by the <a class="el" href="structetl_1_1ratio.html" title="The class template provides compile-time rational arithmetic support. Each instantiation of this temp...">etl::ratio</a> specializations R1 and R2. The result is a <a class="el" href="structetl_1_1ratio.html" title="The class template provides compile-time rational arithmetic support. Each instantiation of this temp...">etl::ratio</a> specialization etl::ratio&lt;U, V&gt;, such that given Num == R1::num * R2::den + R2::num * R1::den and Denom == R1::den.  <a href="#a515e08f8ce11f32a154acd83b2fe6b00">More...</a><br /></td></tr>
<tr class="separator:a515e08f8ce11f32a154acd83b2fe6b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234acc6c1438740afe4f7766f1208784"><td class="memTemplParams" colspan="2">template&lt;class R1 , class R2 &gt; </td></tr>
<tr class="memitem:a234acc6c1438740afe4f7766f1208784"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a234acc6c1438740afe4f7766f1208784">ratio_subtract</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; R1::num *R2::den - R2::num *R1::den, R1::den *R2::den &gt;</td></tr>
<tr class="memdesc:a234acc6c1438740afe4f7766f1208784"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alias template <a class="el" href="namespaceetl.html#a234acc6c1438740afe4f7766f1208784" title="The alias template etl::ratio_subtract denotes the result of subtracting two exact rational fractions...">etl::ratio_subtract</a> denotes the result of subtracting two exact rational fractions represented by the <a class="el" href="structetl_1_1ratio.html" title="The class template provides compile-time rational arithmetic support. Each instantiation of this temp...">etl::ratio</a> specializations R1 and R2. The result is a <a class="el" href="structetl_1_1ratio.html" title="The class template provides compile-time rational arithmetic support. Each instantiation of this temp...">etl::ratio</a> specialization etl::ratio&lt;U, V&gt;, such that given Num == R1::num * R2::den - R2::num * R1::den and Denom == R1::den * R2::den (computed without arithmetic overflow), U is <a class="el" href="structetl_1_1ratio.html#a15ad9bea294aeeba2f02f33ec0283065">etl::ratio&lt;Num, Denom&gt;::num</a> and V is <a class="el" href="structetl_1_1ratio.html" title="The class template provides compile-time rational arithmetic support. Each instantiation of this temp...">etl::ratio</a>&lt;Num, Denom&gt;::den.  <a href="#a234acc6c1438740afe4f7766f1208784">More...</a><br /></td></tr>
<tr class="separator:a234acc6c1438740afe4f7766f1208784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2769dde06d41131748597077535e2cc"><td class="memTemplParams" colspan="2">template&lt;etl::size_t Capacity&gt; </td></tr>
<tr class="memitem:af2769dde06d41131748597077535e2cc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af2769dde06d41131748597077535e2cc">string</a> = <a class="el" href="classetl_1_1basic__string.html">basic_string</a>&lt; char, Capacity &gt;</td></tr>
<tr class="separator:af2769dde06d41131748597077535e2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bffa043c410459eda373247f384b9e2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9bffa043c410459eda373247f384b9e2">small_string</a> = <a class="el" href="classetl_1_1basic__string.html">basic_string</a>&lt; char, 32 &gt;</td></tr>
<tr class="separator:a9bffa043c410459eda373247f384b9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b54646ef5937839803117924c49d01"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac5b54646ef5937839803117924c49d01">true_type</a> = <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; bool, true &gt;</td></tr>
<tr class="separator:ac5b54646ef5937839803117924c49d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0917d3f5e85877c283c4f04e327fd973"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0917d3f5e85877c283c4f04e327fd973">false_type</a> = <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; bool, false &gt;</td></tr>
<tr class="separator:a0917d3f5e85877c283c4f04e327fd973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f76cc2621d7373b79e2fc034f160ee0"><td class="memTemplParams" colspan="2">template&lt;class... &gt; </td></tr>
<tr class="memitem:a8f76cc2621d7373b79e2fc034f160ee0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8f76cc2621d7373b79e2fc034f160ee0">void_t</a> = void</td></tr>
<tr class="separator:a8f76cc2621d7373b79e2fc034f160ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662329de2bc2a83d5e45d1ccad797f17"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a662329de2bc2a83d5e45d1ccad797f17"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a662329de2bc2a83d5e45d1ccad797f17">add_lvalue_reference_t</a> = typename <a class="el" href="structetl_1_1add__lvalue__reference.html">add_lvalue_reference</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a662329de2bc2a83d5e45d1ccad797f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c37a443b0cb66dc9b3c4374967b68f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a17c37a443b0cb66dc9b3c4374967b68f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a17c37a443b0cb66dc9b3c4374967b68f">add_rvalue_reference_t</a> = typename <a class="el" href="structetl_1_1add__rvalue__reference.html">add_rvalue_reference</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a17c37a443b0cb66dc9b3c4374967b68f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e058aba499e52cc4ed554dd7d65332"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a87e058aba499e52cc4ed554dd7d65332"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a87e058aba499e52cc4ed554dd7d65332">remove_const_t</a> = typename <a class="el" href="structetl_1_1remove__const.html">remove_const</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a87e058aba499e52cc4ed554dd7d65332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4593c7817c464ffa0d88cc07eb35e83"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af4593c7817c464ffa0d88cc07eb35e83"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af4593c7817c464ffa0d88cc07eb35e83">remove_volatile_t</a> = typename <a class="el" href="structetl_1_1remove__volatile.html">remove_volatile</a>&lt; T &gt;::type</td></tr>
<tr class="separator:af4593c7817c464ffa0d88cc07eb35e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70fb46b3c4c98f5f23b76cb25f343373"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a70fb46b3c4c98f5f23b76cb25f343373"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a70fb46b3c4c98f5f23b76cb25f343373">remove_cv_t</a> = typename <a class="el" href="structetl_1_1remove__cv.html">remove_cv</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a70fb46b3c4c98f5f23b76cb25f343373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ceb8de4fe37ef6a14f78dd10d95bb6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a26ceb8de4fe37ef6a14f78dd10d95bb6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a26ceb8de4fe37ef6a14f78dd10d95bb6">remove_reference_t</a> = typename <a class="el" href="structetl_1_1remove__reference.html">remove_reference</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a26ceb8de4fe37ef6a14f78dd10d95bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2df53f4e399975501cf8300d451814"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:acb2df53f4e399975501cf8300d451814"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#acb2df53f4e399975501cf8300d451814">make_unsigned_t</a> = typename <a class="el" href="structetl_1_1make__unsigned.html">make_unsigned</a>&lt; T &gt;::type</td></tr>
<tr class="separator:acb2df53f4e399975501cf8300d451814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55bc1fa71ef93a7cd65389359e61683c"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:a55bc1fa71ef93a7cd65389359e61683c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a55bc1fa71ef93a7cd65389359e61683c">is_constructible</a> = <a class="el" href="structetl_1_1detail_1_1is__constructible__helper.html">detail::is_constructible_helper</a>&lt; <a class="el" href="namespaceetl.html#a8f76cc2621d7373b79e2fc034f160ee0">void_t</a>&lt;&gt;, T, Args... &gt;</td></tr>
<tr class="separator:a55bc1fa71ef93a7cd65389359e61683c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa508ba172c61957cf6c18357210f08f6"><td class="memTemplParams" colspan="2">template&lt;bool B, class T , class F &gt; </td></tr>
<tr class="memitem:aa508ba172c61957cf6c18357210f08f6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa508ba172c61957cf6c18357210f08f6">conditional_t</a> = typename <a class="el" href="structetl_1_1conditional.html">conditional</a>&lt; B, T, F &gt;::type</td></tr>
<tr class="separator:aa508ba172c61957cf6c18357210f08f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2df4ab89284c8c5866afea3100f290"><td class="memTemplParams" colspan="2">template&lt;bool B, class T  = void&gt; </td></tr>
<tr class="memitem:a2a2df4ab89284c8c5866afea3100f290"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a> = typename <a class="el" href="structetl_1_1enable__if.html">enable_if</a>&lt; B, T &gt;::type</td></tr>
<tr class="separator:a2a2df4ab89284c8c5866afea3100f290"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aadba129a7dc760f449b09b7fafeb63a8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aadba129a7dc760f449b09b7fafeb63a8">endian</a> { <a class="el" href="namespaceetl.html#aadba129a7dc760f449b09b7fafeb63a8aaae6635e044ac56046b2893a529b5114">endian::little</a> = __ORDER_LITTLE_ENDIAN__, 
<a class="el" href="namespaceetl.html#aadba129a7dc760f449b09b7fafeb63a8ad861877da56b8b4ceb35c8cbfdf65bb4">endian::big</a> = __ORDER_BIG_ENDIAN__, 
<a class="el" href="namespaceetl.html#aadba129a7dc760f449b09b7fafeb63a8a8e5f3adee38c8fccc13c1f3be0143796">endian::native</a> = __BYTE_ORDER__
 }<tr class="memdesc:aadba129a7dc760f449b09b7fafeb63a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the endianness of all scalar types.  <a href="namespaceetl.html#aadba129a7dc760f449b09b7fafeb63a8">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aadba129a7dc760f449b09b7fafeb63a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe360a11ae9b0c5886f80ce2ff28a9d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">byte</a> : uint8_t </td></tr>
<tr class="separator:a3fe360a11ae9b0c5886f80ce2ff28a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cdec522db16c755ade7c7222bf8af92"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0cdec522db16c755ade7c7222bf8af92">float_round_style</a> { <br />
&#160;&#160;<a class="el" href="namespaceetl.html#a0cdec522db16c755ade7c7222bf8af92afd0fa1de009f9a47f51a0ec9c23aa10b">round_indeterminate</a> = -1, 
<a class="el" href="namespaceetl.html#a0cdec522db16c755ade7c7222bf8af92a00004115cf199c1cd29d07f78679a63d">round_toward_zero</a> = 0, 
<a class="el" href="namespaceetl.html#a0cdec522db16c755ade7c7222bf8af92a1fc678348a02cf4262fb59153d5b73c3">round_to_nearest</a> = 1, 
<a class="el" href="namespaceetl.html#a0cdec522db16c755ade7c7222bf8af92a274b79e7a1a164b8b9eea17dda4751c0">round_toward_infinity</a> = 2, 
<br />
&#160;&#160;<a class="el" href="namespaceetl.html#a0cdec522db16c755ade7c7222bf8af92ac6babddc09b7dbf6e3daf12455e3417f">round_toward_neg_infinity</a> = 3
<br />
 }</td></tr>
<tr class="separator:a0cdec522db16c755ade7c7222bf8af92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4892bd9af0bd3ad759fb95ab241247c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad4892bd9af0bd3ad759fb95ab241247c">float_denorm_style</a> { <a class="el" href="namespaceetl.html#ad4892bd9af0bd3ad759fb95ab241247cadc095ee49d9e6884cd67bc20a4c73287">denorm_indeterminate</a> = -1, 
<a class="el" href="namespaceetl.html#ad4892bd9af0bd3ad759fb95ab241247caf254439f29ec6166a1a6fb7b09efd141">denorm_absent</a> = 0, 
<a class="el" href="namespaceetl.html#ad4892bd9af0bd3ad759fb95ab241247ca5a085126714d6734d58691edaa278aa5">denorm_present</a> = 1
 }</td></tr>
<tr class="separator:ad4892bd9af0bd3ad759fb95ab241247c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d70da9977ec456339973b30e372fcbd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3d70da9977ec456339973b30e372fcbd">language_standard</a> { <br />
&#160;&#160;<a class="el" href="namespaceetl.html#a3d70da9977ec456339973b30e372fcbda807ac7fd9764fb3e810d9f1048cd63ca">language_standard::cpp_98</a> = 1998, 
<a class="el" href="namespaceetl.html#a3d70da9977ec456339973b30e372fcbdabbe07f980d9fa36187463846b2811aed">language_standard::cpp_11</a> = 2011, 
<a class="el" href="namespaceetl.html#a3d70da9977ec456339973b30e372fcbdaee3f3f8ff98b05c178cea91bf69cde50">language_standard::cpp_14</a> = 2014, 
<a class="el" href="namespaceetl.html#a3d70da9977ec456339973b30e372fcbda6289bbfa378818f7066ccad5847da5a2">language_standard::cpp_17</a> = 2017, 
<br />
&#160;&#160;<a class="el" href="namespaceetl.html#a3d70da9977ec456339973b30e372fcbda4c7aabdc3eb0d845c62edfb822b0fe5a">language_standard::cpp_20</a> = 2020
<br />
 }<tr class="memdesc:a3d70da9977ec456339973b30e372fcbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration for the currently selected C++ standard version.  <a href="namespaceetl.html#a3d70da9977ec456339973b30e372fcbd">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a3d70da9977ec456339973b30e372fcbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a013f931a99670b660a20f65b845013a3"><td class="memTemplParams" colspan="2">template&lt;class InputIt , class UnaryFunction &gt; </td></tr>
<tr class="memitem:a013f931a99670b660a20f65b845013a3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a013f931a99670b660a20f65b845013a3">for_each</a> (InputIt first, InputIt last, UnaryFunction f) noexcept -&gt; UnaryFunction</td></tr>
<tr class="memdesc:a013f931a99670b660a20f65b845013a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given function object f to the result of dereferencing every iterator in the range [first, last] in order.  <a href="#a013f931a99670b660a20f65b845013a3">More...</a><br /></td></tr>
<tr class="separator:a013f931a99670b660a20f65b845013a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad648007806d54bdfc4e127ab1e1ca4a3"><td class="memTemplParams" colspan="2">template&lt;class InputIt , class Size , class UnaryFunction &gt; </td></tr>
<tr class="memitem:ad648007806d54bdfc4e127ab1e1ca4a3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad648007806d54bdfc4e127ab1e1ca4a3">for_each_n</a> (InputIt first, Size n, UnaryFunction f) noexcept -&gt; InputIt</td></tr>
<tr class="memdesc:ad648007806d54bdfc4e127ab1e1ca4a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given function object f to the result of dereferencing every iterator in the range [first, first+n] in order.  <a href="#ad648007806d54bdfc4e127ab1e1ca4a3">More...</a><br /></td></tr>
<tr class="separator:ad648007806d54bdfc4e127ab1e1ca4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33857e090fba6747166a167e1018400"><td class="memTemplParams" colspan="2">template&lt;class InputIt , class T &gt; </td></tr>
<tr class="memitem:af33857e090fba6747166a167e1018400"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af33857e090fba6747166a167e1018400">find</a> (InputIt first, InputIt last, const T &amp;value) noexcept -&gt; InputIt</td></tr>
<tr class="memdesc:af33857e090fba6747166a167e1018400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an element equal to value.  <a href="#af33857e090fba6747166a167e1018400">More...</a><br /></td></tr>
<tr class="separator:af33857e090fba6747166a167e1018400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa4355c6aa8d1f3fbd2019acfee332f"><td class="memTemplParams" colspan="2">template&lt;class InputIt , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:a6fa4355c6aa8d1f3fbd2019acfee332f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6fa4355c6aa8d1f3fbd2019acfee332f">find_if</a> (InputIt first, InputIt last, UnaryPredicate p) noexcept -&gt; InputIt</td></tr>
<tr class="memdesc:a6fa4355c6aa8d1f3fbd2019acfee332f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an element for which predicate p returns true.  <a href="#a6fa4355c6aa8d1f3fbd2019acfee332f">More...</a><br /></td></tr>
<tr class="separator:a6fa4355c6aa8d1f3fbd2019acfee332f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8040ddc904e657cfe6c640d775b47a"><td class="memTemplParams" colspan="2">template&lt;class InputIt , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:afc8040ddc904e657cfe6c640d775b47a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afc8040ddc904e657cfe6c640d775b47a">find_if_not</a> (InputIt first, InputIt last, UnaryPredicate q) noexcept -&gt; InputIt</td></tr>
<tr class="memdesc:afc8040ddc904e657cfe6c640d775b47a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an element for which predicate q returns false.  <a href="#afc8040ddc904e657cfe6c640d775b47a">More...</a><br /></td></tr>
<tr class="separator:afc8040ddc904e657cfe6c640d775b47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fdd0cf88f36f44f8fe8ec8327cfac74"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a7fdd0cf88f36f44f8fe8ec8327cfac74"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7fdd0cf88f36f44f8fe8ec8327cfac74">max</a> (Type const &amp;a, Type const &amp;b) noexcept -&gt; Type const &amp;</td></tr>
<tr class="memdesc:a7fdd0cf88f36f44f8fe8ec8327cfac74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the greater of a and b.  <a href="#a7fdd0cf88f36f44f8fe8ec8327cfac74">More...</a><br /></td></tr>
<tr class="separator:a7fdd0cf88f36f44f8fe8ec8327cfac74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220fbd23aca7dbc728c200471ed114c8"><td class="memTemplParams" colspan="2">template&lt;class Type , class Compare &gt; </td></tr>
<tr class="memitem:a220fbd23aca7dbc728c200471ed114c8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a220fbd23aca7dbc728c200471ed114c8">max</a> (Type const &amp;a, Type const &amp;b, Compare comp) noexcept -&gt; Type const &amp;</td></tr>
<tr class="memdesc:a220fbd23aca7dbc728c200471ed114c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the greater of a and b, using a compare function.  <a href="#a220fbd23aca7dbc728c200471ed114c8">More...</a><br /></td></tr>
<tr class="separator:a220fbd23aca7dbc728c200471ed114c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa58c8973da727c50c3d0d28b83fdf304"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:aa58c8973da727c50c3d0d28b83fdf304"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa58c8973da727c50c3d0d28b83fdf304">max_element</a> (ForwardIterator first, ForwardIterator last) noexcept -&gt; ForwardIterator</td></tr>
<tr class="memdesc:aa58c8973da727c50c3d0d28b83fdf304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the greatest element in the range [first, last). Elements are compared using operator&lt;.  <a href="#aa58c8973da727c50c3d0d28b83fdf304">More...</a><br /></td></tr>
<tr class="separator:aa58c8973da727c50c3d0d28b83fdf304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab573cae5dd21a6ab0e00ee00da8855e0"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class Compare &gt; </td></tr>
<tr class="memitem:ab573cae5dd21a6ab0e00ee00da8855e0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab573cae5dd21a6ab0e00ee00da8855e0">max_element</a> (ForwardIterator first, ForwardIterator last, Compare comp) -&gt; ForwardIterator</td></tr>
<tr class="memdesc:ab573cae5dd21a6ab0e00ee00da8855e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the greatest element in the range [first, last). Elements are compared using the given binary comparison function comp.  <a href="#ab573cae5dd21a6ab0e00ee00da8855e0">More...</a><br /></td></tr>
<tr class="separator:ab573cae5dd21a6ab0e00ee00da8855e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae1500815312b248e453896d5439b63"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:adae1500815312b248e453896d5439b63"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adae1500815312b248e453896d5439b63">min</a> (Type const &amp;a, Type const &amp;b) noexcept -&gt; Type const &amp;</td></tr>
<tr class="memdesc:adae1500815312b248e453896d5439b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller of a and b.  <a href="#adae1500815312b248e453896d5439b63">More...</a><br /></td></tr>
<tr class="separator:adae1500815312b248e453896d5439b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479c4a8315ae3ef2d1128858d723afc2"><td class="memTemplParams" colspan="2">template&lt;class Type , class Compare &gt; </td></tr>
<tr class="memitem:a479c4a8315ae3ef2d1128858d723afc2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a479c4a8315ae3ef2d1128858d723afc2">min</a> (Type const &amp;a, Type const &amp;b, Compare comp) noexcept -&gt; Type const &amp;</td></tr>
<tr class="memdesc:a479c4a8315ae3ef2d1128858d723afc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller of a and b, using a compare function.  <a href="#a479c4a8315ae3ef2d1128858d723afc2">More...</a><br /></td></tr>
<tr class="separator:a479c4a8315ae3ef2d1128858d723afc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f1e60aa2d0ca23d39bd975ed52e4b4"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a41f1e60aa2d0ca23d39bd975ed52e4b4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a41f1e60aa2d0ca23d39bd975ed52e4b4">min_element</a> (ForwardIterator first, ForwardIterator last) noexcept -&gt; ForwardIterator</td></tr>
<tr class="memdesc:a41f1e60aa2d0ca23d39bd975ed52e4b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the smallest element in the range [first, last). Elements are compared using operator&lt;.  <a href="#a41f1e60aa2d0ca23d39bd975ed52e4b4">More...</a><br /></td></tr>
<tr class="separator:a41f1e60aa2d0ca23d39bd975ed52e4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae206eeb82f5e460124ce4b40e951fa0d"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class Compare &gt; </td></tr>
<tr class="memitem:ae206eeb82f5e460124ce4b40e951fa0d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae206eeb82f5e460124ce4b40e951fa0d">min_element</a> (ForwardIterator first, ForwardIterator last, Compare comp) -&gt; ForwardIterator</td></tr>
<tr class="memdesc:ae206eeb82f5e460124ce4b40e951fa0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the smallest element in the range [first, last). Elements are compared using the given binary comparison function comp.  <a href="#ae206eeb82f5e460124ce4b40e951fa0d">More...</a><br /></td></tr>
<tr class="separator:ae206eeb82f5e460124ce4b40e951fa0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90379160c94dc0396b5f32204c790bf"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:af90379160c94dc0396b5f32204c790bf"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af90379160c94dc0396b5f32204c790bf">clamp</a> (Type const &amp;v, Type const &amp;lo, Type const &amp;hi) noexcept -&gt; Type const &amp;</td></tr>
<tr class="memdesc:af90379160c94dc0396b5f32204c790bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">If v compares less than lo, returns lo; otherwise if hi compares less than v, returns hi; otherwise returns v. Uses operator&lt; to compare the values.  <a href="#af90379160c94dc0396b5f32204c790bf">More...</a><br /></td></tr>
<tr class="separator:af90379160c94dc0396b5f32204c790bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa416a307b0bb33666d34845c42ba2b"><td class="memTemplParams" colspan="2">template&lt;class Type , class Compare &gt; </td></tr>
<tr class="memitem:abfa416a307b0bb33666d34845c42ba2b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abfa416a307b0bb33666d34845c42ba2b">clamp</a> (Type const &amp;v, Type const &amp;lo, Type const &amp;hi, Compare comp) -&gt; Type const &amp;</td></tr>
<tr class="separator:abfa416a307b0bb33666d34845c42ba2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b7eed2eaa0b58da478a2d559164bb4"><td class="memTemplParams" colspan="2">template&lt;class InputIt , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:ad9b7eed2eaa0b58da478a2d559164bb4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad9b7eed2eaa0b58da478a2d559164bb4">all_of</a> (InputIt first, InputIt last, UnaryPredicate p) -&gt; bool</td></tr>
<tr class="memdesc:ad9b7eed2eaa0b58da478a2d559164bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate p returns true for all elements in the range [first, last).  <a href="#ad9b7eed2eaa0b58da478a2d559164bb4">More...</a><br /></td></tr>
<tr class="separator:ad9b7eed2eaa0b58da478a2d559164bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74cda9bdcb48dfe219176e8fbe4f3aa6"><td class="memTemplParams" colspan="2">template&lt;class InputIt , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:a74cda9bdcb48dfe219176e8fbe4f3aa6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a74cda9bdcb48dfe219176e8fbe4f3aa6">any_of</a> (InputIt first, InputIt last, UnaryPredicate p) -&gt; bool</td></tr>
<tr class="memdesc:a74cda9bdcb48dfe219176e8fbe4f3aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate p returns true for at least one element in the range [first, last).  <a href="#a74cda9bdcb48dfe219176e8fbe4f3aa6">More...</a><br /></td></tr>
<tr class="separator:a74cda9bdcb48dfe219176e8fbe4f3aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add22a48a49c792039e0d0ec1eef5528b"><td class="memTemplParams" colspan="2">template&lt;class InputIt , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:add22a48a49c792039e0d0ec1eef5528b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#add22a48a49c792039e0d0ec1eef5528b">none_of</a> (InputIt first, InputIt last, UnaryPredicate p) -&gt; bool</td></tr>
<tr class="memdesc:add22a48a49c792039e0d0ec1eef5528b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate p returns true for no elements in the range [first, last).  <a href="#add22a48a49c792039e0d0ec1eef5528b">More...</a><br /></td></tr>
<tr class="separator:add22a48a49c792039e0d0ec1eef5528b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a13233ebf471c62f35f40b21128884"><td class="memTemplParams" colspan="2">template&lt;class T , class... U&gt; </td></tr>
<tr class="memitem:ae5a13233ebf471c62f35f40b21128884"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae5a13233ebf471c62f35f40b21128884">array</a> (T, U...) -&gt; <a class="el" href="classetl_1_1array.html">array</a>&lt; T, 1+sizeof...(U)&gt;</td></tr>
<tr class="separator:ae5a13233ebf471c62f35f40b21128884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d02c4c388de0067ab15cb5febdebea7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0d02c4c388de0067ab15cb5febdebea7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0d02c4c388de0067ab15cb5febdebea7">popcount</a> (T input) noexcept -&gt; int</td></tr>
<tr class="memdesc:a0d02c4c388de0067ab15cb5febdebea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of 1 bits in the value of x.  <a href="#a0d02c4c388de0067ab15cb5febdebea7">More...</a><br /></td></tr>
<tr class="separator:a0d02c4c388de0067ab15cb5febdebea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa84e096751094f12fc96460addc2483"><td class="memTemplParams" colspan="2">template&lt;typename Integer &gt; </td></tr>
<tr class="memitem:aaa84e096751094f12fc96460addc2483"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aaa84e096751094f12fc96460addc2483">to_integer</a> (<a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> b) noexcept -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt; <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt; Integer &gt;, Integer &gt;</td></tr>
<tr class="memdesc:aaa84e096751094f12fc96460addc2483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: return Integer(b); This overload only participates in overload resolution if <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v&lt;Integer&gt;</a> is true.  <a href="#aaa84e096751094f12fc96460addc2483">More...</a><br /></td></tr>
<tr class="separator:aaa84e096751094f12fc96460addc2483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0480e65e737703d71651dbf0ec77f6be"><td class="memTemplParams" colspan="2">template&lt;class Integer &gt; </td></tr>
<tr class="memitem:a0480e65e737703d71651dbf0ec77f6be"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0480e65e737703d71651dbf0ec77f6be">operator&lt;&lt;</a> (<a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> b, Integer shift) noexcept -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt; <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt; Integer &gt;, <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> &gt;</td></tr>
<tr class="memdesc:a0480e65e737703d71651dbf0ec77f6be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: return <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>(static_cast&lt;unsigned int&gt;(b) &lt;&lt; shift); This overload only participates in overload resolution if <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v&lt;Integer&gt;</a> is true.  <a href="#a0480e65e737703d71651dbf0ec77f6be">More...</a><br /></td></tr>
<tr class="separator:a0480e65e737703d71651dbf0ec77f6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45fcae26cfb190fcc8ea6ab10da01f0"><td class="memTemplParams" colspan="2">template&lt;class Integer &gt; </td></tr>
<tr class="memitem:ac45fcae26cfb190fcc8ea6ab10da01f0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac45fcae26cfb190fcc8ea6ab10da01f0">operator&gt;&gt;</a> (<a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> b, Integer shift) noexcept -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt; <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt; Integer &gt;, <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> &gt;</td></tr>
<tr class="memdesc:ac45fcae26cfb190fcc8ea6ab10da01f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: return <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>(static_cast&lt;unsigned int&gt;(b) &gt;&gt; shift); This overload only participates in overload resolution if <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v&lt;Integer&gt;</a> is true.  <a href="#ac45fcae26cfb190fcc8ea6ab10da01f0">More...</a><br /></td></tr>
<tr class="separator:ac45fcae26cfb190fcc8ea6ab10da01f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d724ccacf75835ddc7e208bf977df9e"><td class="memTemplParams" colspan="2">template&lt;class Integer &gt; </td></tr>
<tr class="memitem:a4d724ccacf75835ddc7e208bf977df9e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4d724ccacf75835ddc7e208bf977df9e">operator&lt;&lt;=</a> (<a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> &amp;b, Integer shift) noexcept -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt; <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt; Integer &gt;, <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> &amp;&gt;</td></tr>
<tr class="memdesc:a4d724ccacf75835ddc7e208bf977df9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: return b = b &lt;&lt; shift; This overload only participates in overload resolution if <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v&lt;Integer&gt;</a> is true.  <a href="#a4d724ccacf75835ddc7e208bf977df9e">More...</a><br /></td></tr>
<tr class="separator:a4d724ccacf75835ddc7e208bf977df9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12556a00fd4d36c275c51643b2c6168a"><td class="memTemplParams" colspan="2">template&lt;class Integer &gt; </td></tr>
<tr class="memitem:a12556a00fd4d36c275c51643b2c6168a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a12556a00fd4d36c275c51643b2c6168a">operator&gt;&gt;=</a> (<a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> &amp;b, Integer shift) noexcept -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt; <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt; Integer &gt;, <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> &amp;&gt;</td></tr>
<tr class="memdesc:a12556a00fd4d36c275c51643b2c6168a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: return b = b &gt;&gt; shift; This overload only participates in overload resolution if <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v&lt;Integer&gt;</a> is true.  <a href="#a12556a00fd4d36c275c51643b2c6168a">More...</a><br /></td></tr>
<tr class="separator:a12556a00fd4d36c275c51643b2c6168a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe220615749beb7a953b281e623e529"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8fe220615749beb7a953b281e623e529">operator|</a> (<a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> l, <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> r) noexcept -&gt; <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a></td></tr>
<tr class="memdesc:a8fe220615749beb7a953b281e623e529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: return <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>(static_cast&lt;unsigned int&gt;(l) | static_cast&lt;unsigned int&gt;(r));.  <a href="#a8fe220615749beb7a953b281e623e529">More...</a><br /></td></tr>
<tr class="separator:a8fe220615749beb7a953b281e623e529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300d68a0b017d8b6f41d000a8800cd77"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a300d68a0b017d8b6f41d000a8800cd77">operator &amp;</a> (<a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> l, <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> r) noexcept -&gt; <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a></td></tr>
<tr class="memdesc:a300d68a0b017d8b6f41d000a8800cd77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: return <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>(static_cast&lt;unsigned int&gt;(l) &amp; static_cast&lt;unsigned int&gt;(r));.  <a href="#a300d68a0b017d8b6f41d000a8800cd77">More...</a><br /></td></tr>
<tr class="separator:a300d68a0b017d8b6f41d000a8800cd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca2f44bc05dd8dbd6f9ea8beadef229"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6ca2f44bc05dd8dbd6f9ea8beadef229">operator^</a> (<a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> l, <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> r) noexcept -&gt; <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a></td></tr>
<tr class="memdesc:a6ca2f44bc05dd8dbd6f9ea8beadef229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: return <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>(static_cast&lt;unsigned int&gt;(l) ^ static_cast&lt;unsigned int&gt;(r));.  <a href="#a6ca2f44bc05dd8dbd6f9ea8beadef229">More...</a><br /></td></tr>
<tr class="separator:a6ca2f44bc05dd8dbd6f9ea8beadef229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb428553f8379a8f3920c202cd85993"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6cb428553f8379a8f3920c202cd85993">operator~</a> (<a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> b) noexcept -&gt; <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a></td></tr>
<tr class="memdesc:a6cb428553f8379a8f3920c202cd85993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: return <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>(~static_cast&lt;unsigned int&gt;(b));.  <a href="#a6cb428553f8379a8f3920c202cd85993">More...</a><br /></td></tr>
<tr class="separator:a6cb428553f8379a8f3920c202cd85993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f53c7f64802ca7093607b55cb86bc6"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a73f53c7f64802ca7093607b55cb86bc6">operator|=</a> (<a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> &amp;l, <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> r) noexcept -&gt; <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> &amp;</td></tr>
<tr class="memdesc:a73f53c7f64802ca7093607b55cb86bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: return l = l | r;.  <a href="#a73f53c7f64802ca7093607b55cb86bc6">More...</a><br /></td></tr>
<tr class="separator:a73f53c7f64802ca7093607b55cb86bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30243ddf0699dede912521c57cb92a25"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a30243ddf0699dede912521c57cb92a25">operator &amp;=</a> (<a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> &amp;l, <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> r) noexcept -&gt; <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> &amp;</td></tr>
<tr class="memdesc:a30243ddf0699dede912521c57cb92a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: return l = l &amp; r;.  <a href="#a30243ddf0699dede912521c57cb92a25">More...</a><br /></td></tr>
<tr class="separator:a30243ddf0699dede912521c57cb92a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0145ea9af63899833b6bf5f9f18fb7c1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0145ea9af63899833b6bf5f9f18fb7c1">operator^=</a> (<a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> &amp;l, <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> r) noexcept -&gt; <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> &amp;</td></tr>
<tr class="memdesc:a0145ea9af63899833b6bf5f9f18fb7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: return l = l ^ r;.  <a href="#a0145ea9af63899833b6bf5f9f18fb7c1">More...</a><br /></td></tr>
<tr class="separator:a0145ea9af63899833b6bf5f9f18fb7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a28bb04c335112b2c13d676c422e66"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a99a28bb04c335112b2c13d676c422e66">memcpy</a> (void *dest, const void *src, <a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">etl::size_t</a> n) -&gt; void *</td></tr>
<tr class="memdesc:a99a28bb04c335112b2c13d676c422e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the first n bytes pointed to by src to the buffer pointed to by dest. Source and destination may not overlap. If source and destination might overlap, <a class="el" href="namespaceetl.html#a4604077670e2126de4d05e9d4dab2df9" title="Copy the first n bytes pointed to by src to the buffer pointed to by dest. Source and destination may...">memmove()</a> must be used instead.  <a href="#a99a28bb04c335112b2c13d676c422e66">More...</a><br /></td></tr>
<tr class="separator:a99a28bb04c335112b2c13d676c422e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055dc327ea35a394f661ca98bf2b08ad"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a055dc327ea35a394f661ca98bf2b08ad">memset</a> (void *s, int c, <a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">etl::size_t</a> n) -&gt; void *</td></tr>
<tr class="memdesc:a055dc327ea35a394f661ca98bf2b08ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the value of c (converted to an unsigned char) into each of the rst n characters of the object pointed to by s.  <a href="#a055dc327ea35a394f661ca98bf2b08ad">More...</a><br /></td></tr>
<tr class="separator:a055dc327ea35a394f661ca98bf2b08ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4604077670e2126de4d05e9d4dab2df9"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4604077670e2126de4d05e9d4dab2df9">memmove</a> (void *dest, const void *src, <a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">etl::size_t</a> n) -&gt; void *</td></tr>
<tr class="memdesc:a4604077670e2126de4d05e9d4dab2df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the first n bytes pointed to by src to the buffer pointed to by dest. Source and destination may overlap.  <a href="#a4604077670e2126de4d05e9d4dab2df9">More...</a><br /></td></tr>
<tr class="separator:a4604077670e2126de4d05e9d4dab2df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add013e52c2672440c53a8d2c82d4c63a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#add013e52c2672440c53a8d2c82d4c63a">strlen</a> (const char *str) -&gt; <a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">etl::size_t</a></td></tr>
<tr class="memdesc:add013e52c2672440c53a8d2c82d4c63a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the C string str.  <a href="#add013e52c2672440c53a8d2c82d4c63a">More...</a><br /></td></tr>
<tr class="separator:add013e52c2672440c53a8d2c82d4c63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe443a26a34b79fc921c4583df576333"><td class="memTemplParams" colspan="2">template&lt;class InputIt , class Type &gt; </td></tr>
<tr class="memitem:afe443a26a34b79fc921c4583df576333"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afe443a26a34b79fc921c4583df576333">accumulate</a> (InputIt first, InputIt last, Type init) noexcept -&gt; Type</td></tr>
<tr class="memdesc:afe443a26a34b79fc921c4583df576333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of the given value init and the elements in the range [first, last). Uses operator+ to sum up the elements.  <a href="#afe443a26a34b79fc921c4583df576333">More...</a><br /></td></tr>
<tr class="separator:afe443a26a34b79fc921c4583df576333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9413959b7ee39d393e7c35ad2cd78294"><td class="memTemplParams" colspan="2">template&lt;class InputIt , class Type , class BinaryOperation &gt; </td></tr>
<tr class="memitem:a9413959b7ee39d393e7c35ad2cd78294"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9413959b7ee39d393e7c35ad2cd78294">accumulate</a> (InputIt first, InputIt last, Type init, BinaryOperation op) noexcept -&gt; Type</td></tr>
<tr class="memdesc:a9413959b7ee39d393e7c35ad2cd78294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of the given value init and the elements in the range [first, last). Uses the BinaryOperation to sum up the elements.  <a href="#a9413959b7ee39d393e7c35ad2cd78294">More...</a><br /></td></tr>
<tr class="separator:a9413959b7ee39d393e7c35ad2cd78294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594a7b7fb202c9a1b6d82115e7a172e3"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a594a7b7fb202c9a1b6d82115e7a172e3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a594a7b7fb202c9a1b6d82115e7a172e3">abs</a> (Type input) noexcept -&gt; Type</td></tr>
<tr class="memdesc:a594a7b7fb202c9a1b6d82115e7a172e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value.  <a href="#a594a7b7fb202c9a1b6d82115e7a172e3">More...</a><br /></td></tr>
<tr class="separator:a594a7b7fb202c9a1b6d82115e7a172e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c15d45f1e3cd0c35fa9c638e90fb4b"><td class="memTemplParams" colspan="2">template&lt;typename M , typename N &gt; </td></tr>
<tr class="memitem:ac0c15d45f1e3cd0c35fa9c638e90fb4b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac0c15d45f1e3cd0c35fa9c638e90fb4b">gcd</a> (M m, N n) noexcept</td></tr>
<tr class="memdesc:ac0c15d45f1e3cd0c35fa9c638e90fb4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the greatest common divisor of the integers m and n.  <a href="#ac0c15d45f1e3cd0c35fa9c638e90fb4b">More...</a><br /></td></tr>
<tr class="separator:ac0c15d45f1e3cd0c35fa9c638e90fb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9900f32867800d2a9ffa2c660090cc83"><td class="memTemplParams" colspan="2">template&lt;typename Integer &gt; </td></tr>
<tr class="memitem:a9900f32867800d2a9ffa2c660090cc83"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9900f32867800d2a9ffa2c660090cc83">midpoint</a> (Integer a, Integer b) noexcept -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt; <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt; Integer &gt;, Integer &gt;</td></tr>
<tr class="memdesc:a9900f32867800d2a9ffa2c660090cc83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns half the sum of a + b. If the sum is odd, the result is rounded towards a.  T is arithmentic type other than bool.  <a href="#a9900f32867800d2a9ffa2c660090cc83">More...</a><br /></td></tr>
<tr class="separator:a9900f32867800d2a9ffa2c660090cc83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6eb417ecc3a7b1c7e71baab1c2c522"><td class="memTemplParams" colspan="2">template&lt;typename Float &gt; </td></tr>
<tr class="memitem:acd6eb417ecc3a7b1c7e71baab1c2c522"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#acd6eb417ecc3a7b1c7e71baab1c2c522">midpoint</a> (Float a, Float b) noexcept -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt; <a class="el" href="namespaceetl.html#a5cf273d19443134cffcd66310d027ae4">etl::is_floating_point_v</a>&lt; Float &gt;, Float &gt;</td></tr>
<tr class="separator:acd6eb417ecc3a7b1c7e71baab1c2c522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f4c423421fddd2a2f941d805c05300"><td class="memTemplParams" colspan="2">template&lt;typename Pointer &gt; </td></tr>
<tr class="memitem:ad2f4c423421fddd2a2f941d805c05300"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad2f4c423421fddd2a2f941d805c05300">midpoint</a> (Pointer a, Pointer b) noexcept -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt; <a class="el" href="namespaceetl.html#ac00eca7d51c4d2c1021402ee9a70f03c">is_pointer_v</a>&lt; Pointer &gt;, Pointer &gt;</td></tr>
<tr class="separator:ad2f4c423421fddd2a2f941d805c05300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f4fd4efe3204f43756b83be3ae1479"><td class="memTemplParams" colspan="2">template&lt;int index, typename First , typename... Rest&gt; </td></tr>
<tr class="memitem:a15f4fd4efe3204f43756b83be3ae1479"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a15f4fd4efe3204f43756b83be3ae1479">get</a> (const <a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; First, Rest... &gt; &amp;t) -&gt; decltype(<a class="el" href="structetl_1_1detail_1_1get__impl.html">detail::get_impl</a>&lt; index, First, Rest... &gt;::value(&amp;t))</td></tr>
<tr class="separator:a15f4fd4efe3204f43756b83be3ae1479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4147daa38c6c4c1e59540fa0fa27a292"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4147daa38c6c4c1e59540fa0fa27a292"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292">declval</a> () noexcept -&gt; typename <a class="el" href="structetl_1_1add__rvalue__reference.html">etl::add_rvalue_reference</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a4147daa38c6c4c1e59540fa0fa27a292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4165fb01e5de4a84bfd7367b5133cb3d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4165fb01e5de4a84bfd7367b5133cb3d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4165fb01e5de4a84bfd7367b5133cb3d">move</a> (T &amp;&amp;t) noexcept -&gt; typename <a class="el" href="structetl_1_1remove__reference.html">etl::remove_reference</a>&lt; T &gt;::type &amp;&amp;</td></tr>
<tr class="memdesc:a4165fb01e5de4a84bfd7367b5133cb3d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceetl.html#a4165fb01e5de4a84bfd7367b5133cb3d" title="etl::move is used to indicate that an object t may be &quot;moved from&quot;, i.e. allowing the efficient trans...">etl::move</a> is used to indicate that an object t may be "moved from", i.e. allowing the efficient transfer of resources from t to another object. In particular, <a class="el" href="namespaceetl.html#a4165fb01e5de4a84bfd7367b5133cb3d" title="etl::move is used to indicate that an object t may be &quot;moved from&quot;, i.e. allowing the efficient trans...">etl::move</a> produces an xvalue expression that identifies its argument t. It is exactly equivalent to a static_cast to an rvalue reference type.  <a href="#a4165fb01e5de4a84bfd7367b5133cb3d">More...</a><br /></td></tr>
<tr class="separator:a4165fb01e5de4a84bfd7367b5133cb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b9621f8af141d0572885428d2880d9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a40b9621f8af141d0572885428d2880d9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a40b9621f8af141d0572885428d2880d9">forward</a> (<a class="el" href="namespaceetl.html#a26ceb8de4fe37ef6a14f78dd10d95bb6">etl::remove_reference_t</a>&lt; T &gt; &amp;param) noexcept -&gt; T &amp;&amp;</td></tr>
<tr class="separator:a40b9621f8af141d0572885428d2880d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb1fda04868d6ffa0343a463beba0e7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aecb1fda04868d6ffa0343a463beba0e7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aecb1fda04868d6ffa0343a463beba0e7">forward</a> (<a class="el" href="namespaceetl.html#a26ceb8de4fe37ef6a14f78dd10d95bb6">etl::remove_reference_t</a>&lt; T &gt; &amp;&amp;param) noexcept -&gt; T &amp;&amp;</td></tr>
<tr class="separator:aecb1fda04868d6ffa0343a463beba0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d24fcc85fa49fd49cdb1c2a808c4723"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1d24fcc85fa49fd49cdb1c2a808c4723"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1add__rvalue__reference.html">etl::add_rvalue_reference</a>&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1d24fcc85fa49fd49cdb1c2a808c4723">declval</a> () noexcept</td></tr>
<tr class="separator:a1d24fcc85fa49fd49cdb1c2a808c4723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad763c7f65a817a0ba3f58cf0d5672d1b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad763c7f65a817a0ba3f58cf0d5672d1b">is_language_standard</a> (<a class="el" href="namespaceetl.html#a3d70da9977ec456339973b30e372fcbd">language_standard</a> ls) -&gt; bool</td></tr>
<tr class="memdesc:ad763c7f65a817a0ba3f58cf0d5672d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the given standard and the currently configurated in the compiler match.  <a href="#ad763c7f65a817a0ba3f58cf0d5672d1b">More...</a><br /></td></tr>
<tr class="separator:ad763c7f65a817a0ba3f58cf0d5672d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8a84a5c6ba35f67fbc2ca6092eedde"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abe8a84a5c6ba35f67fbc2ca6092eedde">is_greater_language_standard</a> (<a class="el" href="namespaceetl.html#a3d70da9977ec456339973b30e372fcbd">language_standard</a> ls) -&gt; bool</td></tr>
<tr class="separator:abe8a84a5c6ba35f67fbc2ca6092eedde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1849ec064e37fdc587449c92492d25"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ada1849ec064e37fdc587449c92492d25"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ada1849ec064e37fdc587449c92492d25">ignore_unused</a> (Types &amp;&amp;...) -&gt; void</td></tr>
<tr class="separator:ada1849ec064e37fdc587449c92492d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3f74da2365a9a6f68d472686fd0f1666"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a3f74da2365a9a6f68d472686fd0f1666"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3f74da2365a9a6f68d472686fd0f1666">is_same_v</a> = <a class="el" href="structetl_1_1is__same.html">is_same</a>&lt;T, U&gt;::value</td></tr>
<tr class="separator:a3f74da2365a9a6f68d472686fd0f1666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149f8ba4063995f2c8ed7248d93a4d9e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a149f8ba4063995f2c8ed7248d93a4d9e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a149f8ba4063995f2c8ed7248d93a4d9e">is_void_v</a> = <a class="el" href="structetl_1_1is__void.html">is_void</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a149f8ba4063995f2c8ed7248d93a4d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef2a50a29c8803d461abedd7437effd"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0ef2a50a29c8803d461abedd7437effd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">is_integral_v</a> = <a class="el" href="structetl_1_1is__integral.html">is_integral</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a0ef2a50a29c8803d461abedd7437effd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf273d19443134cffcd66310d027ae4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5cf273d19443134cffcd66310d027ae4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5cf273d19443134cffcd66310d027ae4">is_floating_point_v</a> = <a class="el" href="structetl_1_1is__floating__point.html">is_floating_point</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a5cf273d19443134cffcd66310d027ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016c8419365e8e3697a56040d335bca4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a016c8419365e8e3697a56040d335bca4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a016c8419365e8e3697a56040d335bca4">is_null_pointer_v</a> = <a class="el" href="structetl_1_1is__null__pointer.html">is_null_pointer</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a016c8419365e8e3697a56040d335bca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa46050181985a6156a6c800c86a7d8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:afaa46050181985a6156a6c800c86a7d8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afaa46050181985a6156a6c800c86a7d8">is_array_v</a> = <a class="el" href="structetl_1_1is__array.html">is_array</a>&lt;T&gt;::value</td></tr>
<tr class="separator:afaa46050181985a6156a6c800c86a7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00eca7d51c4d2c1021402ee9a70f03c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac00eca7d51c4d2c1021402ee9a70f03c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac00eca7d51c4d2c1021402ee9a70f03c">is_pointer_v</a> = <a class="el" href="structetl_1_1is__pointer.html">is_pointer</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ac00eca7d51c4d2c1021402ee9a70f03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d441fab48eb459b77f6f5829f7fc75"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af8d441fab48eb459b77f6f5829f7fc75"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af8d441fab48eb459b77f6f5829f7fc75">is_class_v</a> = <a class="el" href="structetl_1_1is__class.html">is_class</a>&lt;T&gt;::value</td></tr>
<tr class="separator:af8d441fab48eb459b77f6f5829f7fc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4784b73e6d758a37358b62211a308ef"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa4784b73e6d758a37358b62211a308ef"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa4784b73e6d758a37358b62211a308ef">is_enum_v</a> = <a class="el" href="structetl_1_1is__enum.html">is_enum</a>&lt;T&gt;::value</td></tr>
<tr class="separator:aa4784b73e6d758a37358b62211a308ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d4c31d288adf2cb4c5d7fd14c32f00"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a51d4c31d288adf2cb4c5d7fd14c32f00"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a51d4c31d288adf2cb4c5d7fd14c32f00">is_union_v</a> = <a class="el" href="structetl_1_1is__union.html">is_union</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a51d4c31d288adf2cb4c5d7fd14c32f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105e2a5ac8fc634dcc71675e27e3f95e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a105e2a5ac8fc634dcc71675e27e3f95e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a105e2a5ac8fc634dcc71675e27e3f95e">is_arithmetic_v</a> = <a class="el" href="structetl_1_1is__arithmetic.html">is_arithmetic</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a105e2a5ac8fc634dcc71675e27e3f95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab616d6855ca5fc60968a153587b2b4"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:a1ab616d6855ca5fc60968a153587b2b4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1ab616d6855ca5fc60968a153587b2b4">is_constructible_v</a> = <a class="el" href="namespaceetl.html#a55bc1fa71ef93a7cd65389359e61683c">is_constructible</a>&lt;T, Args...&gt;::value</td></tr>
<tr class="separator:a1ab616d6855ca5fc60968a153587b2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbd05dc09b68b19c63d7b4fbf6f1108"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3bbd05dc09b68b19c63d7b4fbf6f1108"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3bbd05dc09b68b19c63d7b4fbf6f1108">is_unsigned_v</a> = <a class="el" href="structetl_1_1is__unsigned.html">is_unsigned</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a3bbd05dc09b68b19c63d7b4fbf6f1108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56baa007c444a18e18b603a55d9957bf"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a56baa007c444a18e18b603a55d9957bf"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">etl::size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a56baa007c444a18e18b603a55d9957bf">rank_v</a> = <a class="el" href="structetl_1_1rank.html">rank</a>&lt;Type&gt;::value</td></tr>
<tr class="separator:a56baa007c444a18e18b603a55d9957bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace for the etl library. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a662329de2bc2a83d5e45d1ccad797f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a662329de2bc2a83d5e45d1ccad797f17">&#9670;&nbsp;</a></span>add_lvalue_reference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a662329de2bc2a83d5e45d1ccad797f17">etl::add_lvalue_reference_t</a> = typedef typename <a class="el" href="structetl_1_1add__lvalue__reference.html">add_lvalue_reference</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a17c37a443b0cb66dc9b3c4374967b68f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c37a443b0cb66dc9b3c4374967b68f">&#9670;&nbsp;</a></span>add_rvalue_reference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a17c37a443b0cb66dc9b3c4374967b68f">etl::add_rvalue_reference_t</a> = typedef typename <a class="el" href="structetl_1_1add__rvalue__reference.html">add_rvalue_reference</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abf333951ccdff3b01dc321ac566bfecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf333951ccdff3b01dc321ac566bfecd">&#9670;&nbsp;</a></span>atto</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#abf333951ccdff3b01dc321ac566bfecd">etl::atto</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1000000000000000000&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a95d8c20c69482c794a0cfb9e4428ca8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d8c20c69482c794a0cfb9e4428ca8d">&#9670;&nbsp;</a></span>centi</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a95d8c20c69482c794a0cfb9e4428ca8d">etl::centi</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 100&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa508ba172c61957cf6c18357210f08f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa508ba172c61957cf6c18357210f08f6">&#9670;&nbsp;</a></span>conditional_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool B, class T , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#aa508ba172c61957cf6c18357210f08f6">etl::conditional_t</a> = typedef typename <a class="el" href="structetl_1_1conditional.html">conditional</a>&lt;B, T, F&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acae5b099e4ead54343e6304a6371985b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae5b099e4ead54343e6304a6371985b">&#9670;&nbsp;</a></span>deca</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#acae5b099e4ead54343e6304a6371985b">etl::deca</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;10, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a59f2e2c10ab4b06ed261d1e4a8358895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f2e2c10ab4b06ed261d1e4a8358895">&#9670;&nbsp;</a></span>deci</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a59f2e2c10ab4b06ed261d1e4a8358895">etl::deci</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 10&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a2df4ab89284c8c5866afea3100f290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a2df4ab89284c8c5866afea3100f290">&#9670;&nbsp;</a></span>enable_if_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool B, class T  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a> = typedef typename <a class="el" href="structetl_1_1enable__if.html">enable_if</a>&lt;B, T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f1a1ee1ab1b90d8dcf30d783f938ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f1a1ee1ab1b90d8dcf30d783f938ada">&#9670;&nbsp;</a></span>exa</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a5f1a1ee1ab1b90d8dcf30d783f938ada">etl::exa</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1000000000000000000, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0917d3f5e85877c283c4f04e327fd973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0917d3f5e85877c283c4f04e327fd973">&#9670;&nbsp;</a></span>false_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a0917d3f5e85877c283c4f04e327fd973">etl::false_type</a> = typedef <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt;bool, false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24c3ad429659821374780e0448855ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c3ad429659821374780e0448855ef8">&#9670;&nbsp;</a></span>femto</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a24c3ad429659821374780e0448855ef8">etl::femto</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1000000000000000&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b0c06d80bc66be0b8807cee66b576f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b0c06d80bc66be0b8807cee66b576f0">&#9670;&nbsp;</a></span>giga</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a1b0c06d80bc66be0b8807cee66b576f0">etl::giga</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1000000000, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aba04e5fa0d29bc9f6a9f3fa4f9ff3dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba04e5fa0d29bc9f6a9f3fa4f9ff3dbb">&#9670;&nbsp;</a></span>hecto</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#aba04e5fa0d29bc9f6a9f3fa4f9ff3dbb">etl::hecto</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;100, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ffe3c07a4dbbe98792f1936145c6876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ffe3c07a4dbbe98792f1936145c6876">&#9670;&nbsp;</a></span>int16_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a3ffe3c07a4dbbe98792f1936145c6876">etl::int16_t</a> = typedef <a class="el" href="namespaceetl.html#a3ffe3c07a4dbbe98792f1936145c6876">int16_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae779a40ac9323d2b0729f8bb95cf0fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae779a40ac9323d2b0729f8bb95cf0fd1">&#9670;&nbsp;</a></span>int32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#ae779a40ac9323d2b0729f8bb95cf0fd1">etl::int32_t</a> = typedef <a class="el" href="namespaceetl.html#ae779a40ac9323d2b0729f8bb95cf0fd1">int32_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adc4b499f2d2820b8af24be768343759b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc4b499f2d2820b8af24be768343759b">&#9670;&nbsp;</a></span>int64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#adc4b499f2d2820b8af24be768343759b">etl::int64_t</a> = typedef <a class="el" href="namespaceetl.html#adc4b499f2d2820b8af24be768343759b">int64_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afd99b481983335f785f7713b9bb4f436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd99b481983335f785f7713b9bb4f436">&#9670;&nbsp;</a></span>int8_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#afd99b481983335f785f7713b9bb4f436">etl::int8_t</a> = typedef <a class="el" href="namespaceetl.html#afd99b481983335f785f7713b9bb4f436">int8_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a178a2082210268baa21de6920cf2de96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178a2082210268baa21de6920cf2de96">&#9670;&nbsp;</a></span>intmax_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a178a2082210268baa21de6920cf2de96">etl::intmax_t</a> = typedef <a class="el" href="namespaceetl.html#a178a2082210268baa21de6920cf2de96">intmax_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a55bc1fa71ef93a7cd65389359e61683c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55bc1fa71ef93a7cd65389359e61683c">&#9670;&nbsp;</a></span>is_constructible</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a55bc1fa71ef93a7cd65389359e61683c">etl::is_constructible</a> = typedef <a class="el" href="structetl_1_1detail_1_1is__constructible__helper.html">detail::is_constructible_helper</a>&lt;<a class="el" href="namespaceetl.html#a8f76cc2621d7373b79e2fc034f160ee0">void_t</a>&lt;&gt;, T, Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a28e306410036af95bf5ea4fc02bed266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28e306410036af95bf5ea4fc02bed266">&#9670;&nbsp;</a></span>kilo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a28e306410036af95bf5ea4fc02bed266">etl::kilo</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1000, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acb2df53f4e399975501cf8300d451814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb2df53f4e399975501cf8300d451814">&#9670;&nbsp;</a></span>make_unsigned_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#acb2df53f4e399975501cf8300d451814">etl::make_unsigned_t</a> = typedef typename <a class="el" href="structetl_1_1make__unsigned.html">make_unsigned</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a918391ebf4a95eeb6fa0ad99c936252d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a918391ebf4a95eeb6fa0ad99c936252d">&#9670;&nbsp;</a></span>mega</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a918391ebf4a95eeb6fa0ad99c936252d">etl::mega</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1000000, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a79c9c1103e0bf6709642f55f9a31cb8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c9c1103e0bf6709642f55f9a31cb8e">&#9670;&nbsp;</a></span>micro</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a79c9c1103e0bf6709642f55f9a31cb8e">etl::micro</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1000000&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a92d262bf043c1ef824a60d171019e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a92d262bf043c1ef824a60d171019e8">&#9670;&nbsp;</a></span>milli</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a8a92d262bf043c1ef824a60d171019e8">etl::milli</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1000&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a49eea6db84c720b602fbe4ec3ad44c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49eea6db84c720b602fbe4ec3ad44c79">&#9670;&nbsp;</a></span>nano</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a49eea6db84c720b602fbe4ec3ad44c79">etl::nano</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1000000000&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adf4272f3f16bf2234ac8248db615f133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf4272f3f16bf2234ac8248db615f133">&#9670;&nbsp;</a></span>nullptr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#adf4272f3f16bf2234ac8248db615f133">etl::nullptr_t</a> = typedef decltype(nullptr)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa37756654b5a747b646eb948d539193c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa37756654b5a747b646eb948d539193c">&#9670;&nbsp;</a></span>peta</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#aa37756654b5a747b646eb948d539193c">etl::peta</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1000000000000000, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acf951c7004991770fcef76d2959007b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf951c7004991770fcef76d2959007b0">&#9670;&nbsp;</a></span>pico</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#acf951c7004991770fcef76d2959007b0">etl::pico</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1000000000000&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a56e0abf50b318376b511f461e8baca33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56e0abf50b318376b511f461e8baca33">&#9670;&nbsp;</a></span>ptrdiff_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a56e0abf50b318376b511f461e8baca33">etl::ptrdiff_t</a> = typedef <a class="el" href="namespaceetl.html#a56e0abf50b318376b511f461e8baca33">ptrdiff_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a515e08f8ce11f32a154acd83b2fe6b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515e08f8ce11f32a154acd83b2fe6b00">&#9670;&nbsp;</a></span>ratio_add</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R1 , class R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a515e08f8ce11f32a154acd83b2fe6b00">etl::ratio_add</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;R1::num * R2::den + R2::num * R1::den, R1::den * R2::den&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The alias template <a class="el" href="namespaceetl.html#a515e08f8ce11f32a154acd83b2fe6b00" title="The alias template etl::ratio_add denotes the result of adding two exact rational fractions represent...">etl::ratio_add</a> denotes the result of adding two exact rational fractions represented by the <a class="el" href="structetl_1_1ratio.html" title="The class template provides compile-time rational arithmetic support. Each instantiation of this temp...">etl::ratio</a> specializations R1 and R2. The result is a <a class="el" href="structetl_1_1ratio.html" title="The class template provides compile-time rational arithmetic support. Each instantiation of this temp...">etl::ratio</a> specialization etl::ratio&lt;U, V&gt;, such that given Num == R1::num * R2::den + R2::num * R1::den and Denom == R1::den. </p>
<ul>
<li>R2::den (computed without arithmetic overflow), U is <a class="el" href="structetl_1_1ratio.html" title="The class template provides compile-time rational arithmetic support. Each instantiation of this temp...">etl::ratio</a>&lt;Num, Denom&gt;::num and V is <a class="el" href="structetl_1_1ratio.html#acb49b27bde07d5c4878c5347454a0044">etl::ratio&lt;Num, Denom&gt;::den</a>. </li>
</ul>

</div>
</div>
<a id="a234acc6c1438740afe4f7766f1208784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234acc6c1438740afe4f7766f1208784">&#9670;&nbsp;</a></span>ratio_subtract</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R1 , class R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a234acc6c1438740afe4f7766f1208784">etl::ratio_subtract</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;R1::num * R2::den - R2::num * R1::den, R1::den * R2::den&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The alias template <a class="el" href="namespaceetl.html#a234acc6c1438740afe4f7766f1208784" title="The alias template etl::ratio_subtract denotes the result of subtracting two exact rational fractions...">etl::ratio_subtract</a> denotes the result of subtracting two exact rational fractions represented by the <a class="el" href="structetl_1_1ratio.html" title="The class template provides compile-time rational arithmetic support. Each instantiation of this temp...">etl::ratio</a> specializations R1 and R2. The result is a <a class="el" href="structetl_1_1ratio.html" title="The class template provides compile-time rational arithmetic support. Each instantiation of this temp...">etl::ratio</a> specialization etl::ratio&lt;U, V&gt;, such that given Num == R1::num * R2::den - R2::num * R1::den and Denom == R1::den * R2::den (computed without arithmetic overflow), U is <a class="el" href="structetl_1_1ratio.html#a15ad9bea294aeeba2f02f33ec0283065">etl::ratio&lt;Num, Denom&gt;::num</a> and V is <a class="el" href="structetl_1_1ratio.html" title="The class template provides compile-time rational arithmetic support. Each instantiation of this temp...">etl::ratio</a>&lt;Num, Denom&gt;::den. </p>

</div>
</div>
<a id="a87e058aba499e52cc4ed554dd7d65332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e058aba499e52cc4ed554dd7d65332">&#9670;&nbsp;</a></span>remove_const_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a87e058aba499e52cc4ed554dd7d65332">etl::remove_const_t</a> = typedef typename <a class="el" href="structetl_1_1remove__const.html">remove_const</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a70fb46b3c4c98f5f23b76cb25f343373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70fb46b3c4c98f5f23b76cb25f343373">&#9670;&nbsp;</a></span>remove_cv_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a70fb46b3c4c98f5f23b76cb25f343373">etl::remove_cv_t</a> = typedef typename <a class="el" href="structetl_1_1remove__cv.html">remove_cv</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a26ceb8de4fe37ef6a14f78dd10d95bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ceb8de4fe37ef6a14f78dd10d95bb6">&#9670;&nbsp;</a></span>remove_reference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a26ceb8de4fe37ef6a14f78dd10d95bb6">etl::remove_reference_t</a> = typedef typename <a class="el" href="structetl_1_1remove__reference.html">remove_reference</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af4593c7817c464ffa0d88cc07eb35e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4593c7817c464ffa0d88cc07eb35e83">&#9670;&nbsp;</a></span>remove_volatile_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#af4593c7817c464ffa0d88cc07eb35e83">etl::remove_volatile_t</a> = typedef typename <a class="el" href="structetl_1_1remove__volatile.html">remove_volatile</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac853a6316b146d25fdfbb5865821cedd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac853a6316b146d25fdfbb5865821cedd">&#9670;&nbsp;</a></span>size_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">etl::size_t</a> = typedef <a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">size_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9bffa043c410459eda373247f384b9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bffa043c410459eda373247f384b9e2">&#9670;&nbsp;</a></span>small_string</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a9bffa043c410459eda373247f384b9e2">etl::small_string</a> = typedef <a class="el" href="classetl_1_1basic__string.html">basic_string</a>&lt;char, 32&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af2769dde06d41131748597077535e2cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2769dde06d41131748597077535e2cc">&#9670;&nbsp;</a></span>string</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t Capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#af2769dde06d41131748597077535e2cc">etl::string</a> = typedef <a class="el" href="classetl_1_1basic__string.html">basic_string</a>&lt;char, Capacity&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c4d429035abc6729b30e3406a1703a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c4d429035abc6729b30e3406a1703a1">&#9670;&nbsp;</a></span>tera</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a2c4d429035abc6729b30e3406a1703a1">etl::tera</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1000000000000, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5b54646ef5937839803117924c49d01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5b54646ef5937839803117924c49d01">&#9670;&nbsp;</a></span>true_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#ac5b54646ef5937839803117924c49d01">etl::true_type</a> = typedef <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt;bool, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af61de6f15f82704d69a80d859a757298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61de6f15f82704d69a80d859a757298">&#9670;&nbsp;</a></span>uint16_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#af61de6f15f82704d69a80d859a757298">etl::uint16_t</a> = typedef <a class="el" href="namespaceetl.html#af61de6f15f82704d69a80d859a757298">uint16_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8e6df1710afc95336b7bee2714144b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e6df1710afc95336b7bee2714144b2">&#9670;&nbsp;</a></span>uint32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#ac8e6df1710afc95336b7bee2714144b2">etl::uint32_t</a> = typedef <a class="el" href="namespaceetl.html#ac8e6df1710afc95336b7bee2714144b2">uint32_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc782f054552345b4cd2428dbc92a4ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc782f054552345b4cd2428dbc92a4ca">&#9670;&nbsp;</a></span>uint64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#afc782f054552345b4cd2428dbc92a4ca">etl::uint64_t</a> = typedef <a class="el" href="namespaceetl.html#afc782f054552345b4cd2428dbc92a4ca">uint64_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a001f884b28f990ecdc3543a19440befb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a001f884b28f990ecdc3543a19440befb">&#9670;&nbsp;</a></span>uint8_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a001f884b28f990ecdc3543a19440befb">etl::uint8_t</a> = typedef <a class="el" href="namespaceetl.html#a001f884b28f990ecdc3543a19440befb">uint8_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a91f7969d130419941da3aeccefc32e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f7969d130419941da3aeccefc32e6a">&#9670;&nbsp;</a></span>uintmax_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a91f7969d130419941da3aeccefc32e6a">etl::uintmax_t</a> = typedef <a class="el" href="namespaceetl.html#a91f7969d130419941da3aeccefc32e6a">uintmax_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f76cc2621d7373b79e2fc034f160ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f76cc2621d7373b79e2fc034f160ee0">&#9670;&nbsp;</a></span>void_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a8f76cc2621d7373b79e2fc034f160ee0">etl::void_t</a> = typedef void</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a3fe360a11ae9b0c5886f80ce2ff28a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe360a11ae9b0c5886f80ce2ff28a9d">&#9670;&nbsp;</a></span>byte</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> : <a class="el" href="namespaceetl.html#a001f884b28f990ecdc3543a19440befb">uint8_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aadba129a7dc760f449b09b7fafeb63a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadba129a7dc760f449b09b7fafeb63a8">&#9670;&nbsp;</a></span>endian</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceetl.html#aadba129a7dc760f449b09b7fafeb63a8">etl::endian</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates the endianness of all scalar types. </p>
<p>If all scalar types are little-endian, <a class="el" href="namespaceetl.html#aadba129a7dc760f449b09b7fafeb63a8a8e5f3adee38c8fccc13c1f3be0143796">etl::endian::native</a> equals <a class="el" href="namespaceetl.html#aadba129a7dc760f449b09b7fafeb63a8aaae6635e044ac56046b2893a529b5114">etl::endian::little</a>. If all scalar types are big-endian, <a class="el" href="namespaceetl.html#aadba129a7dc760f449b09b7fafeb63a8a8e5f3adee38c8fccc13c1f3be0143796">etl::endian::native</a> equals <a class="el" href="namespaceetl.html#aadba129a7dc760f449b09b7fafeb63a8ad861877da56b8b4ceb35c8cbfdf65bb4">etl::endian::big</a> </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aadba129a7dc760f449b09b7fafeb63a8aaae6635e044ac56046b2893a529b5114"></a>little&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aadba129a7dc760f449b09b7fafeb63a8ad861877da56b8b4ceb35c8cbfdf65bb4"></a>big&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aadba129a7dc760f449b09b7fafeb63a8a8e5f3adee38c8fccc13c1f3be0143796"></a>native&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ad4892bd9af0bd3ad759fb95ab241247c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4892bd9af0bd3ad759fb95ab241247c">&#9670;&nbsp;</a></span>float_denorm_style</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceetl.html#ad4892bd9af0bd3ad759fb95ab241247c">etl::float_denorm_style</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad4892bd9af0bd3ad759fb95ab241247cadc095ee49d9e6884cd67bc20a4c73287"></a>denorm_indeterminate&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad4892bd9af0bd3ad759fb95ab241247caf254439f29ec6166a1a6fb7b09efd141"></a>denorm_absent&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad4892bd9af0bd3ad759fb95ab241247ca5a085126714d6734d58691edaa278aa5"></a>denorm_present&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a0cdec522db16c755ade7c7222bf8af92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cdec522db16c755ade7c7222bf8af92">&#9670;&nbsp;</a></span>float_round_style</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceetl.html#a0cdec522db16c755ade7c7222bf8af92">etl::float_round_style</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0cdec522db16c755ade7c7222bf8af92afd0fa1de009f9a47f51a0ec9c23aa10b"></a>round_indeterminate&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cdec522db16c755ade7c7222bf8af92a00004115cf199c1cd29d07f78679a63d"></a>round_toward_zero&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cdec522db16c755ade7c7222bf8af92a1fc678348a02cf4262fb59153d5b73c3"></a>round_to_nearest&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cdec522db16c755ade7c7222bf8af92a274b79e7a1a164b8b9eea17dda4751c0"></a>round_toward_infinity&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cdec522db16c755ade7c7222bf8af92ac6babddc09b7dbf6e3daf12455e3417f"></a>round_toward_neg_infinity&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a3d70da9977ec456339973b30e372fcbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d70da9977ec456339973b30e372fcbd">&#9670;&nbsp;</a></span>language_standard</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceetl.html#a3d70da9977ec456339973b30e372fcbd">etl::language_standard</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration for the currently selected C++ standard version. </p>
<p>Unlike the official macro __cplusplus, these values only include the published year. This is to make the actual values smaller and therfore fit on smaller word sized chips. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3d70da9977ec456339973b30e372fcbda807ac7fd9764fb3e810d9f1048cd63ca"></a>cpp_98&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3d70da9977ec456339973b30e372fcbdabbe07f980d9fa36187463846b2811aed"></a>cpp_11&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3d70da9977ec456339973b30e372fcbdaee3f3f8ff98b05c178cea91bf69cde50"></a>cpp_14&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3d70da9977ec456339973b30e372fcbda6289bbfa378818f7066ccad5847da5a2"></a>cpp_17&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3d70da9977ec456339973b30e372fcbda4c7aabdc3eb0d845c62edfb822b0fe5a"></a>cpp_20&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a594a7b7fb202c9a1b6d82115e7a172e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a594a7b7fb202c9a1b6d82115e7a172e3">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::abs </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td> -&gt; Type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the absolute value. </p>

</div>
</div>
<a id="afe443a26a34b79fc921c4583df576333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe443a26a34b79fc921c4583df576333">&#9670;&nbsp;</a></span>accumulate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt , class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::accumulate </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sum of the given value init and the elements in the range [first, last). Uses operator+ to sum up the elements. </p>

</div>
</div>
<a id="a9413959b7ee39d393e7c35ad2cd78294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9413959b7ee39d393e7c35ad2cd78294">&#9670;&nbsp;</a></span>accumulate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt , class Type , class BinaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::accumulate </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOperation&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sum of the given value init and the elements in the range [first, last). Uses the BinaryOperation to sum up the elements. </p>

</div>
</div>
<a id="ad9b7eed2eaa0b58da478a2d559164bb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9b7eed2eaa0b58da478a2d559164bb4">&#9670;&nbsp;</a></span>all_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt , class UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::all_of </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if unary predicate p returns true for all elements in the range [first, last). </p>

</div>
</div>
<a id="a74cda9bdcb48dfe219176e8fbe4f3aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74cda9bdcb48dfe219176e8fbe4f3aa6">&#9670;&nbsp;</a></span>any_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt , class UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::any_of </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if unary predicate p returns true for at least one element in the range [first, last). </p>

</div>
</div>
<a id="ae5a13233ebf471c62f35f40b21128884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5a13233ebf471c62f35f40b21128884">&#9670;&nbsp;</a></span>array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classetl_1_1array.html">etl::array</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U...&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classetl_1_1array.html">array</a>&lt; T, 1+sizeof...(U)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af90379160c94dc0396b5f32204c790bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af90379160c94dc0396b5f32204c790bf">&#9670;&nbsp;</a></span>clamp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::clamp </td>
          <td>(</td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>hi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Type const&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If v compares less than lo, returns lo; otherwise if hi compares less than v, returns hi; otherwise returns v. Uses operator&lt; to compare the values. </p>

</div>
</div>
<a id="abfa416a307b0bb33666d34845c42ba2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfa416a307b0bb33666d34845c42ba2b">&#9670;&nbsp;</a></span>clamp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::clamp </td>
          <td>(</td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Type const&amp;
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d24fcc85fa49fd49cdb1c2a808c4723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d24fcc85fa49fd49cdb1c2a808c4723">&#9670;&nbsp;</a></span>declval() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1add__rvalue__reference.html">etl::add_rvalue_reference</a>&lt;T&gt;::type etl::declval </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4147daa38c6c4c1e59540fa0fa27a292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4147daa38c6c4c1e59540fa0fa27a292">&#9670;&nbsp;</a></span>declval() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto etl::declval </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  typename <a class="el" href="structetl_1_1add__rvalue__reference.html">etl::add_rvalue_reference</a>&lt; T &gt;::type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af33857e090fba6747166a167e1018400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af33857e090fba6747166a167e1018400">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::find </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; InputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for an element equal to value. </p>

</div>
</div>
<a id="a6fa4355c6aa8d1f3fbd2019acfee332f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa4355c6aa8d1f3fbd2019acfee332f">&#9670;&nbsp;</a></span>find_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt , class UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::find_if </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; InputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for an element for which predicate p returns true. </p>

</div>
</div>
<a id="afc8040ddc904e657cfe6c640d775b47a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc8040ddc904e657cfe6c640d775b47a">&#9670;&nbsp;</a></span>find_if_not()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt , class UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::find_if_not </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; InputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for an element for which predicate q returns false. </p>

</div>
</div>
<a id="a013f931a99670b660a20f65b845013a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a013f931a99670b660a20f65b845013a3">&#9670;&nbsp;</a></span>for_each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt , class UnaryFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::for_each </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunction&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; UnaryFunction
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the given function object f to the result of dereferencing every iterator in the range [first, last] in order. </p>

</div>
</div>
<a id="ad648007806d54bdfc4e127ab1e1ca4a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad648007806d54bdfc4e127ab1e1ca4a3">&#9670;&nbsp;</a></span>for_each_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt , class Size , class UnaryFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::for_each_n </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Size&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunction&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; InputIt
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the given function object f to the result of dereferencing every iterator in the range [first, first+n] in order. </p>

</div>
</div>
<a id="a40b9621f8af141d0572885428d2880d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b9621f8af141d0572885428d2880d9">&#9670;&nbsp;</a></span>forward() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::forward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a26ceb8de4fe37ef6a14f78dd10d95bb6">etl::remove_reference_t</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td> -&gt; T&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aecb1fda04868d6ffa0343a463beba0e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb1fda04868d6ffa0343a463beba0e7">&#9670;&nbsp;</a></span>forward() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::forward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a26ceb8de4fe37ef6a14f78dd10d95bb6">etl::remove_reference_t</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td> -&gt; T&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0c15d45f1e3cd0c35fa9c638e90fb4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c15d45f1e3cd0c35fa9c638e90fb4b">&#9670;&nbsp;</a></span>gcd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename N &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::gcd </td>
          <td>(</td>
          <td class="paramtype">M&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the greatest common divisor of the integers m and n. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>Actual return type is etl::common_type. Needs to be implemented. </dd></dl>

</div>
</div>
<a id="a15f4fd4efe3204f43756b83be3ae1479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f4fd4efe3204f43756b83be3ae1479">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int index, typename First , typename... Rest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto etl::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; First, Rest... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="structetl_1_1detail_1_1get__impl.html">detail::get_impl</a>&lt;index, First, Rest...&gt;::value(&amp;t))
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ada1849ec064e37fdc587449c92492d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada1849ec064e37fdc587449c92492d25">&#9670;&nbsp;</a></span>ignore_unused()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto etl::ignore_unused </td>
          <td>(</td>
          <td class="paramtype">Types &amp;&amp;&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td> -&gt; void
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abe8a84a5c6ba35f67fbc2ca6092eedde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe8a84a5c6ba35f67fbc2ca6092eedde">&#9670;&nbsp;</a></span>is_greater_language_standard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::is_greater_language_standard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3d70da9977ec456339973b30e372fcbd">language_standard</a>&#160;</td>
          <td class="paramname"><em>ls</em></td><td>)</td>
          <td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad763c7f65a817a0ba3f58cf0d5672d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad763c7f65a817a0ba3f58cf0d5672d1b">&#9670;&nbsp;</a></span>is_language_standard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::is_language_standard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3d70da9977ec456339973b30e372fcbd">language_standard</a>&#160;</td>
          <td class="paramname"><em>ls</em></td><td>)</td>
          <td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true, if the given standard and the currently configurated in the compiler match. </p>

</div>
</div>
<a id="a7fdd0cf88f36f44f8fe8ec8327cfac74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fdd0cf88f36f44f8fe8ec8327cfac74">&#9670;&nbsp;</a></span>max() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::max </td>
          <td>(</td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Type const&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the greater of a and b. </p>

</div>
</div>
<a id="a220fbd23aca7dbc728c200471ed114c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220fbd23aca7dbc728c200471ed114c8">&#9670;&nbsp;</a></span>max() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::max </td>
          <td>(</td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Type const&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the greater of a and b, using a compare function. </p>

</div>
</div>
<a id="aa58c8973da727c50c3d0d28b83fdf304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa58c8973da727c50c3d0d28b83fdf304">&#9670;&nbsp;</a></span>max_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::max_element </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIterator
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the greatest element in the range [first, last). Elements are compared using operator&lt;. </p>

</div>
</div>
<a id="ab573cae5dd21a6ab0e00ee00da8855e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab573cae5dd21a6ab0e00ee00da8855e0">&#9670;&nbsp;</a></span>max_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::max_element </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIterator
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the greatest element in the range [first, last). Elements are compared using the given binary comparison function comp. </p>

</div>
</div>
<a id="a99a28bb04c335112b2c13d676c422e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99a28bb04c335112b2c13d676c422e66">&#9670;&nbsp;</a></span>memcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::memcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">etl::size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void*
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the first n bytes pointed to by src to the buffer pointed to by dest. Source and destination may not overlap. If source and destination might overlap, <a class="el" href="namespaceetl.html#a4604077670e2126de4d05e9d4dab2df9" title="Copy the first n bytes pointed to by src to the buffer pointed to by dest. Source and destination may...">memmove()</a> must be used instead. </p>

</div>
</div>
<a id="a4604077670e2126de4d05e9d4dab2df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4604077670e2126de4d05e9d4dab2df9">&#9670;&nbsp;</a></span>memmove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::memmove </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">etl::size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void*
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the first n bytes pointed to by src to the buffer pointed to by dest. Source and destination may overlap. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Check original implementation. They use __np_anyptrlt which is not portable. <a href="https://clc-wiki.net/wiki/C_standard_library:string.h:memmove">https://clc-wiki.net/wiki/C_standard_library:string.h:memmove</a> </dd></dl>

</div>
</div>
<a id="a055dc327ea35a394f661ca98bf2b08ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a055dc327ea35a394f661ca98bf2b08ad">&#9670;&nbsp;</a></span>memset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::memset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">etl::size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void*
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the value of c (converted to an unsigned char) into each of the rst n characters of the object pointed to by s. </p>

</div>
</div>
<a id="a9900f32867800d2a9ffa2c660090cc83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9900f32867800d2a9ffa2c660090cc83">&#9670;&nbsp;</a></span>midpoint() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::midpoint </td>
          <td>(</td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt;<a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt;Integer&gt;, Integer&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns half the sum of a + b. If the sum is odd, the result is rounded towards a.  T is arithmentic type other than bool. </p>

</div>
</div>
<a id="acd6eb417ecc3a7b1c7e71baab1c2c522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd6eb417ecc3a7b1c7e71baab1c2c522">&#9670;&nbsp;</a></span>midpoint() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Float &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::midpoint </td>
          <td>(</td>
          <td class="paramtype">Float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt;<a class="el" href="namespaceetl.html#a5cf273d19443134cffcd66310d027ae4">etl::is_floating_point_v</a>&lt;Float&gt;, Float&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad2f4c423421fddd2a2f941d805c05300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f4c423421fddd2a2f941d805c05300">&#9670;&nbsp;</a></span>midpoint() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Pointer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::midpoint </td>
          <td>(</td>
          <td class="paramtype">Pointer&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pointer&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt;<a class="el" href="namespaceetl.html#ac00eca7d51c4d2c1021402ee9a70f03c">is_pointer_v</a>&lt;Pointer&gt;, Pointer&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adae1500815312b248e453896d5439b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adae1500815312b248e453896d5439b63">&#9670;&nbsp;</a></span>min() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::min </td>
          <td>(</td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Type const&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smaller of a and b. </p>

</div>
</div>
<a id="a479c4a8315ae3ef2d1128858d723afc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479c4a8315ae3ef2d1128858d723afc2">&#9670;&nbsp;</a></span>min() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , class Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::min </td>
          <td>(</td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Type const&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smaller of a and b, using a compare function. </p>

</div>
</div>
<a id="a41f1e60aa2d0ca23d39bd975ed52e4b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f1e60aa2d0ca23d39bd975ed52e4b4">&#9670;&nbsp;</a></span>min_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::min_element </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIterator
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the smallest element in the range [first, last). Elements are compared using operator&lt;. </p>

</div>
</div>
<a id="ae206eeb82f5e460124ce4b40e951fa0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae206eeb82f5e460124ce4b40e951fa0d">&#9670;&nbsp;</a></span>min_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::min_element </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIterator
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the smallest element in the range [first, last). Elements are compared using the given binary comparison function comp. </p>

</div>
</div>
<a id="a4165fb01e5de4a84bfd7367b5133cb3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4165fb01e5de4a84bfd7367b5133cb3d">&#9670;&nbsp;</a></span>move()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::move </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; typename <a class="el" href="structetl_1_1remove__reference.html">etl::remove_reference</a>&lt;T&gt;::type&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespaceetl.html#a4165fb01e5de4a84bfd7367b5133cb3d" title="etl::move is used to indicate that an object t may be &quot;moved from&quot;, i.e. allowing the efficient trans...">etl::move</a> is used to indicate that an object t may be "moved from", i.e. allowing the efficient transfer of resources from t to another object. In particular, <a class="el" href="namespaceetl.html#a4165fb01e5de4a84bfd7367b5133cb3d" title="etl::move is used to indicate that an object t may be &quot;moved from&quot;, i.e. allowing the efficient trans...">etl::move</a> produces an xvalue expression that identifies its argument t. It is exactly equivalent to a static_cast to an rvalue reference type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>static_cast&lt;typename <a class="el" href="structetl_1_1remove__reference.html#a2485f631f25b8f91e902b3d127fd5d2a">etl::remove_reference&lt;T&gt;::type</a>&amp;&amp;&gt;(t) </dd></dl>

</div>
</div>
<a id="add22a48a49c792039e0d0ec1eef5528b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add22a48a49c792039e0d0ec1eef5528b">&#9670;&nbsp;</a></span>none_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt , class UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::none_of </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if unary predicate p returns true for no elements in the range [first, last). </p>

</div>
</div>
<a id="a300d68a0b017d8b6f41d000a8800cd77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a300d68a0b017d8b6f41d000a8800cd77">&#9670;&nbsp;</a></span>operator &()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: return <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>(static_cast&lt;unsigned int&gt;(l) &amp; static_cast&lt;unsigned int&gt;(r));. </p>

</div>
</div>
<a id="a30243ddf0699dede912521c57cb92a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30243ddf0699dede912521c57cb92a25">&#9670;&nbsp;</a></span>operator &=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: return l = l &amp; r;. </p>

</div>
</div>
<a id="a0480e65e737703d71651dbf0ec77f6be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0480e65e737703d71651dbf0ec77f6be">&#9670;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt;<a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt;Integer&gt;, <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: return <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>(static_cast&lt;unsigned int&gt;(b) &lt;&lt; shift); This overload only participates in overload resolution if <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v&lt;Integer&gt;</a> is true. </p>

</div>
</div>
<a id="a4d724ccacf75835ddc7e208bf977df9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d724ccacf75835ddc7e208bf977df9e">&#9670;&nbsp;</a></span>operator<<=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt;&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt;<a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt;Integer&gt;, <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&amp;&gt;

</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: return b = b &lt;&lt; shift; This overload only participates in overload resolution if <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v&lt;Integer&gt;</a> is true. </p>

</div>
</div>
<a id="ac45fcae26cfb190fcc8ea6ab10da01f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45fcae26cfb190fcc8ea6ab10da01f0">&#9670;&nbsp;</a></span>operator>>()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt;<a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt;Integer&gt;, <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: return <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>(static_cast&lt;unsigned int&gt;(b) &gt;&gt; shift); This overload only participates in overload resolution if <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v&lt;Integer&gt;</a> is true. </p>

</div>
</div>
<a id="a12556a00fd4d36c275c51643b2c6168a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12556a00fd4d36c275c51643b2c6168a">&#9670;&nbsp;</a></span>operator>>=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt;&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt;<a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt;Integer&gt;, <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&amp;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: return b = b &gt;&gt; shift; This overload only participates in overload resolution if <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v&lt;Integer&gt;</a> is true. </p>

</div>
</div>
<a id="a6ca2f44bc05dd8dbd6f9ea8beadef229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca2f44bc05dd8dbd6f9ea8beadef229">&#9670;&nbsp;</a></span>operator^()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator^ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: return <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>(static_cast&lt;unsigned int&gt;(l) ^ static_cast&lt;unsigned int&gt;(r));. </p>

</div>
</div>
<a id="a0145ea9af63899833b6bf5f9f18fb7c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0145ea9af63899833b6bf5f9f18fb7c1">&#9670;&nbsp;</a></span>operator^=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator^= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: return l = l ^ r;. </p>

</div>
</div>
<a id="a8fe220615749beb7a953b281e623e529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe220615749beb7a953b281e623e529">&#9670;&nbsp;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: return <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>(static_cast&lt;unsigned int&gt;(l) | static_cast&lt;unsigned int&gt;(r));. </p>

</div>
</div>
<a id="a73f53c7f64802ca7093607b55cb86bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f53c7f64802ca7093607b55cb86bc6">&#9670;&nbsp;</a></span>operator|=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator|= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: return l = l | r;. </p>

</div>
</div>
<a id="a6cb428553f8379a8f3920c202cd85993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb428553f8379a8f3920c202cd85993">&#9670;&nbsp;</a></span>operator~()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator~ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: return <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>(~static_cast&lt;unsigned int&gt;(b));. </p>

</div>
</div>
<a id="a0d02c4c388de0067ab15cb5febdebea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d02c4c388de0067ab15cb5febdebea7">&#9670;&nbsp;</a></span>popcount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::popcount </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td> -&gt; int
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of 1 bits in the value of x. </p>
<p>This overload only participates in overload resolution if T is an unsigned integer type (that is, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long, or an extended unsigned integer type).</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Limit (SFINAE) to unsigned types. Fix conversion warnings. </dd></dl>

</div>
</div>
<a id="add013e52c2672440c53a8d2c82d4c63a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add013e52c2672440c53a8d2c82d4c63a">&#9670;&nbsp;</a></span>strlen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::strlen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">etl::size_t</a>
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length of the C string str. </p>

</div>
</div>
<a id="aaa84e096751094f12fc96460addc2483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa84e096751094f12fc96460addc2483">&#9670;&nbsp;</a></span>to_integer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::to_integer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt;<a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt;Integer&gt;, Integer&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: return Integer(b); This overload only participates in overload resolution if <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v&lt;Integer&gt;</a> is true. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a105e2a5ac8fc634dcc71675e27e3f95e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105e2a5ac8fc634dcc71675e27e3f95e">&#9670;&nbsp;</a></span>is_arithmetic_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_arithmetic_v = <a class="el" href="structetl_1_1is__arithmetic.html">is_arithmetic</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afaa46050181985a6156a6c800c86a7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa46050181985a6156a6c800c86a7d8">&#9670;&nbsp;</a></span>is_array_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_array_v = <a class="el" href="structetl_1_1is__array.html">is_array</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af8d441fab48eb459b77f6f5829f7fc75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d441fab48eb459b77f6f5829f7fc75">&#9670;&nbsp;</a></span>is_class_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_class_v = <a class="el" href="structetl_1_1is__class.html">is_class</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ab616d6855ca5fc60968a153587b2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab616d6855ca5fc60968a153587b2b4">&#9670;&nbsp;</a></span>is_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_constructible_v = <a class="el" href="namespaceetl.html#a55bc1fa71ef93a7cd65389359e61683c">is_constructible</a>&lt;T, Args...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4784b73e6d758a37358b62211a308ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4784b73e6d758a37358b62211a308ef">&#9670;&nbsp;</a></span>is_enum_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_enum_v = <a class="el" href="structetl_1_1is__enum.html">is_enum</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5cf273d19443134cffcd66310d027ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf273d19443134cffcd66310d027ae4">&#9670;&nbsp;</a></span>is_floating_point_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_floating_point_v = <a class="el" href="structetl_1_1is__floating__point.html">is_floating_point</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ef2a50a29c8803d461abedd7437effd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ef2a50a29c8803d461abedd7437effd">&#9670;&nbsp;</a></span>is_integral_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_integral_v = <a class="el" href="structetl_1_1is__integral.html">is_integral</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a016c8419365e8e3697a56040d335bca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a016c8419365e8e3697a56040d335bca4">&#9670;&nbsp;</a></span>is_null_pointer_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_null_pointer_v = <a class="el" href="structetl_1_1is__null__pointer.html">is_null_pointer</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac00eca7d51c4d2c1021402ee9a70f03c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac00eca7d51c4d2c1021402ee9a70f03c">&#9670;&nbsp;</a></span>is_pointer_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_pointer_v = <a class="el" href="structetl_1_1is__pointer.html">is_pointer</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f74da2365a9a6f68d472686fd0f1666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f74da2365a9a6f68d472686fd0f1666">&#9670;&nbsp;</a></span>is_same_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_same_v = <a class="el" href="structetl_1_1is__same.html">is_same</a>&lt;T, U&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a51d4c31d288adf2cb4c5d7fd14c32f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d4c31d288adf2cb4c5d7fd14c32f00">&#9670;&nbsp;</a></span>is_union_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_union_v = <a class="el" href="structetl_1_1is__union.html">is_union</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3bbd05dc09b68b19c63d7b4fbf6f1108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bbd05dc09b68b19c63d7b4fbf6f1108">&#9670;&nbsp;</a></span>is_unsigned_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_unsigned_v = <a class="el" href="structetl_1_1is__unsigned.html">is_unsigned</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a149f8ba4063995f2c8ed7248d93a4d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a149f8ba4063995f2c8ed7248d93a4d9e">&#9670;&nbsp;</a></span>is_void_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_void_v = <a class="el" href="structetl_1_1is__void.html">is_void</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a56baa007c444a18e18b603a55d9957bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56baa007c444a18e18b603a55d9957bf">&#9670;&nbsp;</a></span>rank_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">etl::size_t</a> etl::rank_v = <a class="el" href="structetl_1_1rank.html">rank</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
