<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>taetl: etl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">taetl
   &#160;<span id="projectnumber">0.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">etl Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace for the etl library.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceetl_1_1chrono"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1chrono.html">chrono</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceetl_1_1dsp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1dsp.html">dsp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceetl_1_1experimental"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1experimental.html">experimental</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceetl_1_1hardware"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1hardware.html">hardware</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceetl_1_1literals"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1literals.html">literals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceetl_1_1net"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1net.html">net</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceetl_1_1numbers"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1numbers.html">numbers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceetl_1_1rtos"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1rtos.html">rtos</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__const.html">add_const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except it has a cv-qualifier added (unless T is a function, a reference, or already has this cv-qualifier). Adds const.  <a href="structetl_1_1add__const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__cv.html">add_cv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except it has a cv-qualifier added (unless T is a function, a reference, or already has this cv-qualifier). Adds both const and volatile.  <a href="structetl_1_1add__cv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__lvalue__reference.html">add_lvalue_reference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__pointer.html">add_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a reference type, then provides the member typedef type which is a pointer to the referred type. Otherwise, if T names an object type, a function type that is not cv- or ref-qualified, or a (possibly cv-qualified) void type, provides the member typedef type which is the type T*. Otherwise (if T is a cv- or ref-qualified function type), provides the member typedef type which is the type T. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1add__pointer.html" title="If T is a reference type, then provides the member typedef type which is a pointer to the referred ty...">add_pointer</a> is undefined.  <a href="structetl_1_1add__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__rvalue__reference.html">add_rvalue_reference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__volatile.html">add_volatile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except it has a cv-qualifier added (unless T is a function, a reference, or already has this cv-qualifier). Adds volatile.  <a href="structetl_1_1add__volatile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1adopt__lock__t.html">adopt_lock_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty class tag types used to specify locking strategy for <a class="el" href="classetl_1_1lock__guard.html" title="The class lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a ...">etl::lock_guard</a>, <a class="el" href="classetl_1_1scoped__lock.html" title="RAII based lock. ">etl::scoped_lock</a>, etl::unique_lock, and etl::shared_lock.  <a href="structetl_1_1adopt__lock__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1aligned__storage.html">aligned_storage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the nested type type, which is a trivial standard-layout type suitable for use as uninitialized storage for any object whose size is at most Len and whose alignment requirement is a divisor of Align.  <a href="structetl_1_1aligned__storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1array.html">array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1array.html" title="etl::array is a container that encapsulates fixed size arrays. ">etl::array</a> is a container that encapsulates fixed size arrays.  <a href="structetl_1_1array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1back__insert__iterator.html">back_insert_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classetl_1_1back__insert__iterator.html" title="etl::back_insert_iterator is a LegacyOutputIterator that appends to a container for which it was cons...">etl::back_insert_iterator</a> is a LegacyOutputIterator that appends to a container for which it was constructed. The container's push_back() member function is called whenever the iterator (whether dereferenced or not) is assigned to. Incrementing the <a class="el" href="classetl_1_1back__insert__iterator.html" title="etl::back_insert_iterator is a LegacyOutputIterator that appends to a container for which it was cons...">etl::back_insert_iterator</a> is a no-op.  <a href="classetl_1_1back__insert__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1basic__string.html">basic_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classetl_1_1basic__string.html" title="basic_string class with fixed size capacity. ">basic_string</a> class with fixed size capacity.  <a href="classetl_1_1basic__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1basic__string__view.html">basic_string_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class template <a class="el" href="classetl_1_1basic__string__view.html" title="The class template basic_string_view describes an object that can refer to a constant contiguous sequ...">basic_string_view</a> describes an object that can refer to a constant contiguous sequence of char-like objects with the first element of the sequence at position zero. A typical implementation holds only two members: a pointer to constant CharType and a size.  <a href="classetl_1_1basic__string__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bidirectional__iterator__tag.html">bidirectional_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories.  <a href="structetl_1_1bidirectional__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__and.html">bit_and</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing bitwise AND. Effectively calls operator&amp; on type T.  <a href="structetl_1_1bit__and.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__and_3_01void_01_4.html">bit_and&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing bitwise AND. Effectively calls operator&amp; on type T. The standard library provides a specialization of <a class="el" href="structetl_1_1bit__and.html" title="Function object for performing bitwise AND. Effectively calls operator&amp; on type T. ">etl::bit_and</a> when T is not specified, which leaves the parameter types and return type to be deduced.  <a href="structetl_1_1bit__and_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__not.html">bit_not</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing bitwise NOT. Effectively calls operator~ on type T.  <a href="structetl_1_1bit__not.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__not_3_01void_01_4.html">bit_not&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing bitwise NOT. Effectively calls operator~ on type T. The standard library provides a specialization of <a class="el" href="structetl_1_1bit__not.html" title="Function object for performing bitwise NOT. Effectively calls operator~ on type T. ">etl::bit_not</a> when T is not specified, which leaves the parameter types and return type to be deduced.  <a href="structetl_1_1bit__not_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__or.html">bit_or</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing bitwise OR. Effectively calls operator| on type T.  <a href="structetl_1_1bit__or.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__or_3_01void_01_4.html">bit_or&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing bitwise OR. Effectively calls operator| on type T. The standard library provides a specialization of <a class="el" href="structetl_1_1bit__or.html" title="Function object for performing bitwise OR. Effectively calls operator| on type T. ...">etl::bit_or</a> when T is not specified, which leaves the parameter types and return type to be deduced.  <a href="structetl_1_1bit__or_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__xor.html">bit_xor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing bitwise XOR. Effectively calls operator^ on type T.  <a href="structetl_1_1bit__xor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1bit__xor_3_01void_01_4.html">bit_xor&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing bitwise XOR. Effectively calls operator^ on type T. The standard library provides a specialization of <a class="el" href="structetl_1_1bit__xor.html" title="Function object for performing bitwise XOR. Effectively calls operator^ on type T. ">etl::bit_xor</a> when T is not specified, which leaves the parameter types and return type to be deduced.  <a href="structetl_1_1bit__xor_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1bitset.html">bitset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class template bitset represents a fixed-size sequence of N bits. Bitsets can be manipulated by standard logic operators.  <a href="classetl_1_1bitset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1char__traits.html">char_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structetl_1_1char__traits.html" title="The char_traits class is a traits class template that abstracts basic character and string operations...">char_traits</a> class is a traits class template that abstracts basic character and string operations for a given character type. The defined operation set is such that generic algorithms almost always can be implemented in terms of it. It is thus possible to use such algorithms with almost any possible character or string type, just by supplying a customized <a class="el" href="structetl_1_1char__traits.html" title="The char_traits class is a traits class template that abstracts basic character and string operations...">char_traits</a> class. The <a class="el" href="structetl_1_1char__traits.html" title="The char_traits class is a traits class template that abstracts basic character and string operations...">char_traits</a> class template serves as a basis for explicit instantiations. The user can provide a specialization for any custom character types. Several specializations are defined for the standard character types. If an operation on traits emits an exception, the behavior is undefined.  <a href="structetl_1_1char__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1char__traits_3_01char_01_4.html">char_traits&lt; char &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializations of <a class="el" href="structetl_1_1char__traits.html" title="The char_traits class is a traits class template that abstracts basic character and string operations...">char_traits</a> for type char.  <a href="structetl_1_1char__traits_3_01char_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type.html">common_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the common type among all types T..., that is the type all T... can be implicitly converted to. If such a type exists (as determined according to the rules below), the member type names that type. Otherwise, there is no member type. https://en.cppreference.com/w/cpp/types/common_type.  <a href="structetl_1_1common__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type_3_01etl_1_1chrono_1_1duration_3_01Rep1_00_01Period1_01_4_00_01etl_1_1cb97b81fdc5f26d47dec1bbf9c7339b38.html">common_type&lt; etl::chrono::duration&lt; Rep1, Period1 &gt;, etl::chrono::duration&lt; Rep2, Period2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exposes the type named type, which is the common type of two etl::chrono::durations, whose period is the greatest common divisor of Period1 and Period2.  <a href="structetl_1_1common__type_3_01etl_1_1chrono_1_1duration_3_01Rep1_00_01Period1_01_4_00_01etl_1_1cb97b81fdc5f26d47dec1bbf9c7339b38.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type_3_01T_01_4.html">common_type&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type_3_01T1_00_01T2_01_4.html">common_type&lt; T1, T2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type_3_01T1_00_01T2_00_01R_8_8_8_01_4.html">common_type&lt; T1, T2, R... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1conditional.html">conditional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides member typedef type, which is defined as T if B is true at compile time, or as F if B is false.  <a href="structetl_1_1conditional.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1conditional_3_01false_00_01T_00_01F_01_4.html">conditional&lt; false, T, F &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1conjunction.html">conjunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the logical conjunction of the type traits B..., effectively performing a logical AND on the sequence of traits.  <a href="structetl_1_1conjunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1conjunction_3_01B1_01_4.html">conjunction&lt; B1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1conjunction_3_01B1_00_01Bn_8_8_8_01_4.html">conjunction&lt; B1, Bn... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1contiguous__iterator__tag.html">contiguous_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories.  <a href="structetl_1_1contiguous__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1crtp.html">crtp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1decay.html">decay</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1default__searcher.html">default_searcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default searcher. A class suitable for use with Searcher overload of <a class="el" href="namespaceetl.html#a7813a73d80057255ef78a69804f2f361" title="Searches for the first occurrence of the sequence of elements [s_first, s_last) in the range [first...">etl::search</a> that delegates the search operation to the pre-C++17 standard library's <a class="el" href="namespaceetl.html#a7813a73d80057255ef78a69804f2f361" title="Searches for the first occurrence of the sequence of elements [s_first, s_last) in the range [first...">etl::search</a>.  <a href="classetl_1_1default__searcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1defer__lock__t.html">defer_lock_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty class tag types used to specify locking strategy for <a class="el" href="classetl_1_1lock__guard.html" title="The class lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a ...">etl::lock_guard</a>, <a class="el" href="classetl_1_1scoped__lock.html" title="RAII based lock. ">etl::scoped_lock</a>, etl::unique_lock, and etl::shared_lock.  <a href="structetl_1_1defer__lock__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1disjunction.html">disjunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the logical disjunction of the type traits B..., effectively performing a logical OR on the sequence of traits.  <a href="structetl_1_1disjunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1disjunction_3_01B1_01_4.html">disjunction&lt; B1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1disjunction_3_01B1_00_01Bn_8_8_8_01_4.html">disjunction&lt; B1, Bn... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1divides.html">divides</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing division. Effectively calls operator/ on two instances of type T.  <a href="structetl_1_1divides.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1divides_3_01void_01_4.html">divides&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing division. Effectively calls operator/ on two instances of type T. The standard library provides a specialization of <a class="el" href="structetl_1_1divides.html" title="Function object for performing division. Effectively calls operator/ on two instances of type T...">etl::divides</a> when T is not specified, which leaves the parameter types and return type to be deduced.  <a href="structetl_1_1divides_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1enable__if.html">enable_if</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a member typedef only if a boolean constant is true.  <a href="structetl_1_1enable__if.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1enable__if_3_01true_00_01Type_01_4.html">enable_if&lt; true, Type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1equal__to.html">equal_to</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons. Unless specialised, invokes operator== on type T.  <a href="structetl_1_1equal__to.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1equal__to_3_01void_01_4.html">equal_to&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons. Unless specialised, invokes operator== on type T. The standard library provides a specialization of <a class="el" href="structetl_1_1equal__to.html" title="Function object for performing comparisons. Unless specialised, invokes operator== on type T...">etl::equal_to</a> when T is not specified, which leaves the parameter types and return type to be deduced.  <a href="structetl_1_1equal__to_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1extent.html">extent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1extent_3_01T[]_00_010_01_4.html">extent&lt; T[], 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1extent_3_01T[]_00_01N_01_4.html">extent&lt; T[], N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1extent_3_01T[I]_00_010_01_4.html">extent&lt; T[I], 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1extent_3_01T[I]_00_01N_01_4.html">extent&lt; T[I], N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1forward__iterator__tag.html">forward_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories.  <a href="structetl_1_1forward__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1fpos.html">fpos</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1front__insert__iterator.html">front_insert_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classetl_1_1front__insert__iterator.html" title="etl::front_insert_iterator is an LegacyOutputIterator that prepends elements to a container for which...">etl::front_insert_iterator</a> is an LegacyOutputIterator that prepends elements to a container for which it was constructed. The container's push_front() member function is called whenever the iterator (whether dereferenced or not) is assigned to. Incrementing the <a class="el" href="classetl_1_1front__insert__iterator.html" title="etl::front_insert_iterator is an LegacyOutputIterator that prepends elements to a container for which...">etl::front_insert_iterator</a> is a no-op.  <a href="classetl_1_1front__insert__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1function.html">function</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1function_3_01Capacity_00_01Result_07Arguments_8_8_8_08_4.html">function&lt; Capacity, Result(Arguments...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1function__view.html">function_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1function__view_3_01Result_07Arguments_8_8_8_08_4.html">function_view&lt; Result(Arguments...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1greater.html">greater</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons. Unless specialised, invokes operator&gt; on type T.  <a href="structetl_1_1greater.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1greater_3_01void_01_4.html">greater&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons. Unless specialised, invokes operator&gt; on type T. The standard library provides a specialization of <a class="el" href="structetl_1_1greater.html" title="Function object for performing comparisons. Unless specialised, invokes operator&gt; on type T...">etl::greater</a> when T is not specified, which leaves the parameter types and return type to be deduced.  <a href="structetl_1_1greater_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1greater__equal.html">greater_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons. Unless specialised, invokes operator&gt;= on type T.  <a href="structetl_1_1greater__equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1greater__equal_3_01void_01_4.html">greater_equal&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons. Unless specialised, invokes operator&gt; on type T. The standard library provides a specialization of <a class="el" href="structetl_1_1greater__equal.html" title="Function object for performing comparisons. Unless specialised, invokes operator&gt;= on type T...">etl::greater_equal</a> when T is not specified, which leaves the parameter types and return type to be deduced.  <a href="structetl_1_1greater__equal_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1has__virtual__destructor.html">has_virtual_destructor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a href="https://en.cppreference.com/w/cpp/types/has_virtual_destructor">https://en.cppreference.com/w/cpp/types/has_virtual_destructor</a>  <a href="structetl_1_1has__virtual__destructor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1in__place__index__t.html">in_place_index_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disambiguation tags that can be passed to the constructors of <a class="el" href="classetl_1_1optional.html">etl::optional</a>, <a class="el" href="classetl_1_1variant.html" title="The class template etl::variant represents a type-safe union. An instance of etl::variant at any give...">etl::variant</a>, and etl::any to indicate that the contained object should be constructed in-place, and (for the latter two) the type of the object to be constructed.  <a href="structetl_1_1in__place__index__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1in__place__t.html">in_place_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disambiguation tags that can be passed to the constructors of <a class="el" href="classetl_1_1optional.html">etl::optional</a>, <a class="el" href="classetl_1_1variant.html" title="The class template etl::variant represents a type-safe union. An instance of etl::variant at any give...">etl::variant</a>, and etl::any to indicate that the contained object should be constructed in-place, and (for the latter two) the type of the object to be constructed.  <a href="structetl_1_1in__place__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1in__place__type__t.html">in_place_type_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disambiguation tags that can be passed to the constructors of <a class="el" href="classetl_1_1optional.html">etl::optional</a>, <a class="el" href="classetl_1_1variant.html" title="The class template etl::variant represents a type-safe union. An instance of etl::variant at any give...">etl::variant</a>, and etl::any to indicate that the contained object should be constructed in-place, and (for the latter two) the type of the object to be constructed.  <a href="structetl_1_1in__place__type__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1input__iterator__tag.html">input_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories.  <a href="structetl_1_1input__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1integral__constant.html">integral_constant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__arithmetic.html">is_arithmetic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an arithmetic type (that is, an integral type or a floating-point type) or a cv-qualified version thereof, provides the member constant value equal true. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__arithmetic.html" title="If T is an arithmetic type (that is, an integral type or a floating-point type) or a cv-qualified ver...">is_arithmetic</a> or is_arithmetic_v (since C++17) is undefined.  <a href="structetl_1_1is__arithmetic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__array.html">is_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is an array type. Provides the member constant value which is equal to true, if T is an array type. Otherwise, value is equal to false.  <a href="structetl_1_1is__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__array_3_01T[]_4.html">is_array&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__array_3_01T[N]_4.html">is_array&lt; T[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__assignable.html">is_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the expression <a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292" title="Converts any type T to a reference type, making it possible to use member functions in decltype expre...">etl::declval&lt;T&gt;()</a> = <a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292" title="Converts any type T to a reference type, making it possible to use member functions in decltype expre...">etl::declval&lt;U&gt;()</a> is well-formed in unevaluated context, provides the member constant value equal true. Otherwise, value is false. Access checks are performed as if from a context unrelated to either type.  <a href="structetl_1_1is__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__base__of.html">is_base_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Derived is derived from Base or if both are the same non-union class (in both cases ignoring cv-qualification), provides the member constant value equal to true. Otherwise value is false.  <a href="structetl_1_1is__base__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__bounded__array.html">is_bounded_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is an array type of known bound. Provides the member constant value which is equal to true, if T is an array type of known bound. Otherwise, value is equal to false.  <a href="structetl_1_1is__bounded__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__bounded__array_3_01T[N]_4.html">is_bounded_array&lt; T[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__class.html">is_class</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__compound.html">is_compound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a compound type (that is, array, function, object pointer, function pointer, member object pointer, member function pointer, reference, class, union, or enumeration, including any cv-qualified variants), provides the member constant value equal true. For any other type, value is false.  <a href="structetl_1_1is__compound.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__const.html">is_const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a const-qualified type (that is, const, or const volatile), provides the member constant value equal to true. For any other type, value is false.  <a href="structetl_1_1is__const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__const_3_01const_01T_01_4.html">is_const&lt; const T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__convertible.html">is_convertible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the imaginary function definition To test() { return <a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292" title="Converts any type T to a reference type, making it possible to use member functions in decltype expre...">etl::declval&lt;From&gt;()</a>; } is well-formed, (that is, either <a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292" title="Converts any type T to a reference type, making it possible to use member functions in decltype expre...">etl::declval&lt;From&gt;()</a> can be converted to To using implicit conversions, or both From and To are possibly cv-qualified void), provides the member constant value equal to true. Otherwise value is false. For the purposes of this check, the use of <a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292" title="Converts any type T to a reference type, making it possible to use member functions in decltype expre...">etl::declval</a> in the return statement is not considered an odr-use. Access checks are performed as if from a context unrelated to either type. Only the validity of the immediate context of the expression in the return statement (including conversions to the return type) is considered.  <a href="structetl_1_1is__convertible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__copy__assignable.html">is_copy_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#ac6a0d38654d5eeea44e25fea4eae7a55">etl::is_assignable&lt;T&amp;, const T&amp;&gt;::value</a>.  <a href="structetl_1_1is__copy__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__copy__constructible.html">is_copy_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to etl::is_constructible&lt;T, const T&amp;&gt;::value.  <a href="structetl_1_1is__copy__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__default__constructible.html">is_default_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If etl::is_constructible&lt;T&gt;::value is true, provides the member constant value equal to true, otherwise value is false.  <a href="structetl_1_1is__default__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__destructible.html">is_destructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a href="https://en.cppreference.com/w/cpp/types/is_destructible">https://en.cppreference.com/w/cpp/types/is_destructible</a>  <a href="structetl_1_1is__destructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__destructible_3_01Type[]_4.html">is_destructible&lt; Type[]&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a href="https://en.cppreference.com/w/cpp/types/is_destructible">https://en.cppreference.com/w/cpp/types/is_destructible</a>  <a href="structetl_1_1is__destructible_3_01Type[]_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__destructible_3_01void_01_4.html">is_destructible&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a href="https://en.cppreference.com/w/cpp/types/is_destructible">https://en.cppreference.com/w/cpp/types/is_destructible</a>  <a href="structetl_1_1is__destructible_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__empty.html">is_empty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">f T is an empty type (that is, a non-union class type with no non-static data members other than bit-fields of size 0, no virtual functions, no virtual base classes, and no non-empty base classes), provides the member constant value equal to true. For any other type, value is false.  <a href="structetl_1_1is__empty.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__enum.html">is_enum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__error__code__enum.html">is_error_code_enum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__error__condition__enum.html">is_error_condition_enum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__error__condition__enum_3_01errc_01_4.html">is_error_condition_enum&lt; errc &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__floating__point.html">is_floating_point</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a floating-point type. Provides the member constant value which is equal to true, if T is the type float, double, long double, including any cv-qualified variants. Otherwise, value is equal to false.  <a href="structetl_1_1is__floating__point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__function.html">is_function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a function type. Types like <a class="el" href="classetl_1_1function.html">etl::function</a>, lambdas, classes with overloaded operator() and pointers to functions don't count as function types. Provides the member constant value which is equal to true, if T is a function type. Otherwise, value is equal to false.  <a href="structetl_1_1is__function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__fundamental.html">is_fundamental</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a fundamental type (that is, arithmetic type, void, or nullptr_t), provides the member constant value equal true. For any other type, value is false.  <a href="structetl_1_1is__fundamental.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__integral.html">is_integral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__lvalue__reference.html">is_lvalue_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a lvalue reference type. Provides the member constant value which is equal to true, if T is a lvalue reference type. Otherwise, value is equal to false.  <a href="structetl_1_1is__lvalue__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__lvalue__reference_3_01T_01_6_01_4.html">is_lvalue_reference&lt; T &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__member__function__pointer.html">is_member_function_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a non-static member function pointer. Provides the member constant value which is equal to true, if T is a non-static member function pointer type. Otherwise, value is equal to false.  <a href="structetl_1_1is__member__function__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__member__object__pointer.html">is_member_object_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a non-static member object pointer. Provides the member constant value which is equal to true, if T is a non-static member object pointer type. Otherwise, value is equal to false.  <a href="structetl_1_1is__member__object__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__member__pointer.html">is_member_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is pointer to non-static member object or a pointer to non-static member function, provides the member constant value equal true. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__member__pointer.html" title="If T is pointer to non-static member object or a pointer to non-static member function, provides the member constant value equal true. For any other type, value is false. The behavior of a program that adds specializations for is_member_pointer or is_member_pointer_v (since C++17) is undefined. ">is_member_pointer</a> or is_member_pointer_v (since C++17) is undefined.  <a href="structetl_1_1is__member__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__move__assignable.html">is_move_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#ac6a0d38654d5eeea44e25fea4eae7a55">etl::is_assignable&lt;T&amp;, T&amp;&amp;&gt;::value</a>.  <a href="structetl_1_1is__move__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__move__constructible.html">is_move_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to etl::is_constructible&lt;T, T&amp;&amp;&gt;::value.  <a href="structetl_1_1is__move__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__assignable.html">is_nothrow_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the expression <a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292" title="Converts any type T to a reference type, making it possible to use member functions in decltype expre...">etl::declval&lt;T&gt;()</a> = <a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292" title="Converts any type T to a reference type, making it possible to use member functions in decltype expre...">etl::declval&lt;U&gt;()</a> is well-formed in unevaluated context, provides the member constant value equal true. Otherwise, value is false. Access checks are performed as if from a context unrelated to either type.  <a href="structetl_1_1is__nothrow__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__constructible.html">is_nothrow_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variable definition does not call any operation that is not trivial. For the purposes of this check, the call to <a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292" title="Converts any type T to a reference type, making it possible to use member functions in decltype expre...">etl::declval</a> is considered trivial.  <a href="structetl_1_1is__nothrow__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__copy__assignable.html">is_nothrow_copy_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#ac6a0d38654d5eeea44e25fea4eae7a55">etl::is_nothrow_assignable&lt;T&amp;, const T&amp;&gt;::value</a>.  <a href="structetl_1_1is__nothrow__copy__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__copy__constructible.html">is_nothrow_copy_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as copy, but uses etl::is_nothrow_constructible&lt;T, const T&amp;&gt;.  <a href="structetl_1_1is__nothrow__copy__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__default__constructible.html">is_nothrow_default_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="structetl_1_1integral__constant.html#ac6a0d38654d5eeea44e25fea4eae7a55">etl::is_nothrow_constructible&lt;T&gt;::value</a> is true, provides the member constant value equal to true, otherwise value is false.  <a href="structetl_1_1is__nothrow__default__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__destructible.html">is_nothrow_destructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a href="https://en.cppreference.com/w/cpp/types/is_destructible">https://en.cppreference.com/w/cpp/types/is_destructible</a>  <a href="structetl_1_1is__nothrow__destructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__destructible_3_01Type_01_6_01_4.html">is_nothrow_destructible&lt; Type &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__destructible_3_01Type_01_6_6_01_4.html">is_nothrow_destructible&lt; Type &amp;&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__destructible_3_01Type[N]_4.html">is_nothrow_destructible&lt; Type[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__move__assignable.html">is_nothrow_move_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#ac6a0d38654d5eeea44e25fea4eae7a55">etl::is_assignable&lt;T&amp;, T&amp;&amp;&gt;::value</a>.  <a href="structetl_1_1is__nothrow__move__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__move__constructible.html">is_nothrow_move_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#ac6a0d38654d5eeea44e25fea4eae7a55">etl::is_nothrow_constructible&lt;T, T&amp;&amp;&gt;::value</a>.  <a href="structetl_1_1is__nothrow__move__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__swappable.html">is_nothrow_swappable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to etl::is_nothrow_swappable_with&lt;T&amp;, T&amp;&gt;::value.  <a href="structetl_1_1is__nothrow__swappable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__null__pointer.html">is_null_pointer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__object.html">is_object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an object type (that is any possibly cv-qualified type other than function, reference, or void types), provides the member constant value equal true. For any other type, value is false.  <a href="structetl_1_1is__object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__pointer.html">is_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a pointer to object or a pointer to function (but not a pointer to member/member function). Provides the member constant value which is equal to true, if T is a object/function pointer type. Otherwise, value is equal to false.  <a href="structetl_1_1is__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__reference.html">is_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a reference type (lvalue reference or rvalue reference), provides the member constant value equal true. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__reference.html" title="If T is a reference type (lvalue reference or rvalue reference), provides the member constant value e...">is_reference</a> or is_reference_v is undefined.  <a href="structetl_1_1is__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__reference_3_01T_01_6_01_4.html">is_reference&lt; T &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__reference_3_01T_01_6_6_01_4.html">is_reference&lt; T &amp;&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__rvalue__reference.html">is_rvalue_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a rvalue reference type. Provides the member constant value which is equal to true, if T is a rvalue reference type. Otherwise, value is equal to false.  <a href="structetl_1_1is__rvalue__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__rvalue__reference_3_01T_01_6_6_01_4.html">is_rvalue_reference&lt; T &amp;&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__same.html">is_same</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T and U name the same type (taking into account const/volatile qualifications), provides the member constant value equal to true. Otherwise value is false.  <a href="structetl_1_1is__same.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__same_3_01T_00_01T_01_4.html">is_same&lt; T, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__scalar.html">is_scalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a scalar type (that is a possibly cv-qualified arithmetic, pointer, pointer to member, enumeration, or <a class="el" href="namespaceetl.html#adf4272f3f16bf2234ac8248db615f133">etl::nullptr_t</a> type), provides the member constant value equal true. For any other type, value is false.  <a href="structetl_1_1is__scalar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__signed.html">is_signed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an arithmetic type, provides the member constant value equal to true if T(-1) &lt; T(0): this results in true for the floating-point types and the signed integer types, and in false for the unsigned integer types and the type bool. For any other type, value is false.  <a href="structetl_1_1is__signed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__swappable.html">is_swappable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to etl::is_swappable_with&lt;T&amp;, T&amp;&gt;::value.  <a href="structetl_1_1is__swappable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivial.html">is_trivial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is TrivialType (that is, a scalar type, a trivially copyable class with a trivial default constructor, or array of such type/class, possibly cv-qualified), provides the member constant value equal to true. For any other type, value is false.  <a href="structetl_1_1is__trivial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__assignable.html">is_trivially_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the expression <a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292" title="Converts any type T to a reference type, making it possible to use member functions in decltype expre...">etl::declval&lt;T&gt;()</a> = <a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292" title="Converts any type T to a reference type, making it possible to use member functions in decltype expre...">etl::declval&lt;U&gt;()</a> is well-formed in unevaluated context, provides the member constant value equal true. Otherwise, value is false. Access checks are performed as if from a context unrelated to either type.  <a href="structetl_1_1is__trivially__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__constructible.html">is_trivially_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variable definition does not call any operation that is not trivial. For the purposes of this check, the call to <a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292" title="Converts any type T to a reference type, making it possible to use member functions in decltype expre...">etl::declval</a> is considered trivial.  <a href="structetl_1_1is__trivially__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__copy__assignable.html">is_trivially_copy_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#ac6a0d38654d5eeea44e25fea4eae7a55">etl::is_trivially_assignable&lt;T&amp;, const T&amp;&gt;::value</a>.  <a href="structetl_1_1is__trivially__copy__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__copy__constructible.html">is_trivially_copy_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as copy, but uses etl::is_trivially_constructible&lt;T, const T&amp;&gt;.  <a href="structetl_1_1is__trivially__copy__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1is__trivially__copyable.html">is_trivially_copyable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a TriviallyCopyable type, provides the member constant value equal to true. For any other type, value is false. The only trivially copyable types are scalar types, trivially copyable classes, and arrays of such types/classes (possibly cv-qualified).  <a href="classetl_1_1is__trivially__copyable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1is__trivially__copyable_3_01T_01_5_01_4.html">is_trivially_copyable&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__default__constructible.html">is_trivially_default_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="structetl_1_1integral__constant.html#ac6a0d38654d5eeea44e25fea4eae7a55">etl::is_trivially_constructible&lt;T&gt;::value</a> is true, provides the member constant value equal to true, otherwise value is false.  <a href="structetl_1_1is__trivially__default__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__destructible.html">is_trivially_destructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a href="https://en.cppreference.com/w/cpp/types/is_destructible">https://en.cppreference.com/w/cpp/types/is_destructible</a>  <a href="structetl_1_1is__trivially__destructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__move__assignable.html">is_trivially_move_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#ac6a0d38654d5eeea44e25fea4eae7a55">etl::is_assignable&lt;T&amp;, T&amp;&amp;&gt;::value</a>.  <a href="structetl_1_1is__trivially__move__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__move__constructible.html">is_trivially_move_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#ac6a0d38654d5eeea44e25fea4eae7a55">etl::is_trivially_constructible&lt;T, T&amp;&amp;&gt;::value</a>.  <a href="structetl_1_1is__trivially__move__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__unbounded__array.html">is_unbounded_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is an array type of unknown bound. Provides the member constant value which is equal to true, if T is an array type of unknown bound. Otherwise, value is equal to false.  <a href="structetl_1_1is__unbounded__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__unbounded__array_3_01T[]_4.html">is_unbounded_array&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__union.html">is_union</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__unsigned.html">is_unsigned</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an arithmetic type, provides the member constant value equal to true if T(0) &lt; T(-1): this results in true for the unsigned integer types and the type bool and in false for the signed integer types and the floating-point types. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__unsigned.html" title="If T is an arithmetic type, provides the member constant value equal to true if T(0) &lt; T(-1): this re...">is_unsigned</a> or is_unsigned_v (since C++17) is undefined.  <a href="structetl_1_1is__unsigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__void.html">is_void</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a member typedef only if a boolean constant is true.  <a href="structetl_1_1is__void.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__volatile.html">is_volatile</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__volatile_3_01volatile_01T_01_4.html">is_volatile&lt; volatile T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1iterator__traits.html" title="etl::iterator_traits is the type trait class that provides uniform interface to the properties of Leg...">etl::iterator_traits</a> is the type trait class that provides uniform interface to the properties of LegacyIterator types. This makes it possible to implement algorithms only in terms of iterators.  <a href="structetl_1_1iterator__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1iterator__traits_3_01T_01_5_01_4.html">iterator_traits&lt; T * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1iterator__traits.html" title="etl::iterator_traits is the type trait class that provides uniform interface to the properties of Leg...">etl::iterator_traits</a> is the type trait class that provides uniform interface to the properties of LegacyIterator types. This makes it possible to implement algorithms only in terms of iterators.  <a href="structetl_1_1iterator__traits_3_01T_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1less.html">less</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons. Unless specialised, invokes operator&lt; on type T.  <a href="structetl_1_1less.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1less_3_01void_01_4.html">less&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons. Unless specialised, invokes operator&lt; on type T. The standard library provides a specialization of <a class="el" href="structetl_1_1less.html" title="Function object for performing comparisons. Unless specialised, invokes operator&lt; on type T...">etl::less</a> when T is not specified, which leaves the parameter types and return type to be deduced.  <a href="structetl_1_1less_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1less__equal.html">less_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons. Unless specialised, invokes operator&lt;= on type T.  <a href="structetl_1_1less__equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1less__equal_3_01void_01_4.html">less_equal&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons. Unless specialised, invokes operator&lt; on type T. The standard library provides a specialization of <a class="el" href="structetl_1_1less__equal.html" title="Function object for performing comparisons. Unless specialised, invokes operator&lt;= on type T...">etl::less_equal</a> when T is not specified, which leaves the parameter types and return type to be deduced.  <a href="structetl_1_1less__equal_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1lock__guard.html">lock_guard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class <a class="el" href="classetl_1_1lock__guard.html" title="The class lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a ...">lock_guard</a> is a mutex wrapper that provides a convenient RAII-style mechanism for owning a mutex for the duration of a scoped block. When a <a class="el" href="classetl_1_1lock__guard.html" title="The class lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a ...">lock_guard</a> object is created, it attempts to take ownership of the mutex it is given. When control leaves the scope in which the <a class="el" href="classetl_1_1lock__guard.html" title="The class lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a ...">lock_guard</a> object was created, the <a class="el" href="classetl_1_1lock__guard.html" title="The class lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a ...">lock_guard</a> is destructed and the mutex is released. The <a class="el" href="classetl_1_1lock__guard.html" title="The class lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a ...">lock_guard</a> class is non-copyable.  <a href="classetl_1_1lock__guard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1logical__and.html">logical_and</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing logical AND (logical conjunction). Effectively calls operator&amp;&amp; on type T.  <a href="structetl_1_1logical__and.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1logical__and_3_01void_01_4.html">logical_and&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing logical AND (logical conjunction). Effectively calls operator&amp;&amp; on type T. The standard library provides a specialization of <a class="el" href="structetl_1_1logical__and.html" title="Function object for performing logical AND (logical conjunction). Effectively calls operator&amp;&amp; on typ...">etl::logical_and</a> when T is not specified, which leaves the parameter types and return type to be deduced.  <a href="structetl_1_1logical__and_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1logical__not.html">logical_not</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing logical NOT (logical negation). Effectively calls operator! for type T.  <a href="structetl_1_1logical__not.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1logical__not_3_01void_01_4.html">logical_not&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing logical NOT (logical negation). Effectively calls operator! for type T. The standard library provides a specialization of <a class="el" href="structetl_1_1logical__not.html" title="Function object for performing logical NOT (logical negation). Effectively calls operator! for type T...">etl::logical_not</a> when T is not specified, which leaves the parameter types and return type to be deduced.  <a href="structetl_1_1logical__not_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1logical__or.html">logical_or</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing logical OR (logical disjunction). Effectively calls operator|| on type T.  <a href="structetl_1_1logical__or.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1logical__or_3_01void_01_4.html">logical_or&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing logical OR (logical disjunction). Effectively calls operator|| on type T. The standard library provides a specialization of <a class="el" href="structetl_1_1logical__or.html" title="Function object for performing logical OR (logical disjunction). Effectively calls operator|| on type...">etl::logical_or</a> when T is not specified, which leaves the parameter types and return type to be deduced.  <a href="structetl_1_1logical__or_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1make__signed.html">make_signed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an integral (except bool) or enumeration type, provides the member typedef type which is the unsigned integer type corresponding to T, with the same cv-qualifiers. If T is signed or unsigned char, short, int, long, long long; the unsigned type from this list corresponding to T is provided. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1make__signed.html" title="If T is an integral (except bool) or enumeration type, provides the member typedef type which is the ...">make_signed</a> is undefined.  <a href="structetl_1_1make__signed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1make__unsigned.html">make_unsigned</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an integral (except bool) or enumeration type, provides the member typedef type which is the unsigned integer type corresponding to T, with the same cv-qualifiers. If T is signed or unsigned char, short, int, long, long long; the unsigned type from this list corresponding to T is provided. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1make__unsigned.html" title="If T is an integral (except bool) or enumeration type, provides the member typedef type which is the ...">make_unsigned</a> is undefined.  <a href="structetl_1_1make__unsigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1map.html">map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classetl_1_1map.html" title="etl::map is a sorted associative container that contains key-value pairs with unique keys...">etl::map</a> is a sorted associative container that contains key-value pairs with unique keys. Keys are sorted by using the comparison function Compare. Search, removal, and insertion operations have logarithmic complexity. Uses an inline key-value pair array as storage.  <a href="classetl_1_1map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1map__view.html">map_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface base class for <a class="el" href="classetl_1_1map.html" title="etl::map is a sorted associative container that contains key-value pairs with unique keys...">etl::map</a>. Use this class for function parameters. To create an instance, use <a class="el" href="classetl_1_1map.html" title="etl::map is a sorted associative container that contains key-value pairs with unique keys...">etl::map</a>.  <a href="classetl_1_1map__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1max__align__t.html">max_align_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1minus.html">minus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing subtraction. Effectively calls operator- on two instances of type T.  <a href="structetl_1_1minus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1minus_3_01void_01_4.html">minus&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing subtraction. Effectively calls operator- on two instances of type T. The standard library provides a specialization of <a class="el" href="structetl_1_1minus.html" title="Function object for performing subtraction. Effectively calls operator- on two instances of type T...">etl::minus</a> when T is not specified, which leaves the parameter types and return type to be deduced.  <a href="structetl_1_1minus_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1modulus.html">modulus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for computing remainders of divisions. Implements operator% for type T.  <a href="structetl_1_1modulus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1modulus_3_01void_01_4.html">modulus&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for computing remainders of divisions. Implements operator% for type T. The standard library provides a specialization of <a class="el" href="structetl_1_1modulus.html" title="Function object for computing remainders of divisions. Implements operator% for type T...">etl::modulus</a> when T is not specified, which leaves the parameter types and return type to be deduced.  <a href="structetl_1_1modulus_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1monostate.html">monostate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit type intended for use as a well-behaved empty alternative in <a class="el" href="classetl_1_1variant.html" title="The class template etl::variant represents a type-safe union. An instance of etl::variant at any give...">etl::variant</a>. In particular, a variant of non-default-constructible types may list <a class="el" href="structetl_1_1monostate.html" title="Unit type intended for use as a well-behaved empty alternative in etl::variant. In particular...">etl::monostate</a> as its first alternative: this makes the variant itself default-constructible.  <a href="structetl_1_1monostate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1multiplies.html">multiplies</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing multiplication. Effectively calls operator* on two instances of type T.  <a href="structetl_1_1multiplies.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1multiplies_3_01void_01_4.html">multiplies&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing multiplication. Effectively calls operator* on two instances of type T. The standard library provides a specialization of <a class="el" href="structetl_1_1multiplies.html" title="Function object for performing multiplication. Effectively calls operator* on two instances of type T...">etl::multiplies</a> when T is not specified, which leaves the parameter types and return type to be deduced.  <a href="structetl_1_1multiplies_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1negate.html">negate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing negation. Effectively calls operator- on an instance of type T.  <a href="structetl_1_1negate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1negate_3_01void_01_4.html">negate&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing negation. Effectively calls operator- on an instance of type T. The standard library provides a specialization of <a class="el" href="structetl_1_1negate.html" title="Function object for performing negation. Effectively calls operator- on an instance of type T...">etl::negate</a> when T is not specified, which leaves the parameter types and return type to be deduced.  <a href="structetl_1_1negate_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1negation.html">negation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the logical negation of the type trait B.  <a href="structetl_1_1negation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1not__equal__to.html">not_equal_to</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons. Unless specialised, invokes operator!= on type T.  <a href="structetl_1_1not__equal__to.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1not__equal__to_3_01void_01_4.html">not_equal_to&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing comparisons. Unless specialised, invokes operator!= on type T. The standard library provides a specialization of <a class="el" href="structetl_1_1not__equal__to.html" title="Function object for performing comparisons. Unless specialised, invokes operator!= on type T...">etl::not_equal_to</a> when T is not specified, which leaves the parameter types and return type to be deduced.  <a href="structetl_1_1not__equal__to_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1nullopt__t.html">nullopt_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1nullopt__t.html" title="etl::nullopt_t is an empty class type used to indicate optional type with uninitialized state...">etl::nullopt_t</a> is an empty class type used to indicate optional type with uninitialized state. In particular, <a class="el" href="classetl_1_1optional.html">etl::optional</a> has a constructor with <a class="el" href="structetl_1_1nullopt__t.html" title="etl::nullopt_t is an empty class type used to indicate optional type with uninitialized state...">nullopt_t</a> as a single argument, which creates an optional that does not contain a value.  <a href="structetl_1_1nullopt__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1numeric__limits.html">numeric_limits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1numeric__limits_3_01bool_01_4.html">numeric_limits&lt; bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1numeric__limits_3_01char_01_4.html">numeric_limits&lt; char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1numeric__limits_3_01double_01_4.html">numeric_limits&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1numeric__limits_3_01float_01_4.html">numeric_limits&lt; float &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1numeric__limits_3_01int_01_4.html">numeric_limits&lt; int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1numeric__limits_3_01long_01_4.html">numeric_limits&lt; long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1numeric__limits_3_01short_01_4.html">numeric_limits&lt; short &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1numeric__limits_3_01signed_01char_01_4.html">numeric_limits&lt; signed char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1numeric__limits_3_01unsigned_01char_01_4.html">numeric_limits&lt; unsigned char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1numeric__limits_3_01unsigned_01int_01_4.html">numeric_limits&lt; unsigned int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1numeric__limits_3_01unsigned_01long_01_4.html">numeric_limits&lt; unsigned long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1numeric__limits_3_01unsigned_01short_01_4.html">numeric_limits&lt; unsigned short &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1optional.html">optional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1output__iterator__tag.html">output_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories.  <a href="structetl_1_1output__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1pair.html">pair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1pair.html" title="etl::pair is a class template that provides a way to store two heterogeneous objects as a single unit...">etl::pair</a> is a class template that provides a way to store two heterogeneous objects as a single unit. A pair is a specific case of a <a class="el" href="structetl_1_1tuple.html">etl::tuple</a> with two elements. If neither T1 nor T2 is a possibly cv-qualified class type with non-trivial destructor, or array thereof, the destructor of pair is trivial.  <a href="structetl_1_1pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1piecewise__construct__t.html">piecewise_construct_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structetl_1_1piecewise__construct__t.html" title="etl::piecewise_construct_t is an empty class tag type used to disambiguate between different function...">etl::piecewise_construct_t</a> is an empty class tag type used to disambiguate between different functions that take two tuple arguments.  <a href="structetl_1_1piecewise__construct__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1plus.html">plus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing addition. Effectively calls operator+ on two instances of type T.  <a href="structetl_1_1plus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1plus_3_01void_01_4.html">plus&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing addition. Effectively calls operator+ on two instances of type T. The standard library provides a specialization of <a class="el" href="structetl_1_1plus.html" title="Function object for performing addition. Effectively calls operator+ on two instances of type T...">etl::plus</a> when T is not specified, which leaves the parameter types and return type to be deduced.  <a href="structetl_1_1plus_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1random__access__iterator__tag.html">random_access_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the category of an iterator. Each tag is an empty type and corresponds to one of the five (until C++20) six (since C++20) iterator categories.  <a href="structetl_1_1random__access__iterator__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1rank.html">rank</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Type is an array type, provides the member constant value equal to the number of dimensions of the array. For any other type, value is 0. The behavior of a program that adds specializations for rank or rank_v is undefined.  <a href="structetl_1_1rank.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1rank_3_01T[]_4.html">rank&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1rank_3_01T[N]_4.html">rank&lt; T[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ratio.html">ratio</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class template provides compile-time rational arithmetic support. Each instantiation of this template exactly represents any finite rational number as long as its numerator Num and denominator Denom are representable as compile-time constants of type intmax_t.  <a href="structetl_1_1ratio.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ratio__equal.html">ratio_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ratio objects for equality at compile-time. If the ratios R1 and R2 are equal, provides the member constant value equal true. Otherwise, value is false.  <a href="structetl_1_1ratio__equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ratio__greater.html">ratio_greater</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ratio objects for equality at compile-time. If the ratio R1 is greater than the ratio R2, provides the member constant value equal true. Otherwise, value is false.  <a href="structetl_1_1ratio__greater.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ratio__greater__equal.html">ratio_greater_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ratio objects for equality at compile-time. If the ratio R1 is greater than or equal to the ratio R2, provides the member constant value equal true. Otherwise, value is false.  <a href="structetl_1_1ratio__greater__equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ratio__less.html">ratio_less</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ratio objects for equality at compile-time. If the ratio R1 is less than the ratio R2, provides the member constant value equal true. Otherwise, value is false.  <a href="structetl_1_1ratio__less.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ratio__less__equal.html">ratio_less_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ratio objects for equality at compile-time. If the ratio R1 is less than or equal to the ratio R2, provides the member constant value equal true. Otherwise, value is false.  <a href="structetl_1_1ratio__less__equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1ratio__not__equal.html">ratio_not_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ratio objects for equality at compile-time. If the ratios R1 and R2 are not equal, provides the member constant value equal true. Otherwise, value is false.  <a href="structetl_1_1ratio__not__equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__all__extents.html">remove_all_extents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a multidimensional array of some type X, provides the member typedef type equal to X, otherwise type is T. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1remove__all__extents.html" title="If T is a multidimensional array of some type X, provides the member typedef type equal to X...">remove_all_extents</a> is undefined.  <a href="structetl_1_1remove__all__extents.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__all__extents_3_01T[]_4.html">remove_all_extents&lt; T[]&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a multidimensional array of some type X, provides the member typedef type equal to X, otherwise type is T. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1remove__all__extents.html" title="If T is a multidimensional array of some type X, provides the member typedef type equal to X...">remove_all_extents</a> is undefined.  <a href="structetl_1_1remove__all__extents_3_01T[]_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__all__extents_3_01T[N]_4.html">remove_all_extents&lt; T[N]&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a multidimensional array of some type X, provides the member typedef type equal to X, otherwise type is T. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1remove__all__extents.html" title="If T is a multidimensional array of some type X, provides the member typedef type equal to X...">remove_all_extents</a> is undefined.  <a href="structetl_1_1remove__all__extents_3_01T[N]_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__const.html">remove_const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except that its topmost cv-qualifiers are removed. Removes the topmost const.  <a href="structetl_1_1remove__const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__const_3_01Type_01const_01_4.html">remove_const&lt; Type const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__cv.html">remove_cv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except that its topmost cv-qualifiers are removed. Removes the topmost const, or the topmost volatile, or both, if present.  <a href="structetl_1_1remove__cv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__cvref.html">remove_cvref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the type T is a reference type, provides the member typedef type which is the type referred to by T with its topmost cv-qualifiers removed. Otherwise type is T with its topmost cv-qualifiers removed.  <a href="structetl_1_1remove__cvref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__extent.html">remove_extent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an array of some type X, provides the member typedef type equal to X, otherwise type is T. Note that if T is a multidimensional array, only the first dimension is removed. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1remove__extent.html" title="If T is an array of some type X, provides the member typedef type equal to X, otherwise type is T...">remove_extent</a> is undefined.  <a href="structetl_1_1remove__extent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__extent_3_01T[]_4.html">remove_extent&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__extent_3_01T[N]_4.html">remove_extent&lt; T[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__pointer.html">remove_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the type pointed to by T, or, if T is not a pointer, then type is the same as T. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1remove__pointer.html" title="Provides the member typedef type which is the type pointed to by T, or, if T is not a pointer...">remove_pointer</a> is undefined.  <a href="structetl_1_1remove__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__pointer_3_01T_01_5_01_4.html">remove_pointer&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__pointer_3_01T_01_5const_01_4.html">remove_pointer&lt; T *const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__pointer_3_01T_01_5const_01volatile_01_4.html">remove_pointer&lt; T *const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__pointer_3_01T_01_5volatile_01_4.html">remove_pointer&lt; T *volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__reference.html">remove_reference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__reference_3_01T_01_6_01_4.html">remove_reference&lt; T &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__reference_3_01T_01_6_6_01_4.html">remove_reference&lt; T &amp;&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__volatile.html">remove_volatile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except that its topmost cv-qualifiers are removed. Removes the topmost volatile.  <a href="structetl_1_1remove__volatile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__volatile_3_01Type_01volatile_01_4.html">remove_volatile&lt; Type volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1scope__exit.html">scope_exit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1scope__guard.html">scope_guard</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1scoped__lock.html">scoped_lock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII based lock.  <a href="classetl_1_1scoped__lock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1small__ptr.html">small_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compressed pointer to specified size. Intended to be used as a drop in replacement for native pointers.  <a href="classetl_1_1small__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1span.html">span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-owning view over a contiguous sequence of objects.  <a href="classetl_1_1span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1static__vector.html">static_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamically-resizable fixed-capacity vector.  <a href="classetl_1_1static__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1try__to__lock__t.html">try_to_lock_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty class tag types used to specify locking strategy for <a class="el" href="classetl_1_1lock__guard.html" title="The class lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a ...">etl::lock_guard</a>, <a class="el" href="classetl_1_1scoped__lock.html" title="RAII based lock. ">etl::scoped_lock</a>, etl::unique_lock, and etl::shared_lock.  <a href="structetl_1_1try__to__lock__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple.html">tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple_3_01First_01_4.html">tuple&lt; First &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__element.html">tuple_element</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time indexed access to the type of the elements of the array using tuple-like interface.  <a href="structetl_1_1tuple__element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__element_3_01I_00_01etl_1_1array_3_01T_00_01N_01_4_01_4.html">tuple_element&lt; I, etl::array&lt; T, N &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time indexed access to the type of the elements of the array using tuple-like interface.  <a href="structetl_1_1tuple__element_3_01I_00_01etl_1_1array_3_01T_00_01N_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size.html">tuple_size</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size_3_01const_01T_01_4.html">tuple_size&lt; const T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size_3_01const_01volatile_01T_01_4.html">tuple_size&lt; const volatile T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size_3_01etl_1_1array_3_01T_00_01N_01_4_01_4.html">tuple_size&lt; etl::array&lt; T, N &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the number of elements in an <a class="el" href="structetl_1_1array.html" title="etl::array is a container that encapsulates fixed size arrays. ">etl::array</a> as a compile-time constant expression.  <a href="structetl_1_1tuple__size_3_01etl_1_1array_3_01T_00_01N_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size_3_01etl_1_1tuple_3_01Types_8_8_8_01_4_01_4.html">tuple_size&lt; etl::tuple&lt; Types... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1tuple__size_3_01volatile_01T_01_4.html">tuple_size&lt; volatile T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1type__identity.html">type_identity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1variant.html">variant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class template <a class="el" href="classetl_1_1variant.html" title="The class template etl::variant represents a type-safe union. An instance of etl::variant at any give...">etl::variant</a> represents a type-safe union. An instance of <a class="el" href="classetl_1_1variant.html" title="The class template etl::variant represents a type-safe union. An instance of etl::variant at any give...">etl::variant</a> at any given time either holds a value of one of its alternative types.  <a href="classetl_1_1variant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__alternative.html">variant_alternative</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time indexed access to the types of the alternatives of the possibly cv-qualified variant, combining cv-qualifications of the variant (if any) with the cv-qualifications of the alternative.  <a href="structetl_1_1variant__alternative.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__alternative_3_01I_00_01const_01T_01_4.html">variant_alternative&lt; I, const T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time indexed access to the types of the alternatives of the possibly cv-qualified variant, combining cv-qualifications of the variant (if any) with the cv-qualifications of the alternative.  <a href="structetl_1_1variant__alternative_3_01I_00_01const_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1variant__alternative_3_01I_00_01variant_3_01Types_8_8_8_01_4_01_4.html">variant_alternative&lt; I, variant&lt; Types... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides compile-time indexed access to the types of the alternatives of the possibly cv-qualified variant, combining cv-qualifications of the variant (if any) with the cv-qualifications of the alternative.  <a href="structetl_1_1variant__alternative_3_01I_00_01variant_3_01Types_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a04532556e568bb7cc276440befc7f441"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a04532556e568bb7cc276440befc7f441">float_t</a> = float</td></tr>
<tr class="memdesc:a04532556e568bb7cc276440befc7f441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most efficient floating-point type at least as wide as float.  <a href="#a04532556e568bb7cc276440befc7f441">More...</a><br /></td></tr>
<tr class="separator:a04532556e568bb7cc276440befc7f441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c91cfdd41de11ccf80532067354fe92"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9c91cfdd41de11ccf80532067354fe92">double_t</a> = double</td></tr>
<tr class="memdesc:a9c91cfdd41de11ccf80532067354fe92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most efficient floating-point type at least as wide as double.  <a href="#a9c91cfdd41de11ccf80532067354fe92">More...</a><br /></td></tr>
<tr class="separator:a9c91cfdd41de11ccf80532067354fe92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd99b481983335f785f7713b9bb4f436"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afd99b481983335f785f7713b9bb4f436">int8_t</a> = <a class="el" href="namespaceetl.html#afd99b481983335f785f7713b9bb4f436">int8_t</a></td></tr>
<tr class="separator:afd99b481983335f785f7713b9bb4f436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffe3c07a4dbbe98792f1936145c6876"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3ffe3c07a4dbbe98792f1936145c6876">int16_t</a> = <a class="el" href="namespaceetl.html#a3ffe3c07a4dbbe98792f1936145c6876">int16_t</a></td></tr>
<tr class="separator:a3ffe3c07a4dbbe98792f1936145c6876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae779a40ac9323d2b0729f8bb95cf0fd1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae779a40ac9323d2b0729f8bb95cf0fd1">int32_t</a> = <a class="el" href="namespaceetl.html#ae779a40ac9323d2b0729f8bb95cf0fd1">int32_t</a></td></tr>
<tr class="separator:ae779a40ac9323d2b0729f8bb95cf0fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4b499f2d2820b8af24be768343759b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adc4b499f2d2820b8af24be768343759b">int64_t</a> = <a class="el" href="namespaceetl.html#adc4b499f2d2820b8af24be768343759b">int64_t</a></td></tr>
<tr class="separator:adc4b499f2d2820b8af24be768343759b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001f884b28f990ecdc3543a19440befb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a001f884b28f990ecdc3543a19440befb">uint8_t</a> = <a class="el" href="namespaceetl.html#a001f884b28f990ecdc3543a19440befb">uint8_t</a></td></tr>
<tr class="separator:a001f884b28f990ecdc3543a19440befb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61de6f15f82704d69a80d859a757298"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af61de6f15f82704d69a80d859a757298">uint16_t</a> = <a class="el" href="namespaceetl.html#af61de6f15f82704d69a80d859a757298">uint16_t</a></td></tr>
<tr class="separator:af61de6f15f82704d69a80d859a757298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e6df1710afc95336b7bee2714144b2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac8e6df1710afc95336b7bee2714144b2">uint32_t</a> = <a class="el" href="namespaceetl.html#ac8e6df1710afc95336b7bee2714144b2">uint32_t</a></td></tr>
<tr class="separator:ac8e6df1710afc95336b7bee2714144b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc782f054552345b4cd2428dbc92a4ca"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afc782f054552345b4cd2428dbc92a4ca">uint64_t</a> = <a class="el" href="namespaceetl.html#afc782f054552345b4cd2428dbc92a4ca">uint64_t</a></td></tr>
<tr class="separator:afc782f054552345b4cd2428dbc92a4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e71dd55b5fc087ed6ffc22b06b1543"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa4e71dd55b5fc087ed6ffc22b06b1543">intptr_t</a> = <a class="el" href="namespaceetl.html#aa4e71dd55b5fc087ed6ffc22b06b1543">intptr_t</a></td></tr>
<tr class="separator:aa4e71dd55b5fc087ed6ffc22b06b1543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fca78d7da557daded3df9fbffccc06c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2fca78d7da557daded3df9fbffccc06c">uintptr_t</a> = <a class="el" href="namespaceetl.html#a2fca78d7da557daded3df9fbffccc06c">uintptr_t</a></td></tr>
<tr class="separator:a2fca78d7da557daded3df9fbffccc06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178a2082210268baa21de6920cf2de96"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a178a2082210268baa21de6920cf2de96">intmax_t</a> = <a class="el" href="namespaceetl.html#a178a2082210268baa21de6920cf2de96">intmax_t</a></td></tr>
<tr class="separator:a178a2082210268baa21de6920cf2de96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f7969d130419941da3aeccefc32e6a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a91f7969d130419941da3aeccefc32e6a">uintmax_t</a> = <a class="el" href="namespaceetl.html#a91f7969d130419941da3aeccefc32e6a">uintmax_t</a></td></tr>
<tr class="separator:a91f7969d130419941da3aeccefc32e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac853a6316b146d25fdfbb5865821cedd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">size_t</a> = <a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">size_t</a></td></tr>
<tr class="separator:ac853a6316b146d25fdfbb5865821cedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e0abf50b318376b511f461e8baca33"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a56e0abf50b318376b511f461e8baca33">ptrdiff_t</a> = <a class="el" href="namespaceetl.html#a56e0abf50b318376b511f461e8baca33">ptrdiff_t</a></td></tr>
<tr class="separator:a56e0abf50b318376b511f461e8baca33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4272f3f16bf2234ac8248db615f133"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adf4272f3f16bf2234ac8248db615f133">nullptr_t</a> = decltype(nullptr)</td></tr>
<tr class="separator:adf4272f3f16bf2234ac8248db615f133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38946ce496aa3f045c07f32b2e4ca374"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a38946ce496aa3f045c07f32b2e4ca374">streamoff</a> = int</td></tr>
<tr class="separator:a38946ce496aa3f045c07f32b2e4ca374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515e08f8ce11f32a154acd83b2fe6b00"><td class="memTemplParams" colspan="2">template&lt;class R1 , class R2 &gt; </td></tr>
<tr class="memitem:a515e08f8ce11f32a154acd83b2fe6b00"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a515e08f8ce11f32a154acd83b2fe6b00">ratio_add</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; R1::num *R2::den+R2::num *R1::den, R1::den *R2::den &gt;</td></tr>
<tr class="memdesc:a515e08f8ce11f32a154acd83b2fe6b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alias template <a class="el" href="namespaceetl.html#a515e08f8ce11f32a154acd83b2fe6b00" title="The alias template etl::ratio_add denotes the result of adding two exact rational fractions represent...">etl::ratio_add</a> denotes the result of adding two exact rational fractions represented by the <a class="el" href="structetl_1_1ratio.html" title="The class template provides compile-time rational arithmetic support. Each instantiation of this temp...">etl::ratio</a> specializations R1 and R2.  <a href="#a515e08f8ce11f32a154acd83b2fe6b00">More...</a><br /></td></tr>
<tr class="separator:a515e08f8ce11f32a154acd83b2fe6b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234acc6c1438740afe4f7766f1208784"><td class="memTemplParams" colspan="2">template&lt;class R1 , class R2 &gt; </td></tr>
<tr class="memitem:a234acc6c1438740afe4f7766f1208784"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a234acc6c1438740afe4f7766f1208784">ratio_subtract</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; R1::num *R2::den - R2::num *R1::den, R1::den *R2::den &gt;</td></tr>
<tr class="memdesc:a234acc6c1438740afe4f7766f1208784"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alias template <a class="el" href="namespaceetl.html#a234acc6c1438740afe4f7766f1208784" title="The alias template etl::ratio_subtract denotes the result of subtracting two exact rational fractions...">etl::ratio_subtract</a> denotes the result of subtracting two exact rational fractions represented by the <a class="el" href="structetl_1_1ratio.html" title="The class template provides compile-time rational arithmetic support. Each instantiation of this temp...">etl::ratio</a> specializations R1 and R2.  <a href="#a234acc6c1438740afe4f7766f1208784">More...</a><br /></td></tr>
<tr class="separator:a234acc6c1438740afe4f7766f1208784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbdaf3b94f7cb0830c812d5c8aabbe0b"><td class="memTemplParams" colspan="2">template&lt;class R1 , class R2 &gt; </td></tr>
<tr class="memitem:abbdaf3b94f7cb0830c812d5c8aabbe0b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abbdaf3b94f7cb0830c812d5c8aabbe0b">ratio_multiply</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; R1::num *R2::num, R1::den *R2::den &gt;</td></tr>
<tr class="memdesc:abbdaf3b94f7cb0830c812d5c8aabbe0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alias template <a class="el" href="namespaceetl.html#abbdaf3b94f7cb0830c812d5c8aabbe0b" title="The alias template etl::ratio_multiply denotes the result of multiplying two exact rational fractions...">etl::ratio_multiply</a> denotes the result of multiplying two exact rational fractions represented by the <a class="el" href="structetl_1_1ratio.html" title="The class template provides compile-time rational arithmetic support. Each instantiation of this temp...">etl::ratio</a> specializations R1 and R2.  <a href="#abbdaf3b94f7cb0830c812d5c8aabbe0b">More...</a><br /></td></tr>
<tr class="separator:abbdaf3b94f7cb0830c812d5c8aabbe0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420acf1424e7ed7ae82f703ac31ff258"><td class="memTemplParams" colspan="2">template&lt;class R1 , class R2 &gt; </td></tr>
<tr class="memitem:a420acf1424e7ed7ae82f703ac31ff258"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a420acf1424e7ed7ae82f703ac31ff258">ratio_divide</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; R1::num *R2::den, R1::den *R2::num &gt;</td></tr>
<tr class="memdesc:a420acf1424e7ed7ae82f703ac31ff258"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alias template <a class="el" href="namespaceetl.html#a420acf1424e7ed7ae82f703ac31ff258" title="The alias template etl::ratio_divide denotes the result of dividing two exact rational fractions repr...">etl::ratio_divide</a> denotes the result of dividing two exact rational fractions represented by the <a class="el" href="structetl_1_1ratio.html" title="The class template provides compile-time rational arithmetic support. Each instantiation of this temp...">etl::ratio</a> specializations R1 and R2.  <a href="#a420acf1424e7ed7ae82f703ac31ff258">More...</a><br /></td></tr>
<tr class="separator:a420acf1424e7ed7ae82f703ac31ff258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc2ccd245f477d45cf1f6957c8f8993"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7cc2ccd245f477d45cf1f6957c8f8993">atto</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1, 1 '000 '000 '000 '000 '000 '000 &gt;</td></tr>
<tr class="separator:a7cc2ccd245f477d45cf1f6957c8f8993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837dad904f094bc29e24139565eec1c5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a837dad904f094bc29e24139565eec1c5">femto</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1, 1 '000 '000 '000 '000 '000 &gt;</td></tr>
<tr class="separator:a837dad904f094bc29e24139565eec1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85e2cc66c84a64edf096334ea68d82f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab85e2cc66c84a64edf096334ea68d82f">pico</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1, 1 '000 '000 '000 '000 &gt;</td></tr>
<tr class="separator:ab85e2cc66c84a64edf096334ea68d82f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16ea857b72e93345fcd6fb255f7fe86"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab16ea857b72e93345fcd6fb255f7fe86">nano</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1, 1 '000 '000 '000 &gt;</td></tr>
<tr class="separator:ab16ea857b72e93345fcd6fb255f7fe86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ee5013d725632677b4d1d93204c07b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a56ee5013d725632677b4d1d93204c07b">micro</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1, 1 '000 '000 &gt;</td></tr>
<tr class="separator:a56ee5013d725632677b4d1d93204c07b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc43923bf9757db3bbaa5a6e4d36a3c6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afc43923bf9757db3bbaa5a6e4d36a3c6">milli</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1, 1 '000 &gt;</td></tr>
<tr class="separator:afc43923bf9757db3bbaa5a6e4d36a3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d8c20c69482c794a0cfb9e4428ca8d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a95d8c20c69482c794a0cfb9e4428ca8d">centi</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1, 100 &gt;</td></tr>
<tr class="separator:a95d8c20c69482c794a0cfb9e4428ca8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f2e2c10ab4b06ed261d1e4a8358895"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a59f2e2c10ab4b06ed261d1e4a8358895">deci</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1, 10 &gt;</td></tr>
<tr class="separator:a59f2e2c10ab4b06ed261d1e4a8358895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae5b099e4ead54343e6304a6371985b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#acae5b099e4ead54343e6304a6371985b">deca</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 10, 1 &gt;</td></tr>
<tr class="separator:acae5b099e4ead54343e6304a6371985b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba04e5fa0d29bc9f6a9f3fa4f9ff3dbb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aba04e5fa0d29bc9f6a9f3fa4f9ff3dbb">hecto</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 100, 1 &gt;</td></tr>
<tr class="separator:aba04e5fa0d29bc9f6a9f3fa4f9ff3dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f7df2b4a088f13d067ec91336ad6d8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae0f7df2b4a088f13d067ec91336ad6d8">kilo</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1 '000, 1 &gt;</td></tr>
<tr class="separator:ae0f7df2b4a088f13d067ec91336ad6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8b8f156e99d25877de869998eca882"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afb8b8f156e99d25877de869998eca882">mega</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1 '000 '000, 1 &gt;</td></tr>
<tr class="separator:afb8b8f156e99d25877de869998eca882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa010c22727dfd8ede60afef156650c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aeaa010c22727dfd8ede60afef156650c">giga</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1 '000 '000 '000, 1 &gt;</td></tr>
<tr class="separator:aeaa010c22727dfd8ede60afef156650c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d864adecb109d82a13a134020536ce7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9d864adecb109d82a13a134020536ce7">tera</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1 '000 '000 '000 '000, 1 &gt;</td></tr>
<tr class="separator:a9d864adecb109d82a13a134020536ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2de582631c8b0507fa316267f24ae3b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac2de582631c8b0507fa316267f24ae3b">peta</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1 '000 '000 '000 '000 '000, 1 &gt;</td></tr>
<tr class="separator:ac2de582631c8b0507fa316267f24ae3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525a461cc6d062b7138a777cadacac47"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a525a461cc6d062b7138a777cadacac47">exa</a> = <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt; 1 '000 '000 '000 '000 '000 '000, 1 &gt;</td></tr>
<tr class="separator:a525a461cc6d062b7138a777cadacac47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2769dde06d41131748597077535e2cc"><td class="memTemplParams" colspan="2">template&lt;etl::size_t Capacity&gt; </td></tr>
<tr class="memitem:af2769dde06d41131748597077535e2cc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af2769dde06d41131748597077535e2cc">string</a> = <a class="el" href="classetl_1_1basic__string.html">basic_string</a>&lt; char, Capacity &gt;</td></tr>
<tr class="separator:af2769dde06d41131748597077535e2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bffa043c410459eda373247f384b9e2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9bffa043c410459eda373247f384b9e2">small_string</a> = <a class="el" href="classetl_1_1basic__string.html">basic_string</a>&lt; char, 32 &gt;</td></tr>
<tr class="separator:a9bffa043c410459eda373247f384b9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ec92a1e825e31fc024b95f85aed1da"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a41ec92a1e825e31fc024b95f85aed1da">string_view</a> = <a class="el" href="classetl_1_1basic__string__view.html">basic_string_view</a>&lt; char, <a class="el" href="structetl_1_1char__traits.html">etl::char_traits</a>&lt; char &gt; &gt;</td></tr>
<tr class="memdesc:a41ec92a1e825e31fc024b95f85aed1da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedefs for common character type.  <a href="#a41ec92a1e825e31fc024b95f85aed1da">More...</a><br /></td></tr>
<tr class="separator:a41ec92a1e825e31fc024b95f85aed1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19ff9e7939158584698cee4260e4471"><td class="memTemplParams" colspan="2">template&lt;bool B&gt; </td></tr>
<tr class="memitem:aa19ff9e7939158584698cee4260e4471"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa19ff9e7939158584698cee4260e4471">bool_constant</a> = <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt; bool, B &gt;</td></tr>
<tr class="separator:aa19ff9e7939158584698cee4260e4471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa107a29afbb5288d6dceb9fae86b07b8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa107a29afbb5288d6dceb9fae86b07b8">true_type</a> = <a class="el" href="namespaceetl.html#aa19ff9e7939158584698cee4260e4471">bool_constant</a>&lt; true &gt;</td></tr>
<tr class="separator:aa107a29afbb5288d6dceb9fae86b07b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466dc202e27dec8fa05a9fcc6ef47e27"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a466dc202e27dec8fa05a9fcc6ef47e27">false_type</a> = <a class="el" href="namespaceetl.html#aa19ff9e7939158584698cee4260e4471">bool_constant</a>&lt; false &gt;</td></tr>
<tr class="separator:a466dc202e27dec8fa05a9fcc6ef47e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f76cc2621d7373b79e2fc034f160ee0"><td class="memTemplParams" colspan="2">template&lt;typename... &gt; </td></tr>
<tr class="memitem:a8f76cc2621d7373b79e2fc034f160ee0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8f76cc2621d7373b79e2fc034f160ee0">void_t</a> = void</td></tr>
<tr class="separator:a8f76cc2621d7373b79e2fc034f160ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa508ba172c61957cf6c18357210f08f6"><td class="memTemplParams" colspan="2">template&lt;bool B, class T , class F &gt; </td></tr>
<tr class="memitem:aa508ba172c61957cf6c18357210f08f6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa508ba172c61957cf6c18357210f08f6">conditional_t</a> = typename <a class="el" href="structetl_1_1conditional.html">conditional</a>&lt; B, T, F &gt;::type</td></tr>
<tr class="separator:aa508ba172c61957cf6c18357210f08f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662329de2bc2a83d5e45d1ccad797f17"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a662329de2bc2a83d5e45d1ccad797f17"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a662329de2bc2a83d5e45d1ccad797f17">add_lvalue_reference_t</a> = typename <a class="el" href="structetl_1_1add__lvalue__reference.html">add_lvalue_reference</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a662329de2bc2a83d5e45d1ccad797f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c37a443b0cb66dc9b3c4374967b68f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a17c37a443b0cb66dc9b3c4374967b68f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a17c37a443b0cb66dc9b3c4374967b68f">add_rvalue_reference_t</a> = typename <a class="el" href="structetl_1_1add__rvalue__reference.html">add_rvalue_reference</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a17c37a443b0cb66dc9b3c4374967b68f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2368185596474aaf04490908f75e3a18"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2368185596474aaf04490908f75e3a18"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2368185596474aaf04490908f75e3a18">remove_extent_t</a> = typename <a class="el" href="structetl_1_1remove__extent.html">remove_extent</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a2368185596474aaf04490908f75e3a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e53fc126f7c9ebf9901856b9c2db22"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a96e53fc126f7c9ebf9901856b9c2db22"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a96e53fc126f7c9ebf9901856b9c2db22">remove_all_extents_t</a> = typename <a class="el" href="structetl_1_1remove__all__extents.html">remove_all_extents</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a96e53fc126f7c9ebf9901856b9c2db22"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a multidimensional array of some type X, provides the member typedef type equal to X, otherwise type is T. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1remove__all__extents.html" title="If T is a multidimensional array of some type X, provides the member typedef type equal to X...">remove_all_extents</a> is undefined.  <a href="#a96e53fc126f7c9ebf9901856b9c2db22">More...</a><br /></td></tr>
<tr class="separator:a96e53fc126f7c9ebf9901856b9c2db22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e058aba499e52cc4ed554dd7d65332"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a87e058aba499e52cc4ed554dd7d65332"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a87e058aba499e52cc4ed554dd7d65332">remove_const_t</a> = typename <a class="el" href="structetl_1_1remove__const.html">remove_const</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a87e058aba499e52cc4ed554dd7d65332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4593c7817c464ffa0d88cc07eb35e83"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af4593c7817c464ffa0d88cc07eb35e83"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af4593c7817c464ffa0d88cc07eb35e83">remove_volatile_t</a> = typename <a class="el" href="structetl_1_1remove__volatile.html">remove_volatile</a>&lt; T &gt;::type</td></tr>
<tr class="separator:af4593c7817c464ffa0d88cc07eb35e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70fb46b3c4c98f5f23b76cb25f343373"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a70fb46b3c4c98f5f23b76cb25f343373"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a70fb46b3c4c98f5f23b76cb25f343373">remove_cv_t</a> = typename <a class="el" href="structetl_1_1remove__cv.html">remove_cv</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a70fb46b3c4c98f5f23b76cb25f343373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ceb8de4fe37ef6a14f78dd10d95bb6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a26ceb8de4fe37ef6a14f78dd10d95bb6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a26ceb8de4fe37ef6a14f78dd10d95bb6">remove_reference_t</a> = typename <a class="el" href="structetl_1_1remove__reference.html">remove_reference</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a26ceb8de4fe37ef6a14f78dd10d95bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad85fb8c9d4542d450aa421f420184ca1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad85fb8c9d4542d450aa421f420184ca1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad85fb8c9d4542d450aa421f420184ca1">remove_cvref_t</a> = typename <a class="el" href="structetl_1_1remove__cvref.html">remove_cvref</a>&lt; T &gt;::type</td></tr>
<tr class="separator:ad85fb8c9d4542d450aa421f420184ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dab9cb6af8b33ea5f7c09c58e75bfb7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7dab9cb6af8b33ea5f7c09c58e75bfb7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7dab9cb6af8b33ea5f7c09c58e75bfb7">remove_pointer_t</a> = typename <a class="el" href="structetl_1_1remove__pointer.html">remove_pointer</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a7dab9cb6af8b33ea5f7c09c58e75bfb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd20d67cb221212f49a97e02a7c1ca25"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:afd20d67cb221212f49a97e02a7c1ca25"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afd20d67cb221212f49a97e02a7c1ca25">add_pointer_t</a> = typename <a class="el" href="structetl_1_1add__pointer.html">add_pointer</a>&lt; T &gt;::type</td></tr>
<tr class="separator:afd20d67cb221212f49a97e02a7c1ca25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40eedf5bef2e5ff8e5c7ca337cdc3ee1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a40eedf5bef2e5ff8e5c7ca337cdc3ee1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a40eedf5bef2e5ff8e5c7ca337cdc3ee1">add_cv_t</a> = typename <a class="el" href="structetl_1_1add__cv.html">add_cv</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a40eedf5bef2e5ff8e5c7ca337cdc3ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20607674e1e3cd49d5f0b815b33b2c1d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a20607674e1e3cd49d5f0b815b33b2c1d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a20607674e1e3cd49d5f0b815b33b2c1d">add_const_t</a> = typename <a class="el" href="structetl_1_1add__const.html">add_const</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a20607674e1e3cd49d5f0b815b33b2c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3ae65a8164f8204c7f0ab6076b2cbc"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4e3ae65a8164f8204c7f0ab6076b2cbc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4e3ae65a8164f8204c7f0ab6076b2cbc">add_volatile_t</a> = typename <a class="el" href="structetl_1_1add__volatile.html">add_volatile</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a4e3ae65a8164f8204c7f0ab6076b2cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abffe34c79351f871acb3e0438b2ad488"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:abffe34c79351f871acb3e0438b2ad488"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abffe34c79351f871acb3e0438b2ad488">make_signed_t</a> = typename <a class="el" href="structetl_1_1make__signed.html">make_signed</a>&lt; T &gt;::type</td></tr>
<tr class="separator:abffe34c79351f871acb3e0438b2ad488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2df53f4e399975501cf8300d451814"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:acb2df53f4e399975501cf8300d451814"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#acb2df53f4e399975501cf8300d451814">make_unsigned_t</a> = typename <a class="el" href="structetl_1_1make__unsigned.html">make_unsigned</a>&lt; T &gt;::type</td></tr>
<tr class="separator:acb2df53f4e399975501cf8300d451814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55bc1fa71ef93a7cd65389359e61683c"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:a55bc1fa71ef93a7cd65389359e61683c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a55bc1fa71ef93a7cd65389359e61683c">is_constructible</a> = detail::is_constructible_helper&lt; <a class="el" href="namespaceetl.html#a8f76cc2621d7373b79e2fc034f160ee0">void_t</a>&lt;&gt;, T, Args... &gt;</td></tr>
<tr class="separator:a55bc1fa71ef93a7cd65389359e61683c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2df4ab89284c8c5866afea3100f290"><td class="memTemplParams" colspan="2">template&lt;bool B, class T  = void&gt; </td></tr>
<tr class="memitem:a2a2df4ab89284c8c5866afea3100f290"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a> = typename <a class="el" href="structetl_1_1enable__if.html">enable_if</a>&lt; B, T &gt;::type</td></tr>
<tr class="separator:a2a2df4ab89284c8c5866afea3100f290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad602447fa93ad71f4db547fa0ae92883"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad602447fa93ad71f4db547fa0ae92883"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad602447fa93ad71f4db547fa0ae92883">decay_t</a> = typename <a class="el" href="structetl_1_1decay.html">decay</a>&lt; T &gt;::type</td></tr>
<tr class="separator:ad602447fa93ad71f4db547fa0ae92883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80571ce0a1bbafdb4d8e153ceade9e3"><td class="memTemplParams" colspan="2">template&lt;class... T&gt; </td></tr>
<tr class="memitem:ac80571ce0a1bbafdb4d8e153ceade9e3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac80571ce0a1bbafdb4d8e153ceade9e3">common_type_t</a> = typename <a class="el" href="structetl_1_1common__type.html">common_type</a>&lt; T... &gt;::type</td></tr>
<tr class="separator:ac80571ce0a1bbafdb4d8e153ceade9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ded42403ee495bd465c070c0262b8a"><td class="memTemplParams" colspan="2">template&lt;etl::size_t Len, etl::size_t Align = alignof(etl::max_align_t)&gt; </td></tr>
<tr class="memitem:a16ded42403ee495bd465c070c0262b8a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a16ded42403ee495bd465c070c0262b8a">aligned_storage_t</a> = typename <a class="el" href="structetl_1_1aligned__storage.html">aligned_storage</a>&lt; Len, Align &gt;::type</td></tr>
<tr class="separator:a16ded42403ee495bd465c070c0262b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7110ca07ee5b481d99d9ae57a977ed"><td class="memTemplParams" colspan="2">template&lt;size_t I, class T &gt; </td></tr>
<tr class="memitem:aef7110ca07ee5b481d99d9ae57a977ed"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aef7110ca07ee5b481d99d9ae57a977ed">variant_alternative_t</a> = typename <a class="el" href="structetl_1_1variant__alternative.html">variant_alternative</a>&lt; I, T &gt;::type</td></tr>
<tr class="separator:aef7110ca07ee5b481d99d9ae57a977ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aadba129a7dc760f449b09b7fafeb63a8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aadba129a7dc760f449b09b7fafeb63a8">endian</a> { <a class="el" href="namespaceetl.html#aadba129a7dc760f449b09b7fafeb63a8aaae6635e044ac56046b2893a529b5114">endian::little</a> = __ORDER_LITTLE_ENDIAN__, 
<a class="el" href="namespaceetl.html#aadba129a7dc760f449b09b7fafeb63a8ad861877da56b8b4ceb35c8cbfdf65bb4">endian::big</a> = __ORDER_BIG_ENDIAN__, 
<a class="el" href="namespaceetl.html#aadba129a7dc760f449b09b7fafeb63a8a8e5f3adee38c8fccc13c1f3be0143796">endian::native</a> = __BYTE_ORDER__
 }<tr class="memdesc:aadba129a7dc760f449b09b7fafeb63a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the endianness of all scalar types.  <a href="namespaceetl.html#aadba129a7dc760f449b09b7fafeb63a8">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aadba129a7dc760f449b09b7fafeb63a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe360a11ae9b0c5886f80ce2ff28a9d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">byte</a> : uint8_t </td></tr>
<tr class="separator:a3fe360a11ae9b0c5886f80ce2ff28a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cdec522db16c755ade7c7222bf8af92"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0cdec522db16c755ade7c7222bf8af92">float_round_style</a> { <br />
&#160;&#160;<a class="el" href="namespaceetl.html#a0cdec522db16c755ade7c7222bf8af92afd0fa1de009f9a47f51a0ec9c23aa10b">round_indeterminate</a> = -1, 
<a class="el" href="namespaceetl.html#a0cdec522db16c755ade7c7222bf8af92a00004115cf199c1cd29d07f78679a63d">round_toward_zero</a> = 0, 
<a class="el" href="namespaceetl.html#a0cdec522db16c755ade7c7222bf8af92a1fc678348a02cf4262fb59153d5b73c3">round_to_nearest</a> = 1, 
<a class="el" href="namespaceetl.html#a0cdec522db16c755ade7c7222bf8af92a274b79e7a1a164b8b9eea17dda4751c0">round_toward_infinity</a> = 2, 
<br />
&#160;&#160;<a class="el" href="namespaceetl.html#a0cdec522db16c755ade7c7222bf8af92ac6babddc09b7dbf6e3daf12455e3417f">round_toward_neg_infinity</a> = 3
<br />
 }</td></tr>
<tr class="separator:a0cdec522db16c755ade7c7222bf8af92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4892bd9af0bd3ad759fb95ab241247c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad4892bd9af0bd3ad759fb95ab241247c">float_denorm_style</a> { <a class="el" href="namespaceetl.html#ad4892bd9af0bd3ad759fb95ab241247cadc095ee49d9e6884cd67bc20a4c73287">denorm_indeterminate</a> = -1, 
<a class="el" href="namespaceetl.html#ad4892bd9af0bd3ad759fb95ab241247caf254439f29ec6166a1a6fb7b09efd141">denorm_absent</a> = 0, 
<a class="el" href="namespaceetl.html#ad4892bd9af0bd3ad759fb95ab241247ca5a085126714d6734d58691edaa278aa5">denorm_present</a> = 1
 }</td></tr>
<tr class="separator:ad4892bd9af0bd3ad759fb95ab241247c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf855e66ccd0c031e0994ed578f1c170"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170">errc</a> { <br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a8ab69162f060cc46b805b3265ad1cdf1">errc::address_family_not_supported</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a8e2bc80599069d337b43dff6edfb6891">errc::address_in_use</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a20abf2ffbf6e82e36405843f269d6438">errc::address_not_available</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170ab5580b198f691ab2df12f5e2ab974373">errc::already_connected</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a1b245b26b5ea3428c050d7f1503d7715">errc::argument_list_too_long</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a4b82222a0895b538d0597092b3ceab3e">errc::argument_out_of_domain</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170aaf169f73a82794128aa491c4b4f1c071">errc::bad_address</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a9941c5c8c58ff058b870e94e96ac38e1">errc::bad_file_descriptor</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170ac7944ab5d2e25bf75b267d070b506d1c">errc::bad_message</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a2f0338eed54503152be1d31c93c9c2f1">errc::broken_pipe</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a2f8f27a7eef1ad585c7ab6f25a6c2c79">errc::connection_aborted</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a81cf222a9b1530171fdfd66c3f734989">errc::connection_already_in_progress</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a53793ee58fc24168a0d6549c3cb2df8e">errc::connection_refused</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170abf39bfc8665384194e343c08ab344405">errc::connection_reset</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a6177070a517d51a4382ab0d7c88e5b58">errc::cross_device_link</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a326032e01f2a5e14c7f730f4d03d753a">errc::destination_address_required</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170ab3ab5338a00f49c4451851cc5442f370">errc::device_or_resource_busy</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a6a336135d33e62f49edc55f29354e12e">errc::directory_not_empty</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a4dfaf9c996cf045f32d17edc9754fc95">errc::executable_format_error</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a41edf636e3c7b59f797348fc58472258">errc::file_exists</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170aa1e14bfb89b41ddf654b1772c8fd2e74">errc::file_too_large</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a6e56e6ed055b9771b8192a4f229fee27">errc::filename_too_long</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170aa33c516bbdfb179cef733c8daeb97bed">errc::function_not_supported</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170afe2377fbd16d7f335474e1df7d6376bf">errc::host_unreachable</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a054e5b4ff59331386872de744d661719">errc::identifier_removed</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a53a9e57a679708b2d8ff0ccd8ec96b18">errc::illegal_byte_sequence</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a45fe7da1767194b580aeba752d7b44ae">errc::inappropriate_io_control_operation</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170afadb76763385627e57ec386c9b6038f0">errc::interrupted</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170ae55d43eabeefe5a8271b4a3c898bd18f">errc::invalid_argument</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170abd86a2c65caf6a270b916234ab321ce3">errc::invalid_seek</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170acccc32f2a5f7dc7b87d2f85daea66789">errc::io_error</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170af3c51d7ea75a76f26c0a2bdc00c4e006">errc::is_a_directory</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170ade5f4bc2f8a4690176e22e83196b9fd3">errc::message_size</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a93b16d34b1689f66f0cfed60e99c0009">errc::network_down</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a0e1d200ae35ede416bf85f84093ce37a">errc::network_reset</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a608a68344b4eb1fe0690861a83828816">errc::network_unreachable</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a618ead44397b73cf0baa08b460b66c39">errc::no_buffer_space</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170ad08d4c854a6810cebd2a8ab61876f919">errc::no_child_process</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170add431dfaf61ea842693dca8be1ebcaf7">errc::no_link</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a58688487c3e24313637a76bd29881e64">errc::no_lock_available</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170aeec0f03ad92584c78835c10ab79d7f42">errc::no_message_available</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170acec935db07cfc57caafa37e98eafb213">errc::no_message</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170abed8a9032d9366c28582a0ad59a31525">errc::no_protocol_option</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a1a5334dd8d1ca56e33887bd44630641b">errc::no_space_on_device</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170ad8b1d94a0ac09c6d55b2ed68f0836142">errc::no_stream_resources</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a5c83a012eac17bbf458df5804801e373">errc::no_such_device_or_address</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170af42b2e58729e2783b683c8610977fc22">errc::no_such_device</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a2e70fc89b08f26fa3fc77694c91e8f7a">errc::no_such_file_or_directory</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170ad91a9b8a734f2bef4b778f89806cbab7">errc::no_such_process</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a21e867ca95e1dfecff4701863547dcec">errc::not_a_directory</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a22ac64bb14c46bcbc338a21950b6e722">errc::not_a_socket</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a6e752b7a04543e5052b2d0dd05eca0fa">errc::not_a_stream</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a69c2dbb5917ca550a862e9c1c839bca1">errc::not_connected</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170aafdb5594dc3e484fc1bfd7c564d550c1">errc::not_enough_memory</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170aa55e82356e9721946aa9ba954733c6f0">errc::not_supported</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170afd3d0bdcc9eb9e68534b7d055c5fe586">errc::operation_canceled</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a4c7eb50b6d86ac8a130ebebc18dbe263">errc::operation_in_progress</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a8344b3d509942f035d5e303022f9b986">errc::operation_not_permitted</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a69bf074bf052ee4c9047b62fe7c24569">errc::operation_not_supported</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a738abdaead9cd7b2e2ea19a34764b385">errc::operation_would_block</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a2abac2fa6722c56b2ea17ac6c4097f68">errc::owner_dead</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170ae8ee838822072f02738dbd7d97ea03fc">errc::permission_denied</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a9665c745d0a9132d8da6ed55e89a0564">errc::protocol_error</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170aa2635acef8b9a3e1c40923829722d472">errc::protocol_not_supported</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a06108efce8ef1cd8aa4cc440f8b4317f">errc::read_only_file_system</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170aed65f7649c6f0e365673d65a9d8119d8">errc::resource_deadlock_would_occur</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170ae46a97ea2906921c8c626890bde832cf">errc::resource_unavailable_try_again</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a8e0fafb181567cc468e1ee81983d739d">errc::result_out_of_range</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a6805059549401365b824b54573a6f46e">errc::state_not_recoverable</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170ac1a620a30954dc9402a811453c2c3e3f">errc::stream_timeout</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170ad2f80f12d22bb099fcf1062db660b567">errc::text_file_busy</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a56c27b1ab1a5a5a0eae853cabb4dc0c1">errc::timed_out</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a3130d1d4e000cdc1e7c47013e313c10e">errc::too_many_files_open_in_system</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170aed2c33c8fe874cfeba6f4a7747c62d05">errc::too_many_files_open</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170abfe22fc9b27a8ff13186aba60b6bc5c8">errc::too_many_links</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a33c78baca1480479c88aa4d50cb68206">errc::too_many_symbolic_link_levels</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a143653b075bff946193644ba6d97fa5d">errc::value_too_large</a>, 
<a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170a81cac28a38438710de9856af4a8bcd0b">errc::wrong_protocol_type</a>
<br />
 }<tr class="memdesc:abf855e66ccd0c031e0994ed578f1c170"><td class="mdescLeft">&#160;</td><td class="mdescRight">The scoped enumeration <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170" title="The scoped enumeration etl::errc defines the values of portable error conditions that correspond to t...">etl::errc</a> defines the values of portable error conditions that correspond to the POSIX error codes.  <a href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:abf855e66ccd0c031e0994ed578f1c170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d70da9977ec456339973b30e372fcbd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3d70da9977ec456339973b30e372fcbd">language_standard</a> { <br />
&#160;&#160;<a class="el" href="namespaceetl.html#a3d70da9977ec456339973b30e372fcbda807ac7fd9764fb3e810d9f1048cd63ca">language_standard::cpp_98</a> = 1998, 
<a class="el" href="namespaceetl.html#a3d70da9977ec456339973b30e372fcbdabbe07f980d9fa36187463846b2811aed">language_standard::cpp_11</a> = 2011, 
<a class="el" href="namespaceetl.html#a3d70da9977ec456339973b30e372fcbdaee3f3f8ff98b05c178cea91bf69cde50">language_standard::cpp_14</a> = 2014, 
<a class="el" href="namespaceetl.html#a3d70da9977ec456339973b30e372fcbda6289bbfa378818f7066ccad5847da5a2">language_standard::cpp_17</a> = 2017, 
<br />
&#160;&#160;<a class="el" href="namespaceetl.html#a3d70da9977ec456339973b30e372fcbda4c7aabdc3eb0d845c62edfb822b0fe5a">language_standard::cpp_20</a> = 2020
<br />
 }<tr class="memdesc:a3d70da9977ec456339973b30e372fcbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration for the currently selected C++ standard version.  <a href="namespaceetl.html#a3d70da9977ec456339973b30e372fcbd">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a3d70da9977ec456339973b30e372fcbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0a1c3baeebc248b3f787a308af595c6a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0a1c3baeebc248b3f787a308af595c6a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0a1c3baeebc248b3f787a308af595c6a">swap</a> (T &amp;a, T &amp;b) noexcept -&gt; void</td></tr>
<tr class="memdesc:a0a1c3baeebc248b3f787a308af595c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the given values. Swaps the values a and b. This overload does not participate in overload resolution unless <a class="el" href="namespaceetl.html#a82b776d5da5e25514489bfd330d7940d">etl::is_move_constructible_v&lt;T&gt;</a> &amp;&amp; <a class="el" href="namespaceetl.html#ad208b3b6c99d59cdc5d698310e59143e">etl::is_move_assignable_v&lt;T&gt;</a> is true.  <a href="#a0a1c3baeebc248b3f787a308af595c6a">More...</a><br /></td></tr>
<tr class="separator:a0a1c3baeebc248b3f787a308af595c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18b878794474881fce640e7a163abf3"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt1 , typename ForwardIt2 &gt; </td></tr>
<tr class="memitem:aa18b878794474881fce640e7a163abf3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa18b878794474881fce640e7a163abf3">iter_swap</a> (ForwardIt1 a, ForwardIt2 b) -&gt; void</td></tr>
<tr class="memdesc:aa18b878794474881fce640e7a163abf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the values of the elements the given iterators are pointing to.  <a href="#aa18b878794474881fce640e7a163abf3">More...</a><br /></td></tr>
<tr class="separator:aa18b878794474881fce640e7a163abf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a5b274f170d18a9e175fddf538a4bc"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename OutputIter &gt; </td></tr>
<tr class="memitem:ad0a5b274f170d18a9e175fddf538a4bc"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad0a5b274f170d18a9e175fddf538a4bc">move</a> (InputIter first, InputIter last, OutputIter destination) -&gt; OutputIter</td></tr>
<tr class="memdesc:ad0a5b274f170d18a9e175fddf538a4bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the elements in the range [first, last), to another range beginning at d_first, starting from first and proceeding to last - 1. After this operation the elements in the moved-from range will still contain valid values of the appropriate type, but not necessarily the same values as before the move.  <a href="#ad0a5b274f170d18a9e175fddf538a4bc">More...</a><br /></td></tr>
<tr class="separator:ad0a5b274f170d18a9e175fddf538a4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013f931a99670b660a20f65b845013a3"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename UnaryFunction &gt; </td></tr>
<tr class="memitem:a013f931a99670b660a20f65b845013a3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a013f931a99670b660a20f65b845013a3">for_each</a> (InputIt first, InputIt last, UnaryFunction f) noexcept -&gt; UnaryFunction</td></tr>
<tr class="memdesc:a013f931a99670b660a20f65b845013a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given function object f to the result of dereferencing every iterator in the range [first, last] in order.  <a href="#a013f931a99670b660a20f65b845013a3">More...</a><br /></td></tr>
<tr class="separator:a013f931a99670b660a20f65b845013a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3c610f3a94e96a8a1c8cac49e70388"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename Size , typename UnaryFunction &gt; </td></tr>
<tr class="memitem:a9c3c610f3a94e96a8a1c8cac49e70388"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9c3c610f3a94e96a8a1c8cac49e70388">for_each_n</a> (InputIter first, Size n, UnaryFunction f) noexcept -&gt; InputIter</td></tr>
<tr class="memdesc:a9c3c610f3a94e96a8a1c8cac49e70388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given function object <code>f</code> to the result of dereferencing every iterator in the range [ <code>first</code>, first+n] in order.  <a href="#a9c3c610f3a94e96a8a1c8cac49e70388">More...</a><br /></td></tr>
<tr class="separator:a9c3c610f3a94e96a8a1c8cac49e70388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32dd2ffddadb248b341e42879a9e9951"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename OutputIter , typename UnaryOperation &gt; </td></tr>
<tr class="memitem:a32dd2ffddadb248b341e42879a9e9951"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a32dd2ffddadb248b341e42879a9e9951">transform</a> (InputIter first, InputIter last, OutputIter destination, UnaryOperation op) -&gt; OutputIter</td></tr>
<tr class="memdesc:a32dd2ffddadb248b341e42879a9e9951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given function to a range and stores the result in another range, beginning at <code>destination</code>. The unary operation unary_op is applied to the range defined by [ <code>first</code>, <code>last</code> ).  <a href="#a32dd2ffddadb248b341e42879a9e9951">More...</a><br /></td></tr>
<tr class="separator:a32dd2ffddadb248b341e42879a9e9951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f81702ed6fdeecec082a39e50e4e2a"><td class="memTemplParams" colspan="2">template&lt;typename InputIter1 , typename InputIter2 , typename OutputIter , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:a85f81702ed6fdeecec082a39e50e4e2a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a85f81702ed6fdeecec082a39e50e4e2a">transform</a> (InputIter1 first1, InputIter1 last1, InputIter2 first2, OutputIter dest, BinaryOperation op) -&gt; OutputIter</td></tr>
<tr class="memdesc:a85f81702ed6fdeecec082a39e50e4e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given function to a range and stores the result in another range, beginning at destination. The binary operation binary_op is applied to pairs of elements from two ranges: one defined by [first1, last1) and the other beginning at first2.  <a href="#a85f81702ed6fdeecec082a39e50e4e2a">More...</a><br /></td></tr>
<tr class="separator:a85f81702ed6fdeecec082a39e50e4e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b963791bdb1da038a64b23555f245c4"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename Generator &gt; </td></tr>
<tr class="memitem:a0b963791bdb1da038a64b23555f245c4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0b963791bdb1da038a64b23555f245c4">generate</a> (ForwardIt first, ForwardIt last, Generator g) -&gt; void</td></tr>
<tr class="memdesc:a0b963791bdb1da038a64b23555f245c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns each element in range [first, last) a value generated by the given function object g.  <a href="#a0b963791bdb1da038a64b23555f245c4">More...</a><br /></td></tr>
<tr class="separator:a0b963791bdb1da038a64b23555f245c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab984bfa2eb0fd6da7369b629ca3acdc7"><td class="memTemplParams" colspan="2">template&lt;typename OutputIt , typename SizeT , typename Generator &gt; </td></tr>
<tr class="memitem:ab984bfa2eb0fd6da7369b629ca3acdc7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab984bfa2eb0fd6da7369b629ca3acdc7">generate_n</a> (OutputIt first, SizeT <a class="el" href="namespaceetl.html#afe8c29a359a0bffc469225b6aeb0ae64">count</a>, Generator g) -&gt; OutputIt</td></tr>
<tr class="memdesc:ab984bfa2eb0fd6da7369b629ca3acdc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns values, generated by given function object g, to the first count elements in the range beginning at first, if count&gt;0. Does nothing otherwise.  <a href="#ab984bfa2eb0fd6da7369b629ca3acdc7">More...</a><br /></td></tr>
<tr class="separator:ab984bfa2eb0fd6da7369b629ca3acdc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8c29a359a0bffc469225b6aeb0ae64"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename T &gt; </td></tr>
<tr class="memitem:afe8c29a359a0bffc469225b6aeb0ae64"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afe8c29a359a0bffc469225b6aeb0ae64">count</a> (InputIter first, InputIter last, const T &amp;value) -&gt; typename <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; InputIter &gt;::difference_type</td></tr>
<tr class="memdesc:afe8c29a359a0bffc469225b6aeb0ae64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the range [first, last) satisfying specific criteria. Counts the elements that are equal to value.  <a href="#afe8c29a359a0bffc469225b6aeb0ae64">More...</a><br /></td></tr>
<tr class="separator:afe8c29a359a0bffc469225b6aeb0ae64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af949f9bf15cdfd7e8282705ab00ddcc3"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:af949f9bf15cdfd7e8282705ab00ddcc3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af949f9bf15cdfd7e8282705ab00ddcc3">count_if</a> (InputIter first, InputIter last, UnaryPredicate p) -&gt; typename <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt; InputIter &gt;::difference_type</td></tr>
<tr class="memdesc:af949f9bf15cdfd7e8282705ab00ddcc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the range [first, last) satisfying specific criteria. Counts elements for which predicate p returns true.  <a href="#af949f9bf15cdfd7e8282705ab00ddcc3">More...</a><br /></td></tr>
<tr class="separator:af949f9bf15cdfd7e8282705ab00ddcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab340ce2b640eb395b08fe8b266881603"><td class="memTemplParams" colspan="2">template&lt;class InputIter1 , class InputIter2 , class BinaryPredicate &gt; </td></tr>
<tr class="memitem:ab340ce2b640eb395b08fe8b266881603"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab340ce2b640eb395b08fe8b266881603">mismatch</a> (InputIter1 first1, InputIter1 last1, InputIter2 first2, BinaryPredicate pred) -&gt; <a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; InputIter1, InputIter2 &gt;</td></tr>
<tr class="memdesc:ab340ce2b640eb395b08fe8b266881603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first mismatching pair of elements from two ranges: one defined by [first1, last1) and another defined by [first2,last2). If last2 is not provided (overloads (1-4)), it denotes first2 + (last1 - first1).  <a href="#ab340ce2b640eb395b08fe8b266881603">More...</a><br /></td></tr>
<tr class="separator:ab340ce2b640eb395b08fe8b266881603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5670e9bd29e9fb8b573558fe9a6bff17"><td class="memTemplParams" colspan="2">template&lt;class InputIter1 , class InputIter2 &gt; </td></tr>
<tr class="memitem:a5670e9bd29e9fb8b573558fe9a6bff17"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5670e9bd29e9fb8b573558fe9a6bff17">mismatch</a> (InputIter1 first1, InputIter1 last1, InputIter2 first2) -&gt; <a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; InputIter1, InputIter2 &gt;</td></tr>
<tr class="memdesc:a5670e9bd29e9fb8b573558fe9a6bff17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first mismatching pair of elements from two ranges: one defined by [first1, last1) and another defined by [first2,last2). If last2 is not provided (overloads (1-4)), it denotes first2 + (last1 - first1).  <a href="#a5670e9bd29e9fb8b573558fe9a6bff17">More...</a><br /></td></tr>
<tr class="separator:a5670e9bd29e9fb8b573558fe9a6bff17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4d823211420bf94fe43c94bf902a57"><td class="memTemplParams" colspan="2">template&lt;class InputIter1 , class InputIter2 , class BinaryPredicate &gt; </td></tr>
<tr class="memitem:ace4d823211420bf94fe43c94bf902a57"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ace4d823211420bf94fe43c94bf902a57">mismatch</a> (InputIter1 first1, InputIter1 last1, InputIter2 first2, InputIter2 last2, BinaryPredicate pred) -&gt; <a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; InputIter1, InputIter2 &gt;</td></tr>
<tr class="memdesc:ace4d823211420bf94fe43c94bf902a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first mismatching pair of elements from two ranges: one defined by [first1, last1) and another defined by [first2,last2). If last2 is not provided (overloads (1-4)), it denotes first2 + (last1 - first1).  <a href="#ace4d823211420bf94fe43c94bf902a57">More...</a><br /></td></tr>
<tr class="separator:ace4d823211420bf94fe43c94bf902a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934b1b48023aa9532f3f329fe18f1079"><td class="memTemplParams" colspan="2">template&lt;class InputIter1 , class InputIter2 &gt; </td></tr>
<tr class="memitem:a934b1b48023aa9532f3f329fe18f1079"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a934b1b48023aa9532f3f329fe18f1079">mismatch</a> (InputIter1 first1, InputIter1 last1, InputIter2 first2, InputIter2 last2) -&gt; <a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; InputIter1, InputIter2 &gt;</td></tr>
<tr class="memdesc:a934b1b48023aa9532f3f329fe18f1079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first mismatching pair of elements from two ranges: one defined by [first1, last1) and another defined by [first2,last2). If last2 is not provided (overloads (1-4)), it denotes first2 + (last1 - first1).  <a href="#a934b1b48023aa9532f3f329fe18f1079">More...</a><br /></td></tr>
<tr class="separator:a934b1b48023aa9532f3f329fe18f1079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac504b45acce22fba5a962a6ba642c942"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename T &gt; </td></tr>
<tr class="memitem:ac504b45acce22fba5a962a6ba642c942"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac504b45acce22fba5a962a6ba642c942">find</a> (InputIter first, InputIter last, T const &amp;value) noexcept -&gt; InputIter</td></tr>
<tr class="memdesc:ac504b45acce22fba5a962a6ba642c942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an element equal to value.  <a href="#ac504b45acce22fba5a962a6ba642c942">More...</a><br /></td></tr>
<tr class="separator:ac504b45acce22fba5a962a6ba642c942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee167552576c5bc91dc94fd1fc8324d"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a0ee167552576c5bc91dc94fd1fc8324d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0ee167552576c5bc91dc94fd1fc8324d">find_if</a> (InputIter first, InputIter last, UnaryPredicate p) noexcept -&gt; InputIter</td></tr>
<tr class="memdesc:a0ee167552576c5bc91dc94fd1fc8324d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an element for which predicate p returns true.  <a href="#a0ee167552576c5bc91dc94fd1fc8324d">More...</a><br /></td></tr>
<tr class="separator:a0ee167552576c5bc91dc94fd1fc8324d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9d16dde42342fd1e6b91ea378af979"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a2a9d16dde42342fd1e6b91ea378af979"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2a9d16dde42342fd1e6b91ea378af979">find_if_not</a> (InputIter first, InputIter last, UnaryPredicate predicate) noexcept -&gt; InputIter</td></tr>
<tr class="memdesc:a2a9d16dde42342fd1e6b91ea378af979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an element for which predicate q returns false.  <a href="#a2a9d16dde42342fd1e6b91ea378af979">More...</a><br /></td></tr>
<tr class="separator:a2a9d16dde42342fd1e6b91ea378af979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7813a73d80057255ef78a69804f2f361"><td class="memTemplParams" colspan="2">template&lt;class ForwardIter1 , class ForwardIter2 , class BinaryPredicate &gt; </td></tr>
<tr class="memitem:a7813a73d80057255ef78a69804f2f361"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7813a73d80057255ef78a69804f2f361">search</a> (ForwardIter1 first, ForwardIter1 last, ForwardIter2 s_first, ForwardIter2 s_last, BinaryPredicate pred) -&gt; ForwardIter1</td></tr>
<tr class="memdesc:a7813a73d80057255ef78a69804f2f361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the first occurrence of the sequence of elements [s_first, s_last) in the range [first, last). Elements are compared using the given binary predicate <code>pred</code>.  <a href="#a7813a73d80057255ef78a69804f2f361">More...</a><br /></td></tr>
<tr class="separator:a7813a73d80057255ef78a69804f2f361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af723526a6284b865a1a001958e4f72a4"><td class="memTemplParams" colspan="2">template&lt;class ForwardIter1 , class ForwardIter2 &gt; </td></tr>
<tr class="memitem:af723526a6284b865a1a001958e4f72a4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af723526a6284b865a1a001958e4f72a4">search</a> (ForwardIter1 first, ForwardIter1 last, ForwardIter2 s_first, ForwardIter2 s_last) -&gt; ForwardIter1</td></tr>
<tr class="memdesc:af723526a6284b865a1a001958e4f72a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the first occurrence of the sequence of elements [s_first, s_last) in the range [first, last). Elements are compared using operator==.  <a href="#af723526a6284b865a1a001958e4f72a4">More...</a><br /></td></tr>
<tr class="separator:af723526a6284b865a1a001958e4f72a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358e4ef95efe7ae5429eb586dedf290f"><td class="memTemplParams" colspan="2">template&lt;class ForwardIter , class Searcher &gt; </td></tr>
<tr class="memitem:a358e4ef95efe7ae5429eb586dedf290f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a358e4ef95efe7ae5429eb586dedf290f">search</a> (ForwardIter first, ForwardIter last, Searcher const &amp;searcher) -&gt; ForwardIter</td></tr>
<tr class="memdesc:a358e4ef95efe7ae5429eb586dedf290f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the sequence [first, last) for the pattern specified in the constructor of searcher.  <a href="#a358e4ef95efe7ae5429eb586dedf290f">More...</a><br /></td></tr>
<tr class="separator:a358e4ef95efe7ae5429eb586dedf290f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fdd0cf88f36f44f8fe8ec8327cfac74"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a7fdd0cf88f36f44f8fe8ec8327cfac74"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7fdd0cf88f36f44f8fe8ec8327cfac74">max</a> (Type const &amp;a, Type const &amp;b) noexcept -&gt; Type const &amp;</td></tr>
<tr class="memdesc:a7fdd0cf88f36f44f8fe8ec8327cfac74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the greater of a and b.  <a href="#a7fdd0cf88f36f44f8fe8ec8327cfac74">More...</a><br /></td></tr>
<tr class="separator:a7fdd0cf88f36f44f8fe8ec8327cfac74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220fbd23aca7dbc728c200471ed114c8"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Compare &gt; </td></tr>
<tr class="memitem:a220fbd23aca7dbc728c200471ed114c8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a220fbd23aca7dbc728c200471ed114c8">max</a> (Type const &amp;a, Type const &amp;b, Compare comp) noexcept -&gt; Type const &amp;</td></tr>
<tr class="memdesc:a220fbd23aca7dbc728c200471ed114c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the greater of a and b, using a compare function.  <a href="#a220fbd23aca7dbc728c200471ed114c8">More...</a><br /></td></tr>
<tr class="separator:a220fbd23aca7dbc728c200471ed114c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa58c8973da727c50c3d0d28b83fdf304"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:aa58c8973da727c50c3d0d28b83fdf304"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa58c8973da727c50c3d0d28b83fdf304">max_element</a> (ForwardIterator first, ForwardIterator last) noexcept -&gt; ForwardIterator</td></tr>
<tr class="memdesc:aa58c8973da727c50c3d0d28b83fdf304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the greatest element in the range [first, last). Elements are compared using operator&lt;.  <a href="#aa58c8973da727c50c3d0d28b83fdf304">More...</a><br /></td></tr>
<tr class="separator:aa58c8973da727c50c3d0d28b83fdf304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab573cae5dd21a6ab0e00ee00da8855e0"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Compare &gt; </td></tr>
<tr class="memitem:ab573cae5dd21a6ab0e00ee00da8855e0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab573cae5dd21a6ab0e00ee00da8855e0">max_element</a> (ForwardIterator first, ForwardIterator last, Compare comp) -&gt; ForwardIterator</td></tr>
<tr class="memdesc:ab573cae5dd21a6ab0e00ee00da8855e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the greatest element in the range [first, last). Elements are compared using the given binary comparison function comp.  <a href="#ab573cae5dd21a6ab0e00ee00da8855e0">More...</a><br /></td></tr>
<tr class="separator:ab573cae5dd21a6ab0e00ee00da8855e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae1500815312b248e453896d5439b63"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:adae1500815312b248e453896d5439b63"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adae1500815312b248e453896d5439b63">min</a> (Type const &amp;a, Type const &amp;b) noexcept -&gt; Type const &amp;</td></tr>
<tr class="memdesc:adae1500815312b248e453896d5439b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller of a and b.  <a href="#adae1500815312b248e453896d5439b63">More...</a><br /></td></tr>
<tr class="separator:adae1500815312b248e453896d5439b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479c4a8315ae3ef2d1128858d723afc2"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Compare &gt; </td></tr>
<tr class="memitem:a479c4a8315ae3ef2d1128858d723afc2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a479c4a8315ae3ef2d1128858d723afc2">min</a> (Type const &amp;a, Type const &amp;b, Compare comp) noexcept -&gt; Type const &amp;</td></tr>
<tr class="memdesc:a479c4a8315ae3ef2d1128858d723afc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller of a and b, using a compare function.  <a href="#a479c4a8315ae3ef2d1128858d723afc2">More...</a><br /></td></tr>
<tr class="separator:a479c4a8315ae3ef2d1128858d723afc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f1e60aa2d0ca23d39bd975ed52e4b4"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:a41f1e60aa2d0ca23d39bd975ed52e4b4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a41f1e60aa2d0ca23d39bd975ed52e4b4">min_element</a> (ForwardIterator first, ForwardIterator last) noexcept -&gt; ForwardIterator</td></tr>
<tr class="memdesc:a41f1e60aa2d0ca23d39bd975ed52e4b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the smallest element in the range [first, last). Elements are compared using operator&lt;.  <a href="#a41f1e60aa2d0ca23d39bd975ed52e4b4">More...</a><br /></td></tr>
<tr class="separator:a41f1e60aa2d0ca23d39bd975ed52e4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae206eeb82f5e460124ce4b40e951fa0d"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Compare &gt; </td></tr>
<tr class="memitem:ae206eeb82f5e460124ce4b40e951fa0d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae206eeb82f5e460124ce4b40e951fa0d">min_element</a> (ForwardIterator first, ForwardIterator last, Compare comp) -&gt; ForwardIterator</td></tr>
<tr class="memdesc:ae206eeb82f5e460124ce4b40e951fa0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the smallest element in the range [first, last). Elements are compared using the given binary comparison function comp.  <a href="#ae206eeb82f5e460124ce4b40e951fa0d">More...</a><br /></td></tr>
<tr class="separator:ae206eeb82f5e460124ce4b40e951fa0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90379160c94dc0396b5f32204c790bf"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:af90379160c94dc0396b5f32204c790bf"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af90379160c94dc0396b5f32204c790bf">clamp</a> (Type const &amp;v, Type const &amp;lo, Type const &amp;hi) noexcept -&gt; Type const &amp;</td></tr>
<tr class="memdesc:af90379160c94dc0396b5f32204c790bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">If v compares less than lo, returns lo; otherwise if hi compares less than v, returns hi; otherwise returns v. Uses operator&lt; to compare the values.  <a href="#af90379160c94dc0396b5f32204c790bf">More...</a><br /></td></tr>
<tr class="separator:af90379160c94dc0396b5f32204c790bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa416a307b0bb33666d34845c42ba2b"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Compare &gt; </td></tr>
<tr class="memitem:abfa416a307b0bb33666d34845c42ba2b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abfa416a307b0bb33666d34845c42ba2b">clamp</a> (Type const &amp;v, Type const &amp;lo, Type const &amp;hi, Compare comp) -&gt; Type const &amp;</td></tr>
<tr class="separator:abfa416a307b0bb33666d34845c42ba2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b7eed2eaa0b58da478a2d559164bb4"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:ad9b7eed2eaa0b58da478a2d559164bb4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad9b7eed2eaa0b58da478a2d559164bb4">all_of</a> (InputIt first, InputIt last, UnaryPredicate p) -&gt; bool</td></tr>
<tr class="memdesc:ad9b7eed2eaa0b58da478a2d559164bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate p returns true for all elements in the range [first, last).  <a href="#ad9b7eed2eaa0b58da478a2d559164bb4">More...</a><br /></td></tr>
<tr class="separator:ad9b7eed2eaa0b58da478a2d559164bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74cda9bdcb48dfe219176e8fbe4f3aa6"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a74cda9bdcb48dfe219176e8fbe4f3aa6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a74cda9bdcb48dfe219176e8fbe4f3aa6">any_of</a> (InputIt first, InputIt last, UnaryPredicate p) -&gt; bool</td></tr>
<tr class="memdesc:a74cda9bdcb48dfe219176e8fbe4f3aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate p returns true for at least one element in the range [first, last).  <a href="#a74cda9bdcb48dfe219176e8fbe4f3aa6">More...</a><br /></td></tr>
<tr class="separator:a74cda9bdcb48dfe219176e8fbe4f3aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add22a48a49c792039e0d0ec1eef5528b"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:add22a48a49c792039e0d0ec1eef5528b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#add22a48a49c792039e0d0ec1eef5528b">none_of</a> (InputIt first, InputIt last, UnaryPredicate p) -&gt; bool</td></tr>
<tr class="memdesc:add22a48a49c792039e0d0ec1eef5528b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate p returns true for no elements in the range [first, last).  <a href="#add22a48a49c792039e0d0ec1eef5528b">More...</a><br /></td></tr>
<tr class="separator:add22a48a49c792039e0d0ec1eef5528b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9590c66ecd3e2668da22396b36470994"><td class="memTemplParams" colspan="2">template&lt;typename BidirIter &gt; </td></tr>
<tr class="memitem:a9590c66ecd3e2668da22396b36470994"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9590c66ecd3e2668da22396b36470994">reverse</a> (BidirIter first, BidirIter last) -&gt; void</td></tr>
<tr class="memdesc:a9590c66ecd3e2668da22396b36470994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the order of the elements in the range [first, last). Behaves as if applying <a class="el" href="namespaceetl.html#aa18b878794474881fce640e7a163abf3" title="Swaps the values of the elements the given iterators are pointing to. ">etl::iter_swap</a> to every pair of iterators first+i, (last-i) - 1 for each non-negative i &lt; (last-first)/2.  <a href="#a9590c66ecd3e2668da22396b36470994">More...</a><br /></td></tr>
<tr class="separator:a9590c66ecd3e2668da22396b36470994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbd6a789b8ca03eeb582c7e2cb433e4"><td class="memTemplParams" colspan="2">template&lt;typename BidirIter , typename OutputIter &gt; </td></tr>
<tr class="memitem:a9cbd6a789b8ca03eeb582c7e2cb433e4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9cbd6a789b8ca03eeb582c7e2cb433e4">reverse_copy</a> (BidirIter first, BidirIter last, OutputIter destination) -&gt; OutputIter</td></tr>
<tr class="memdesc:a9cbd6a789b8ca03eeb582c7e2cb433e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range [ <code>first</code>, <code>last</code> ) to another range beginning at d_first in such a way that the elements in the new range are in reverse order.  <a href="#a9cbd6a789b8ca03eeb582c7e2cb433e4">More...</a><br /></td></tr>
<tr class="separator:a9cbd6a789b8ca03eeb582c7e2cb433e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c225b4298d1c3ad6d3d17d92fd865b5"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt &gt; </td></tr>
<tr class="memitem:a6c225b4298d1c3ad6d3d17d92fd865b5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6c225b4298d1c3ad6d3d17d92fd865b5">rotate</a> (ForwardIt first, ForwardIt n_first, ForwardIt last) -&gt; ForwardIt</td></tr>
<tr class="memdesc:a6c225b4298d1c3ad6d3d17d92fd865b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a left rotation on a range of elements.  <a href="#a6c225b4298d1c3ad6d3d17d92fd865b5">More...</a><br /></td></tr>
<tr class="separator:a6c225b4298d1c3ad6d3d17d92fd865b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b71bc0359b4e8144996d1a1ea271d46"><td class="memTemplParams" colspan="2">template&lt;class ForwardIter , class BinaryPredicate &gt; </td></tr>
<tr class="memitem:a9b71bc0359b4e8144996d1a1ea271d46"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9b71bc0359b4e8144996d1a1ea271d46">unique</a> (ForwardIter first, ForwardIter last, BinaryPredicate pred) -&gt; ForwardIter</td></tr>
<tr class="memdesc:a9b71bc0359b4e8144996d1a1ea271d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminates all except the first element from every consecutive group of equivalent elements from the range [first, last) and returns a past-the-end iterator for the new logical end of the range.  <a href="#a9b71bc0359b4e8144996d1a1ea271d46">More...</a><br /></td></tr>
<tr class="separator:a9b71bc0359b4e8144996d1a1ea271d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825f3aafcdce4f906287730fe3a44709"><td class="memTemplParams" colspan="2">template&lt;class ForwardIter &gt; </td></tr>
<tr class="memitem:a825f3aafcdce4f906287730fe3a44709"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a825f3aafcdce4f906287730fe3a44709">unique</a> (ForwardIter first, ForwardIter last) -&gt; ForwardIter</td></tr>
<tr class="memdesc:a825f3aafcdce4f906287730fe3a44709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminates all except the first element from every consecutive group of equivalent elements from the range [first, last) and returns a past-the-end iterator for the new logical end of the range.  <a href="#a825f3aafcdce4f906287730fe3a44709">More...</a><br /></td></tr>
<tr class="separator:a825f3aafcdce4f906287730fe3a44709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c85c3f38fdc2e8f49bdb6c5e5dea43"><td class="memTemplParams" colspan="2">template&lt;typename InputIter , typename OutputIter , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ad7c85c3f38fdc2e8f49bdb6c5e5dea43"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad7c85c3f38fdc2e8f49bdb6c5e5dea43">unique_copy</a> (InputIter first, InputIter last, OutputIter destination, BinaryPredicate pred) -&gt; OutputIter</td></tr>
<tr class="memdesc:ad7c85c3f38fdc2e8f49bdb6c5e5dea43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range [first, last), to another range beginning at d_first in such a way that there are no consecutive equal elements. Only the first element of each group of equal elements is copied.  <a href="#ad7c85c3f38fdc2e8f49bdb6c5e5dea43">More...</a><br /></td></tr>
<tr class="separator:ad7c85c3f38fdc2e8f49bdb6c5e5dea43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75adac4ca1890a2c3dee203f76fee1bf"><td class="memTemplParams" colspan="2">template&lt;class InputIter , class OutputIter &gt; </td></tr>
<tr class="memitem:a75adac4ca1890a2c3dee203f76fee1bf"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a75adac4ca1890a2c3dee203f76fee1bf">unique_copy</a> (InputIter first, InputIter last, OutputIter destination) -&gt; OutputIter</td></tr>
<tr class="memdesc:a75adac4ca1890a2c3dee203f76fee1bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range [first, last), to another range beginning at d_first in such a way that there are no consecutive equal elements. Only the first element of each group of equal elements is copied.  <a href="#a75adac4ca1890a2c3dee203f76fee1bf">More...</a><br /></td></tr>
<tr class="separator:a75adac4ca1890a2c3dee203f76fee1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90bcaf1e13dfc47ddc7a62033d7cedc"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:aa90bcaf1e13dfc47ddc7a62033d7cedc"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa90bcaf1e13dfc47ddc7a62033d7cedc">partition</a> (ForwardIt first, ForwardIt last, UnaryPredicate p) -&gt; ForwardIt</td></tr>
<tr class="memdesc:aa90bcaf1e13dfc47ddc7a62033d7cedc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders the elements in the range [first, last) in such a way that all elements for which the predicate p returns true precede the elements for which predicate p returns false. Relative order of the elements is not preserved.  <a href="#aa90bcaf1e13dfc47ddc7a62033d7cedc">More...</a><br /></td></tr>
<tr class="separator:aa90bcaf1e13dfc47ddc7a62033d7cedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120f5d964cae523ab637a2ec068011e4"><td class="memTemplParams" colspan="2">template&lt;typename BidirIt , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a120f5d964cae523ab637a2ec068011e4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a120f5d964cae523ab637a2ec068011e4">stable_partition</a> (BidirIt f, BidirIt l, UnaryPredicate p) -&gt; BidirIt</td></tr>
<tr class="memdesc:a120f5d964cae523ab637a2ec068011e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders the elements in the range [first, last) in such a way that all elements for which the predicate p returns true precede the elements for which predicate p returns false. Relative order of the elements is preserved.  <a href="#a120f5d964cae523ab637a2ec068011e4">More...</a><br /></td></tr>
<tr class="separator:a120f5d964cae523ab637a2ec068011e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3271ee1abafc543f4bf69cc20b01ded"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename OutputIt &gt; </td></tr>
<tr class="memitem:ad3271ee1abafc543f4bf69cc20b01ded"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad3271ee1abafc543f4bf69cc20b01ded">copy</a> (InputIt first, InputIt last, OutputIt destination) -&gt; OutputIt</td></tr>
<tr class="memdesc:ad3271ee1abafc543f4bf69cc20b01ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements in the range, defined by [first, last), to another range beginning at destination.  <a href="#ad3271ee1abafc543f4bf69cc20b01ded">More...</a><br /></td></tr>
<tr class="separator:ad3271ee1abafc543f4bf69cc20b01ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2066fbbe3ee185ee159011308414d8ed"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename OutputIt , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a2066fbbe3ee185ee159011308414d8ed"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2066fbbe3ee185ee159011308414d8ed">copy_if</a> (InputIt first, InputIt last, OutputIt d_first, UnaryPredicate pred) -&gt; OutputIt</td></tr>
<tr class="memdesc:a2066fbbe3ee185ee159011308414d8ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements in the range, defined by [first, last), to another range beginning at destination.  <a href="#a2066fbbe3ee185ee159011308414d8ed">More...</a><br /></td></tr>
<tr class="separator:a2066fbbe3ee185ee159011308414d8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65063d9f87cd088156f3d49bb32f2e5"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Size , typename OutputIt &gt; </td></tr>
<tr class="memitem:aa65063d9f87cd088156f3d49bb32f2e5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa65063d9f87cd088156f3d49bb32f2e5">copy_n</a> (InputIt first, Size <a class="el" href="namespaceetl.html#afe8c29a359a0bffc469225b6aeb0ae64">count</a>, OutputIt result) -&gt; OutputIt</td></tr>
<tr class="memdesc:aa65063d9f87cd088156f3d49bb32f2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies exactly count values from the range beginning at first to the range beginning at result. Formally, for each integer 0  i &lt; count, performs *(result + i) = *(first + i). Overlap of ranges is formally permitted, but leads to unpredictable ordering of the results.  <a href="#aa65063d9f87cd088156f3d49bb32f2e5">More...</a><br /></td></tr>
<tr class="separator:aa65063d9f87cd088156f3d49bb32f2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cac48e35a645442922221597ece14b1"><td class="memTemplParams" colspan="2">template&lt;typename BidirIt1 , typename BidirIt2 &gt; </td></tr>
<tr class="memitem:a9cac48e35a645442922221597ece14b1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9cac48e35a645442922221597ece14b1">copy_backward</a> (BidirIt1 first, BidirIt1 last, BidirIt2 d_last) -&gt; BidirIt2</td></tr>
<tr class="memdesc:a9cac48e35a645442922221597ece14b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the range, defined by [first, last), to another range ending at d_last. The elements are copied in reverse order (the last element is copied first), but their relative order is preserved.  <a href="#a9cac48e35a645442922221597ece14b1">More...</a><br /></td></tr>
<tr class="separator:a9cac48e35a645442922221597ece14b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11bb84e871a5db6b2a230e5ef065234"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename T &gt; </td></tr>
<tr class="memitem:aa11bb84e871a5db6b2a230e5ef065234"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa11bb84e871a5db6b2a230e5ef065234">fill</a> (ForwardIt first, ForwardIt last, T const &amp;value) -&gt; void</td></tr>
<tr class="memdesc:aa11bb84e871a5db6b2a230e5ef065234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the given value to the elements in the range [first, last).  <a href="#aa11bb84e871a5db6b2a230e5ef065234">More...</a><br /></td></tr>
<tr class="separator:aa11bb84e871a5db6b2a230e5ef065234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee66cde5734c21ca66a2e818a82f5dd"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:a1ee66cde5734c21ca66a2e818a82f5dd"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1ee66cde5734c21ca66a2e818a82f5dd">equal</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, BinaryPredicate p) -&gt; bool</td></tr>
<tr class="memdesc:a1ee66cde5734c21ca66a2e818a82f5dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the range [first1, last1) is equal to the range [first2, first2.  <a href="#a1ee66cde5734c21ca66a2e818a82f5dd">More...</a><br /></td></tr>
<tr class="separator:a1ee66cde5734c21ca66a2e818a82f5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934bfc901fe1ed60e93f7f9b9fb34079"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 &gt; </td></tr>
<tr class="memitem:a934bfc901fe1ed60e93f7f9b9fb34079"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a934bfc901fe1ed60e93f7f9b9fb34079">equal</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2) -&gt; bool</td></tr>
<tr class="memdesc:a934bfc901fe1ed60e93f7f9b9fb34079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the range [first1, last1) is equal to the range [first2, first2.  <a href="#a934bfc901fe1ed60e93f7f9b9fb34079">More...</a><br /></td></tr>
<tr class="separator:a934bfc901fe1ed60e93f7f9b9fb34079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ede11426eb69032bea8482caa55d51"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ab1ede11426eb69032bea8482caa55d51"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab1ede11426eb69032bea8482caa55d51">equal</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, BinaryPredicate p) -&gt; bool</td></tr>
<tr class="memdesc:ab1ede11426eb69032bea8482caa55d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the range [first1, last1) is equal to the range [first2, last2), and false otherwise.  <a href="#ab1ede11426eb69032bea8482caa55d51">More...</a><br /></td></tr>
<tr class="separator:ab1ede11426eb69032bea8482caa55d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19bb44dc832eef8b58d30b1cc70411ff"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 &gt; </td></tr>
<tr class="memitem:a19bb44dc832eef8b58d30b1cc70411ff"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a19bb44dc832eef8b58d30b1cc70411ff">equal</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2) -&gt; bool</td></tr>
<tr class="memdesc:a19bb44dc832eef8b58d30b1cc70411ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the range [first1, last1) is equal to the range [first2, last2), and false otherwise.  <a href="#a19bb44dc832eef8b58d30b1cc70411ff">More...</a><br /></td></tr>
<tr class="separator:a19bb44dc832eef8b58d30b1cc70411ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5ebb5d35320f153506765261d81a03"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename Compare &gt; </td></tr>
<tr class="memitem:afe5ebb5d35320f153506765261d81a03"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afe5ebb5d35320f153506765261d81a03">lexicographical_compare</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, Compare comp) -&gt; bool</td></tr>
<tr class="memdesc:afe5ebb5d35320f153506765261d81a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the first range [first1, last1) is lexicographically less than the second range [first2, last2). Elements are compared using the given binary comparison function comp.  <a href="#afe5ebb5d35320f153506765261d81a03">More...</a><br /></td></tr>
<tr class="separator:afe5ebb5d35320f153506765261d81a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae627d43cafd94be503c4082795951f33"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 &gt; </td></tr>
<tr class="memitem:ae627d43cafd94be503c4082795951f33"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae627d43cafd94be503c4082795951f33">lexicographical_compare</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2) -&gt; bool</td></tr>
<tr class="memdesc:ae627d43cafd94be503c4082795951f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the first range [first1, last1) is lexicographically less than the second range [first2, last2). Elements are compared using operator&lt;.  <a href="#ae627d43cafd94be503c4082795951f33">More...</a><br /></td></tr>
<tr class="separator:ae627d43cafd94be503c4082795951f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda62f64ad31faeb43dab1bbe8b2a664"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt , typename Compare &gt; </td></tr>
<tr class="memitem:adda62f64ad31faeb43dab1bbe8b2a664"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adda62f64ad31faeb43dab1bbe8b2a664">sort</a> (RandomIt first, RandomIt last, Compare comp) -&gt; void</td></tr>
<tr class="memdesc:adda62f64ad31faeb43dab1bbe8b2a664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range [first, last) in non-descending order. The order of equal elements is not guaranteed to be preserved.  <a href="#adda62f64ad31faeb43dab1bbe8b2a664">More...</a><br /></td></tr>
<tr class="separator:adda62f64ad31faeb43dab1bbe8b2a664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29031b0fee25653ff42e6fab29670267"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt &gt; </td></tr>
<tr class="memitem:a29031b0fee25653ff42e6fab29670267"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a29031b0fee25653ff42e6fab29670267">sort</a> (RandomIt first, RandomIt last) -&gt; void</td></tr>
<tr class="memdesc:a29031b0fee25653ff42e6fab29670267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range [first, last) in non-descending order. The order of equal elements is not guaranteed to be preserved. Elements are compared using operator&lt;.  <a href="#a29031b0fee25653ff42e6fab29670267">More...</a><br /></td></tr>
<tr class="separator:a29031b0fee25653ff42e6fab29670267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d06375f6c6ee1b6ffe30e433b5ca742"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIter &gt; </td></tr>
<tr class="memitem:a3d06375f6c6ee1b6ffe30e433b5ca742"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3d06375f6c6ee1b6ffe30e433b5ca742">is_sorted_until</a> (ForwardIter first, ForwardIter last) -&gt; ForwardIter</td></tr>
<tr class="memdesc:a3d06375f6c6ee1b6ffe30e433b5ca742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Examines the range [first, last) and finds the largest range beginning at first in which the elements are sorted in non-descending order. Elements are compared using operator&lt;.  <a href="#a3d06375f6c6ee1b6ffe30e433b5ca742">More...</a><br /></td></tr>
<tr class="separator:a3d06375f6c6ee1b6ffe30e433b5ca742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8cd072db84b3726ff5ff9734f09c81e"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIter , typename Compare &gt; </td></tr>
<tr class="memitem:af8cd072db84b3726ff5ff9734f09c81e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af8cd072db84b3726ff5ff9734f09c81e">is_sorted_until</a> (ForwardIter first, ForwardIter last, Compare comp) -&gt; ForwardIter</td></tr>
<tr class="memdesc:af8cd072db84b3726ff5ff9734f09c81e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Examines the range [first, last) and finds the largest range beginning at first in which the elements are sorted in non-descending order. Elements are compared using the given binary comparison function comp.  <a href="#af8cd072db84b3726ff5ff9734f09c81e">More...</a><br /></td></tr>
<tr class="separator:af8cd072db84b3726ff5ff9734f09c81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab088a74d056814b99f64cba7c31cef"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIter &gt; </td></tr>
<tr class="memitem:aaab088a74d056814b99f64cba7c31cef"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aaab088a74d056814b99f64cba7c31cef">is_sorted</a> (ForwardIter first, ForwardIter last) -&gt; bool</td></tr>
<tr class="memdesc:aaab088a74d056814b99f64cba7c31cef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the elements in range [first, last) are sorted in non-descending order. Elements are compared using operator&lt;.  <a href="#aaab088a74d056814b99f64cba7c31cef">More...</a><br /></td></tr>
<tr class="separator:aaab088a74d056814b99f64cba7c31cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a93174fd55dba4449e55dd3accbd299"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIter , typename Compare &gt; </td></tr>
<tr class="memitem:a5a93174fd55dba4449e55dd3accbd299"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5a93174fd55dba4449e55dd3accbd299">is_sorted</a> (ForwardIter first, ForwardIter last, Compare comp) -&gt; bool</td></tr>
<tr class="memdesc:a5a93174fd55dba4449e55dd3accbd299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the elements in range [first, last) are sorted in non-descending order. Elements are compared using the given binary comparison function comp.  <a href="#a5a93174fd55dba4449e55dd3accbd299">More...</a><br /></td></tr>
<tr class="separator:a5a93174fd55dba4449e55dd3accbd299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7d9a038b385aff889235d470b837e4"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 &gt; </td></tr>
<tr class="memitem:acc7d9a038b385aff889235d470b837e4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#acc7d9a038b385aff889235d470b837e4">includes</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2) -&gt; bool</td></tr>
<tr class="memdesc:acc7d9a038b385aff889235d470b837e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the sorted range [first2, last2) is a subsequence of the sorted range [first1, last1). Both ranges must be sorted with operator&lt;.  <a href="#acc7d9a038b385aff889235d470b837e4">More...</a><br /></td></tr>
<tr class="separator:acc7d9a038b385aff889235d470b837e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f97df033ed5dc7c5458f991078633d9"><td class="memTemplParams" colspan="2">template&lt;typename InputIt1 , typename InputIt2 , typename Compare &gt; </td></tr>
<tr class="memitem:a2f97df033ed5dc7c5458f991078633d9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2f97df033ed5dc7c5458f991078633d9">includes</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, Compare comp) -&gt; bool</td></tr>
<tr class="memdesc:a2f97df033ed5dc7c5458f991078633d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the sorted range [first2, last2) is a subsequence of the sorted range [first1, last1). Both ranges must be sorted with the given comparison function comp.  <a href="#a2f97df033ed5dc7c5458f991078633d9">More...</a><br /></td></tr>
<tr class="separator:a2f97df033ed5dc7c5458f991078633d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f31d2c1983d613a5b1be68a431cfd13"><td class="memTemplParams" colspan="2">template&lt;class T , etl::size_t N&gt; </td></tr>
<tr class="memitem:a0f31d2c1983d613a5b1be68a431cfd13"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0f31d2c1983d613a5b1be68a431cfd13">swap</a> (<a class="el" href="structetl_1_1array.html">etl::array</a>&lt; T, N &gt; &amp;lhs, <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; T, N &gt; &amp;rhs) noexcept(noexcept(lhs.swap(rhs))) -&gt; void</td></tr>
<tr class="memdesc:a0f31d2c1983d613a5b1be68a431cfd13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes the <a class="el" href="namespaceetl.html#a0a1c3baeebc248b3f787a308af595c6a" title="Exchanges the given values. Swaps the values a and b. This overload does not participate in overload ...">etl::swap</a> algorithm for <a class="el" href="structetl_1_1array.html" title="etl::array is a container that encapsulates fixed size arrays. ">etl::array</a>. Swaps the contents of lhs and rhs.  <a href="#a0f31d2c1983d613a5b1be68a431cfd13">More...</a><br /></td></tr>
<tr class="separator:a0f31d2c1983d613a5b1be68a431cfd13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd14c4b2bb371a67b0b7e5359471eb58"><td class="memTemplParams" colspan="2">template&lt;class T , etl::size_t N&gt; </td></tr>
<tr class="memitem:acd14c4b2bb371a67b0b7e5359471eb58"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#acd14c4b2bb371a67b0b7e5359471eb58">operator==</a> (<a class="el" href="structetl_1_1array.html">etl::array</a>&lt; T, N &gt; const &amp;lhs, <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; T, N &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:acd14c4b2bb371a67b0b7e5359471eb58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of lhs and rhs are equal, that is, they have the same number of elements and each element in lhs compares equal with the element in rhs at the same position.  <a href="#acd14c4b2bb371a67b0b7e5359471eb58">More...</a><br /></td></tr>
<tr class="separator:acd14c4b2bb371a67b0b7e5359471eb58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295bd71db44f0eff27e67e5767360cdc"><td class="memTemplParams" colspan="2">template&lt;class T , etl::size_t N&gt; </td></tr>
<tr class="memitem:a295bd71db44f0eff27e67e5767360cdc"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a295bd71db44f0eff27e67e5767360cdc">operator!=</a> (<a class="el" href="structetl_1_1array.html">etl::array</a>&lt; T, N &gt; const &amp;lhs, <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; T, N &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:a295bd71db44f0eff27e67e5767360cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of lhs and rhs lexicographically. The comparison is performed by a function equivalent to <a class="el" href="namespaceetl.html#afe5ebb5d35320f153506765261d81a03" title="Checks if the first range [first1, last1) is lexicographically less than the second range [first2...">etl::lexicographical_compare</a>.  <a href="#a295bd71db44f0eff27e67e5767360cdc">More...</a><br /></td></tr>
<tr class="separator:a295bd71db44f0eff27e67e5767360cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e223941035502e547d8793e780a8e6"><td class="memTemplParams" colspan="2">template&lt;class T , etl::size_t N&gt; </td></tr>
<tr class="memitem:a92e223941035502e547d8793e780a8e6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a92e223941035502e547d8793e780a8e6">operator&lt;</a> (<a class="el" href="structetl_1_1array.html">etl::array</a>&lt; T, N &gt; const &amp;lhs, <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; T, N &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:a92e223941035502e547d8793e780a8e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of lhs and rhs lexicographically. The comparison is performed by a function equivalent to <a class="el" href="namespaceetl.html#afe5ebb5d35320f153506765261d81a03" title="Checks if the first range [first1, last1) is lexicographically less than the second range [first2...">etl::lexicographical_compare</a>.  <a href="#a92e223941035502e547d8793e780a8e6">More...</a><br /></td></tr>
<tr class="separator:a92e223941035502e547d8793e780a8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ed5e457d650aa10897012d52cd42fa"><td class="memTemplParams" colspan="2">template&lt;class T , etl::size_t N&gt; </td></tr>
<tr class="memitem:ab2ed5e457d650aa10897012d52cd42fa"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab2ed5e457d650aa10897012d52cd42fa">operator&lt;=</a> (<a class="el" href="structetl_1_1array.html">etl::array</a>&lt; T, N &gt; const &amp;lhs, <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; T, N &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:ab2ed5e457d650aa10897012d52cd42fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of lhs and rhs lexicographically. The comparison is performed by a function equivalent to <a class="el" href="namespaceetl.html#afe5ebb5d35320f153506765261d81a03" title="Checks if the first range [first1, last1) is lexicographically less than the second range [first2...">etl::lexicographical_compare</a>.  <a href="#ab2ed5e457d650aa10897012d52cd42fa">More...</a><br /></td></tr>
<tr class="separator:ab2ed5e457d650aa10897012d52cd42fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2006aed7a710a77f2d7fff71d49a03"><td class="memTemplParams" colspan="2">template&lt;class T , etl::size_t N&gt; </td></tr>
<tr class="memitem:a1b2006aed7a710a77f2d7fff71d49a03"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1b2006aed7a710a77f2d7fff71d49a03">operator&gt;</a> (<a class="el" href="structetl_1_1array.html">etl::array</a>&lt; T, N &gt; const &amp;lhs, <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; T, N &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:a1b2006aed7a710a77f2d7fff71d49a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of lhs and rhs lexicographically. The comparison is performed by a function equivalent to <a class="el" href="namespaceetl.html#afe5ebb5d35320f153506765261d81a03" title="Checks if the first range [first1, last1) is lexicographically less than the second range [first2...">etl::lexicographical_compare</a>.  <a href="#a1b2006aed7a710a77f2d7fff71d49a03">More...</a><br /></td></tr>
<tr class="separator:a1b2006aed7a710a77f2d7fff71d49a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963d59bdcd892d002ca5733c2627cff4"><td class="memTemplParams" colspan="2">template&lt;class T , etl::size_t N&gt; </td></tr>
<tr class="memitem:a963d59bdcd892d002ca5733c2627cff4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a963d59bdcd892d002ca5733c2627cff4">operator&gt;=</a> (<a class="el" href="structetl_1_1array.html">etl::array</a>&lt; T, N &gt; const &amp;lhs, <a class="el" href="structetl_1_1array.html">etl::array</a>&lt; T, N &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:a963d59bdcd892d002ca5733c2627cff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of lhs and rhs lexicographically. The comparison is performed by a function equivalent to <a class="el" href="namespaceetl.html#afe5ebb5d35320f153506765261d81a03" title="Checks if the first range [first1, last1) is lexicographically less than the second range [first2...">etl::lexicographical_compare</a>.  <a href="#a963d59bdcd892d002ca5733c2627cff4">More...</a><br /></td></tr>
<tr class="separator:a963d59bdcd892d002ca5733c2627cff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a13233ebf471c62f35f40b21128884"><td class="memTemplParams" colspan="2">template&lt;class T , class... U&gt; </td></tr>
<tr class="memitem:ae5a13233ebf471c62f35f40b21128884"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae5a13233ebf471c62f35f40b21128884">array</a> (T, U...) -&gt; <a class="el" href="structetl_1_1array.html">array</a>&lt; T, 1+sizeof...(U)&gt;</td></tr>
<tr class="memdesc:ae5a13233ebf471c62f35f40b21128884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide.  <a href="#ae5a13233ebf471c62f35f40b21128884">More...</a><br /></td></tr>
<tr class="separator:ae5a13233ebf471c62f35f40b21128884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae516046f5fb54110a91f5e7759f16240"><td class="memTemplParams" colspan="2">template&lt;class To , class From &gt; </td></tr>
<tr class="memitem:ae516046f5fb54110a91f5e7759f16240"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae516046f5fb54110a91f5e7759f16240">bit_cast</a> (const From &amp;src) noexcept -&gt; typename <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt;(sizeof(To)==sizeof(From)) &amp;&amp;<a class="el" href="namespaceetl.html#a5b3b937c99443cbaf5f1817d061261bd">etl::is_trivially_copyable_v</a>&lt; From &gt; &amp;&amp;<a class="el" href="namespaceetl.html#a5b3b937c99443cbaf5f1817d061261bd">etl::is_trivially_copyable_v</a>&lt; To &gt;, To &gt;</td></tr>
<tr class="memdesc:ae516046f5fb54110a91f5e7759f16240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a value of type To by reinterpreting the object representation of from. Every bit in the value representation of the returned To object is equal to the corresponding bit in the object representation of from.  <a href="#ae516046f5fb54110a91f5e7759f16240">More...</a><br /></td></tr>
<tr class="separator:ae516046f5fb54110a91f5e7759f16240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966b3039757a35f7b1104a7f6c9b6523"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a966b3039757a35f7b1104a7f6c9b6523"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a966b3039757a35f7b1104a7f6c9b6523">popcount</a> (T input) noexcept -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt; detail::is_unsigned_integer&lt; T &gt;::value, int &gt;</td></tr>
<tr class="memdesc:a966b3039757a35f7b1104a7f6c9b6523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of 1 bits in the value of x.  <a href="#a966b3039757a35f7b1104a7f6c9b6523">More...</a><br /></td></tr>
<tr class="separator:a966b3039757a35f7b1104a7f6c9b6523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4fea3bb59d69e9a23786b36024d802a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af4fea3bb59d69e9a23786b36024d802a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af4fea3bb59d69e9a23786b36024d802a">has_single_bit</a> (T x) noexcept -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt; detail::is_unsigned_integer&lt; T &gt;::value, bool &gt;</td></tr>
<tr class="memdesc:af4fea3bb59d69e9a23786b36024d802a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if x is an integral power of two.  <a href="#af4fea3bb59d69e9a23786b36024d802a">More...</a><br /></td></tr>
<tr class="separator:af4fea3bb59d69e9a23786b36024d802a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89028d9dc63da94a3c786df4c0a09f03"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a89028d9dc63da94a3c786df4c0a09f03"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a89028d9dc63da94a3c786df4c0a09f03">countl_zero</a> (T x) noexcept -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt; detail::is_unsigned_integer&lt; T &gt;::value, int &gt;</td></tr>
<tr class="memdesc:a89028d9dc63da94a3c786df4c0a09f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of consecutive 0 bits in the value of x, starting from the most significant bit ("left").  <a href="#a89028d9dc63da94a3c786df4c0a09f03">More...</a><br /></td></tr>
<tr class="separator:a89028d9dc63da94a3c786df4c0a09f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036c43ee12867c8bc74fe95022f175c3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a036c43ee12867c8bc74fe95022f175c3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a036c43ee12867c8bc74fe95022f175c3">countl_one</a> (T x) noexcept -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt; detail::is_unsigned_integer&lt; T &gt;::value, int &gt;</td></tr>
<tr class="memdesc:a036c43ee12867c8bc74fe95022f175c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of consecutive 1 ("one") bits in the value of x, starting from the most significant bit ("left").  <a href="#a036c43ee12867c8bc74fe95022f175c3">More...</a><br /></td></tr>
<tr class="separator:a036c43ee12867c8bc74fe95022f175c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9317469178624538d15a8e264d22887a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9317469178624538d15a8e264d22887a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9317469178624538d15a8e264d22887a">bit_width</a> (T x) noexcept -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt; detail::is_unsigned_integer&lt; T &gt;::value, int &gt;</td></tr>
<tr class="memdesc:a9317469178624538d15a8e264d22887a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If x is not zero, calculates the number of bits needed to store the value x, that is, 1+log2(x). If x is zero, returns zero.  <a href="#a9317469178624538d15a8e264d22887a">More...</a><br /></td></tr>
<tr class="separator:a9317469178624538d15a8e264d22887a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa84e096751094f12fc96460addc2483"><td class="memTemplParams" colspan="2">template&lt;typename Integer &gt; </td></tr>
<tr class="memitem:aaa84e096751094f12fc96460addc2483"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aaa84e096751094f12fc96460addc2483">to_integer</a> (<a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> b) noexcept -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt; <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt; Integer &gt;, Integer &gt;</td></tr>
<tr class="memdesc:aaa84e096751094f12fc96460addc2483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: return Integer(b); This overload only participates in overload resolution if <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v&lt;Integer&gt;</a> is true.  <a href="#aaa84e096751094f12fc96460addc2483">More...</a><br /></td></tr>
<tr class="separator:aaa84e096751094f12fc96460addc2483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0480e65e737703d71651dbf0ec77f6be"><td class="memTemplParams" colspan="2">template&lt;class Integer &gt; </td></tr>
<tr class="memitem:a0480e65e737703d71651dbf0ec77f6be"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0480e65e737703d71651dbf0ec77f6be">operator&lt;&lt;</a> (<a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> b, Integer shift) noexcept -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt; <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt; Integer &gt;, <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> &gt;</td></tr>
<tr class="memdesc:a0480e65e737703d71651dbf0ec77f6be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: return <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>(static_cast&lt;unsigned int&gt;(b) &lt;&lt; shift); This overload only participates in overload resolution if <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v&lt;Integer&gt;</a> is true.  <a href="#a0480e65e737703d71651dbf0ec77f6be">More...</a><br /></td></tr>
<tr class="separator:a0480e65e737703d71651dbf0ec77f6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45fcae26cfb190fcc8ea6ab10da01f0"><td class="memTemplParams" colspan="2">template&lt;class Integer &gt; </td></tr>
<tr class="memitem:ac45fcae26cfb190fcc8ea6ab10da01f0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac45fcae26cfb190fcc8ea6ab10da01f0">operator&gt;&gt;</a> (<a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> b, Integer shift) noexcept -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt; <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt; Integer &gt;, <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> &gt;</td></tr>
<tr class="memdesc:ac45fcae26cfb190fcc8ea6ab10da01f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: return <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>(static_cast&lt;unsigned int&gt;(b) &gt;&gt; shift); This overload only participates in overload resolution if <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v&lt;Integer&gt;</a> is true.  <a href="#ac45fcae26cfb190fcc8ea6ab10da01f0">More...</a><br /></td></tr>
<tr class="separator:ac45fcae26cfb190fcc8ea6ab10da01f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d724ccacf75835ddc7e208bf977df9e"><td class="memTemplParams" colspan="2">template&lt;class Integer &gt; </td></tr>
<tr class="memitem:a4d724ccacf75835ddc7e208bf977df9e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4d724ccacf75835ddc7e208bf977df9e">operator&lt;&lt;=</a> (<a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> &amp;b, Integer shift) noexcept -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt; <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt; Integer &gt;, <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> &amp;&gt;</td></tr>
<tr class="memdesc:a4d724ccacf75835ddc7e208bf977df9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: return b = b &lt;&lt; shift; This overload only participates in overload resolution if <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v&lt;Integer&gt;</a> is true.  <a href="#a4d724ccacf75835ddc7e208bf977df9e">More...</a><br /></td></tr>
<tr class="separator:a4d724ccacf75835ddc7e208bf977df9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12556a00fd4d36c275c51643b2c6168a"><td class="memTemplParams" colspan="2">template&lt;class Integer &gt; </td></tr>
<tr class="memitem:a12556a00fd4d36c275c51643b2c6168a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a12556a00fd4d36c275c51643b2c6168a">operator&gt;&gt;=</a> (<a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> &amp;b, Integer shift) noexcept -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt; <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt; Integer &gt;, <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> &amp;&gt;</td></tr>
<tr class="memdesc:a12556a00fd4d36c275c51643b2c6168a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: return b = b &gt;&gt; shift; This overload only participates in overload resolution if <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v&lt;Integer&gt;</a> is true.  <a href="#a12556a00fd4d36c275c51643b2c6168a">More...</a><br /></td></tr>
<tr class="separator:a12556a00fd4d36c275c51643b2c6168a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe220615749beb7a953b281e623e529"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8fe220615749beb7a953b281e623e529">operator|</a> (<a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> l, <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> r) noexcept -&gt; <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a></td></tr>
<tr class="memdesc:a8fe220615749beb7a953b281e623e529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: return <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>(static_cast&lt;unsigned int&gt;(l) | static_cast&lt;unsigned int&gt;(r));.  <a href="#a8fe220615749beb7a953b281e623e529">More...</a><br /></td></tr>
<tr class="separator:a8fe220615749beb7a953b281e623e529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300d68a0b017d8b6f41d000a8800cd77"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a300d68a0b017d8b6f41d000a8800cd77">operator &amp;</a> (<a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> l, <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> r) noexcept -&gt; <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a></td></tr>
<tr class="memdesc:a300d68a0b017d8b6f41d000a8800cd77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: return <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>(static_cast&lt;unsigned int&gt;(l) &amp; static_cast&lt;unsigned int&gt;(r));.  <a href="#a300d68a0b017d8b6f41d000a8800cd77">More...</a><br /></td></tr>
<tr class="separator:a300d68a0b017d8b6f41d000a8800cd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca2f44bc05dd8dbd6f9ea8beadef229"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6ca2f44bc05dd8dbd6f9ea8beadef229">operator^</a> (<a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> l, <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> r) noexcept -&gt; <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a></td></tr>
<tr class="memdesc:a6ca2f44bc05dd8dbd6f9ea8beadef229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: return <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>(static_cast&lt;unsigned int&gt;(l) ^ static_cast&lt;unsigned int&gt;(r));.  <a href="#a6ca2f44bc05dd8dbd6f9ea8beadef229">More...</a><br /></td></tr>
<tr class="separator:a6ca2f44bc05dd8dbd6f9ea8beadef229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb428553f8379a8f3920c202cd85993"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6cb428553f8379a8f3920c202cd85993">operator~</a> (<a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> b) noexcept -&gt; <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a></td></tr>
<tr class="memdesc:a6cb428553f8379a8f3920c202cd85993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: return <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>(~static_cast&lt;unsigned int&gt;(b));.  <a href="#a6cb428553f8379a8f3920c202cd85993">More...</a><br /></td></tr>
<tr class="separator:a6cb428553f8379a8f3920c202cd85993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f53c7f64802ca7093607b55cb86bc6"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a73f53c7f64802ca7093607b55cb86bc6">operator|=</a> (<a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> &amp;l, <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> r) noexcept -&gt; <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> &amp;</td></tr>
<tr class="memdesc:a73f53c7f64802ca7093607b55cb86bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: return l = l | r;.  <a href="#a73f53c7f64802ca7093607b55cb86bc6">More...</a><br /></td></tr>
<tr class="separator:a73f53c7f64802ca7093607b55cb86bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30243ddf0699dede912521c57cb92a25"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a30243ddf0699dede912521c57cb92a25">operator &amp;=</a> (<a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> &amp;l, <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> r) noexcept -&gt; <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> &amp;</td></tr>
<tr class="memdesc:a30243ddf0699dede912521c57cb92a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: return l = l &amp; r;.  <a href="#a30243ddf0699dede912521c57cb92a25">More...</a><br /></td></tr>
<tr class="separator:a30243ddf0699dede912521c57cb92a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0145ea9af63899833b6bf5f9f18fb7c1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0145ea9af63899833b6bf5f9f18fb7c1">operator^=</a> (<a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> &amp;l, <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> r) noexcept -&gt; <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> &amp;</td></tr>
<tr class="memdesc:a0145ea9af63899833b6bf5f9f18fb7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to: return l = l ^ r;.  <a href="#a0145ea9af63899833b6bf5f9f18fb7c1">More...</a><br /></td></tr>
<tr class="separator:a0145ea9af63899833b6bf5f9f18fb7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ef6491e0baea008f09e77e8bdd1893"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a47ef6491e0baea008f09e77e8bdd1893">isinf</a> (float arg) -&gt; bool</td></tr>
<tr class="memdesc:a47ef6491e0baea008f09e77e8bdd1893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg is a positive or negative infinity.  <a href="#a47ef6491e0baea008f09e77e8bdd1893">More...</a><br /></td></tr>
<tr class="separator:a47ef6491e0baea008f09e77e8bdd1893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd9c92fc417d48f3b71a556c288f34d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0bd9c92fc417d48f3b71a556c288f34d">isinf</a> (double arg) -&gt; bool</td></tr>
<tr class="memdesc:a0bd9c92fc417d48f3b71a556c288f34d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg is a positive or negative infinity.  <a href="#a0bd9c92fc417d48f3b71a556c288f34d">More...</a><br /></td></tr>
<tr class="separator:a0bd9c92fc417d48f3b71a556c288f34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac63899ba5cdbbcbe25e867baaa11c8a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aac63899ba5cdbbcbe25e867baaa11c8a">isinf</a> (long double arg) -&gt; bool</td></tr>
<tr class="memdesc:aac63899ba5cdbbcbe25e867baaa11c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg is a positive or negative infinity.  <a href="#aac63899ba5cdbbcbe25e867baaa11c8a">More...</a><br /></td></tr>
<tr class="separator:aac63899ba5cdbbcbe25e867baaa11c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479b0c43cc953cd7843f865e75bdc53b"><td class="memTemplParams" colspan="2">template&lt;typename IntegralType &gt; </td></tr>
<tr class="memitem:a479b0c43cc953cd7843f865e75bdc53b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a479b0c43cc953cd7843f865e75bdc53b">isinf</a> (IntegralType arg) -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt; <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt; IntegralType &gt;, bool &gt;</td></tr>
<tr class="memdesc:a479b0c43cc953cd7843f865e75bdc53b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of overloads or a function template accepting the arg argument of any integral type. Equivalent to cast to double.  <a href="#a479b0c43cc953cd7843f865e75bdc53b">More...</a><br /></td></tr>
<tr class="separator:a479b0c43cc953cd7843f865e75bdc53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605d9e24e916cbbc8f38c7e377eb792d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a605d9e24e916cbbc8f38c7e377eb792d">isnan</a> (float arg) -&gt; bool</td></tr>
<tr class="memdesc:a605d9e24e916cbbc8f38c7e377eb792d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg is a not-a-number (NaN) value.  <a href="#a605d9e24e916cbbc8f38c7e377eb792d">More...</a><br /></td></tr>
<tr class="separator:a605d9e24e916cbbc8f38c7e377eb792d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4da86e5987c4a4fc2368f5195645c3f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac4da86e5987c4a4fc2368f5195645c3f">isnan</a> (double arg) -&gt; bool</td></tr>
<tr class="memdesc:ac4da86e5987c4a4fc2368f5195645c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg is a not-a-number (NaN) value.  <a href="#ac4da86e5987c4a4fc2368f5195645c3f">More...</a><br /></td></tr>
<tr class="separator:ac4da86e5987c4a4fc2368f5195645c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1b06749558d3368fe928aba61d3b46"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5b1b06749558d3368fe928aba61d3b46">isnan</a> (long double arg) -&gt; bool</td></tr>
<tr class="memdesc:a5b1b06749558d3368fe928aba61d3b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg is a not-a-number (NaN) value.  <a href="#a5b1b06749558d3368fe928aba61d3b46">More...</a><br /></td></tr>
<tr class="separator:a5b1b06749558d3368fe928aba61d3b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8337c5b28ae7940b265ee8afe4c328e"><td class="memTemplParams" colspan="2">template&lt;typename IntegralType &gt; </td></tr>
<tr class="memitem:aa8337c5b28ae7940b265ee8afe4c328e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa8337c5b28ae7940b265ee8afe4c328e">isnan</a> (IntegralType arg) -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt; <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt; IntegralType &gt;, bool &gt;</td></tr>
<tr class="memdesc:aa8337c5b28ae7940b265ee8afe4c328e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg is a not-a-number (NaN) value.  <a href="#aa8337c5b28ae7940b265ee8afe4c328e">More...</a><br /></td></tr>
<tr class="separator:aa8337c5b28ae7940b265ee8afe4c328e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80bf904f99630edb18fcb3a07117779f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a80bf904f99630edb18fcb3a07117779f">isfinite</a> (float arg) -&gt; bool</td></tr>
<tr class="memdesc:a80bf904f99630edb18fcb3a07117779f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg has finite value i.e. it is normal, subnormal or zero, but not infinite or NaN.  <a href="#a80bf904f99630edb18fcb3a07117779f">More...</a><br /></td></tr>
<tr class="separator:a80bf904f99630edb18fcb3a07117779f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813ce51b2632847f81eed1858528ff8e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a813ce51b2632847f81eed1858528ff8e">isfinite</a> (double arg) -&gt; bool</td></tr>
<tr class="memdesc:a813ce51b2632847f81eed1858528ff8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg has finite value i.e. it is normal, subnormal or zero, but not infinite or NaN.  <a href="#a813ce51b2632847f81eed1858528ff8e">More...</a><br /></td></tr>
<tr class="separator:a813ce51b2632847f81eed1858528ff8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33b9666e620117df47e7cd5c2faae53"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae33b9666e620117df47e7cd5c2faae53">isfinite</a> (long double arg) -&gt; bool</td></tr>
<tr class="memdesc:ae33b9666e620117df47e7cd5c2faae53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given floating point number arg has finite value i.e. it is normal, subnormal or zero, but not infinite or NaN.  <a href="#ae33b9666e620117df47e7cd5c2faae53">More...</a><br /></td></tr>
<tr class="separator:ae33b9666e620117df47e7cd5c2faae53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b9405fac6c1a10a80eedfbe2a120b6"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a07b9405fac6c1a10a80eedfbe2a120b6">itoa</a> (int val, char *const buffer, int base) -&gt; char *</td></tr>
<tr class="memdesc:a07b9405fac6c1a10a80eedfbe2a120b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an integer value to a null-terminated string using the specified base and stores the result in the array given by str parameter.  <a href="#a07b9405fac6c1a10a80eedfbe2a120b6">More...</a><br /></td></tr>
<tr class="separator:a07b9405fac6c1a10a80eedfbe2a120b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9788f03be1d72496a6c116e12ffd008a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9788f03be1d72496a6c116e12ffd008a">atol</a> (const char *str) -&gt; long</td></tr>
<tr class="memdesc:a9788f03be1d72496a6c116e12ffd008a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the C-string str interpreting its content as an integral number, which is returned as a value of type long int.  <a href="#a9788f03be1d72496a6c116e12ffd008a">More...</a><br /></td></tr>
<tr class="separator:a9788f03be1d72496a6c116e12ffd008a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a28bb04c335112b2c13d676c422e66"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a99a28bb04c335112b2c13d676c422e66">memcpy</a> (void *dest, const void *src, <a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">etl::size_t</a> n) -&gt; void *</td></tr>
<tr class="memdesc:a99a28bb04c335112b2c13d676c422e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the first n bytes pointed to by src to the buffer pointed to by dest. Source and destination may not overlap. If source and destination might overlap, <a class="el" href="namespaceetl.html#a4604077670e2126de4d05e9d4dab2df9" title="Copy the first n bytes pointed to by src to the buffer pointed to by dest. Source and destination may...">memmove()</a> must be used instead.  <a href="#a99a28bb04c335112b2c13d676c422e66">More...</a><br /></td></tr>
<tr class="separator:a99a28bb04c335112b2c13d676c422e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055dc327ea35a394f661ca98bf2b08ad"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a055dc327ea35a394f661ca98bf2b08ad">memset</a> (void *s, int c, <a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">etl::size_t</a> n) -&gt; void *</td></tr>
<tr class="memdesc:a055dc327ea35a394f661ca98bf2b08ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the value of c (converted to an unsigned char) into each of the rst n characters of the object pointed to by s.  <a href="#a055dc327ea35a394f661ca98bf2b08ad">More...</a><br /></td></tr>
<tr class="separator:a055dc327ea35a394f661ca98bf2b08ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4604077670e2126de4d05e9d4dab2df9"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4604077670e2126de4d05e9d4dab2df9">memmove</a> (void *dest, const void *src, <a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">etl::size_t</a> n) -&gt; void *</td></tr>
<tr class="memdesc:a4604077670e2126de4d05e9d4dab2df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the first n bytes pointed to by src to the buffer pointed to by dest. Source and destination may overlap.  <a href="#a4604077670e2126de4d05e9d4dab2df9">More...</a><br /></td></tr>
<tr class="separator:a4604077670e2126de4d05e9d4dab2df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add013e52c2672440c53a8d2c82d4c63a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#add013e52c2672440c53a8d2c82d4c63a">strlen</a> (const char *str) -&gt; <a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">etl::size_t</a></td></tr>
<tr class="memdesc:add013e52c2672440c53a8d2c82d4c63a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the C string str.  <a href="#add013e52c2672440c53a8d2c82d4c63a">More...</a><br /></td></tr>
<tr class="separator:add013e52c2672440c53a8d2c82d4c63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f8423cdd9669ce22e5b258d0755687"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab5f8423cdd9669ce22e5b258d0755687">strcmp</a> (const char *lhs, const char *rhs) -&gt; int</td></tr>
<tr class="memdesc:ab5f8423cdd9669ce22e5b258d0755687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the C string lhs to the C string rhs.  <a href="#ab5f8423cdd9669ce22e5b258d0755687">More...</a><br /></td></tr>
<tr class="separator:ab5f8423cdd9669ce22e5b258d0755687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3031e070c39546444bdd5fda57ead3d2"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a3031e070c39546444bdd5fda57ead3d2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3031e070c39546444bdd5fda57ead3d2">begin</a> (C &amp;c) -&gt; decltype(c.begin())</td></tr>
<tr class="memdesc:a3031e070c39546444bdd5fda57ead3d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning of the given container c or array array. These templates rely on <a class="el" href="namespaceetl.html#ab0330eb79a39a00af31e79ece021f90f" title="Returns an iterator to the beginning of the given container c or array array. These templates rely on...">C::begin()</a> having a reasonable implementation. Returns exactly <a class="el" href="namespaceetl.html#ab0330eb79a39a00af31e79ece021f90f" title="Returns an iterator to the beginning of the given container c or array array. These templates rely on...">c.begin()</a>, which is typically an iterator to the beginning of the sequence represented by c. If C is a standard Container, this returns C::iterator when c is not const-qualified, and C::const_iterator otherwise.  <a href="#a3031e070c39546444bdd5fda57ead3d2">More...</a><br /></td></tr>
<tr class="separator:a3031e070c39546444bdd5fda57ead3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66664547d4c0705247e58b8580e1990e"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a66664547d4c0705247e58b8580e1990e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a66664547d4c0705247e58b8580e1990e">begin</a> (const C &amp;c) -&gt; decltype(c.begin())</td></tr>
<tr class="memdesc:a66664547d4c0705247e58b8580e1990e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning of the given container c or array array. These templates rely on <a class="el" href="namespaceetl.html#ab0330eb79a39a00af31e79ece021f90f" title="Returns an iterator to the beginning of the given container c or array array. These templates rely on...">C::begin()</a> having a reasonable implementation. Returns exactly <a class="el" href="namespaceetl.html#ab0330eb79a39a00af31e79ece021f90f" title="Returns an iterator to the beginning of the given container c or array array. These templates rely on...">c.begin()</a>, which is typically an iterator to the beginning of the sequence represented by c. If C is a standard Container, this returns C::iterator when c is not const-qualified, and C::const_iterator otherwise.  <a href="#a66664547d4c0705247e58b8580e1990e">More...</a><br /></td></tr>
<tr class="separator:a66664547d4c0705247e58b8580e1990e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0330eb79a39a00af31e79ece021f90f"><td class="memTemplParams" colspan="2">template&lt;class T , etl::size_t N&gt; </td></tr>
<tr class="memitem:ab0330eb79a39a00af31e79ece021f90f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab0330eb79a39a00af31e79ece021f90f">begin</a> (T(&amp;<a class="el" href="structetl_1_1array.html">array</a>)[N]) noexcept -&gt; T *</td></tr>
<tr class="memdesc:ab0330eb79a39a00af31e79ece021f90f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning of the given container c or array array. These templates rely on <a class="el" href="namespaceetl.html#ab0330eb79a39a00af31e79ece021f90f" title="Returns an iterator to the beginning of the given container c or array array. These templates rely on...">C::begin()</a> having a reasonable implementation. Returns a pointer to the beginning of the array.  <a href="#ab0330eb79a39a00af31e79ece021f90f">More...</a><br /></td></tr>
<tr class="separator:ab0330eb79a39a00af31e79ece021f90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac530ab34c9d8ef872aeb563f30be8091"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:ac530ab34c9d8ef872aeb563f30be8091"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac530ab34c9d8ef872aeb563f30be8091">cbegin</a> (const C &amp;c) noexcept(noexcept(<a class="el" href="namespaceetl.html#a3031e070c39546444bdd5fda57ead3d2">etl::begin</a>(c))) -&gt; decltype(<a class="el" href="namespaceetl.html#a3031e070c39546444bdd5fda57ead3d2">etl::begin</a>(c))</td></tr>
<tr class="memdesc:ac530ab34c9d8ef872aeb563f30be8091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning of the given container c or array array. These templates rely on <a class="el" href="namespaceetl.html#ab0330eb79a39a00af31e79ece021f90f" title="Returns an iterator to the beginning of the given container c or array array. These templates rely on...">C::begin()</a> having a reasonable implementation. Returns exactly etl::begin(c), with c always treated as const-qualified. If C is a standard Container, this always returns C::const_iterator.  <a href="#ac530ab34c9d8ef872aeb563f30be8091">More...</a><br /></td></tr>
<tr class="separator:ac530ab34c9d8ef872aeb563f30be8091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9eb859a31968a9179b29b638cd054b"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:abf9eb859a31968a9179b29b638cd054b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abf9eb859a31968a9179b29b638cd054b">end</a> (C &amp;c) -&gt; decltype(c.end())</td></tr>
<tr class="memdesc:abf9eb859a31968a9179b29b638cd054b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end (i.e. the element after the last element) of the given container c or array array. These templates rely on <a class="el" href="namespaceetl.html#a6f5d203d41447f951c386a27ef969327" title="Returns an iterator to the end (i.e. the element after the last element) of the given container c or ...">C::end()</a> having a reasonable implementation.  <a href="#abf9eb859a31968a9179b29b638cd054b">More...</a><br /></td></tr>
<tr class="separator:abf9eb859a31968a9179b29b638cd054b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb97ec3cd4ce3928f2e25709ee21afa0"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:afb97ec3cd4ce3928f2e25709ee21afa0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afb97ec3cd4ce3928f2e25709ee21afa0">end</a> (const C &amp;c) -&gt; decltype(c.end())</td></tr>
<tr class="memdesc:afb97ec3cd4ce3928f2e25709ee21afa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end (i.e. the element after the last element) of the given container c or array array. These templates rely on <a class="el" href="namespaceetl.html#a6f5d203d41447f951c386a27ef969327" title="Returns an iterator to the end (i.e. the element after the last element) of the given container c or ...">C::end()</a> having a reasonable implementation.  <a href="#afb97ec3cd4ce3928f2e25709ee21afa0">More...</a><br /></td></tr>
<tr class="separator:afb97ec3cd4ce3928f2e25709ee21afa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5d203d41447f951c386a27ef969327"><td class="memTemplParams" colspan="2">template&lt;class T , etl::size_t N&gt; </td></tr>
<tr class="memitem:a6f5d203d41447f951c386a27ef969327"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6f5d203d41447f951c386a27ef969327">end</a> (T(&amp;<a class="el" href="structetl_1_1array.html">array</a>)[N]) noexcept -&gt; T *</td></tr>
<tr class="memdesc:a6f5d203d41447f951c386a27ef969327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end (i.e. the element after the last element) of the given container c or array array. These templates rely on <a class="el" href="namespaceetl.html#a6f5d203d41447f951c386a27ef969327" title="Returns an iterator to the end (i.e. the element after the last element) of the given container c or ...">C::end()</a> having a reasonable implementation.  <a href="#a6f5d203d41447f951c386a27ef969327">More...</a><br /></td></tr>
<tr class="separator:a6f5d203d41447f951c386a27ef969327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9516c752e87a1cc87e7bc5763b61b7f4"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a9516c752e87a1cc87e7bc5763b61b7f4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9516c752e87a1cc87e7bc5763b61b7f4">cend</a> (const C &amp;c) noexcept(noexcept(<a class="el" href="namespaceetl.html#abf9eb859a31968a9179b29b638cd054b">etl::end</a>(c))) -&gt; decltype(<a class="el" href="namespaceetl.html#abf9eb859a31968a9179b29b638cd054b">etl::end</a>(c))</td></tr>
<tr class="memdesc:a9516c752e87a1cc87e7bc5763b61b7f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end (i.e. the element after the last element) of the given container c or array array. These templates rely on <a class="el" href="namespaceetl.html#a6f5d203d41447f951c386a27ef969327" title="Returns an iterator to the end (i.e. the element after the last element) of the given container c or ...">C::end()</a> having a reasonable implementation.  <a href="#a9516c752e87a1cc87e7bc5763b61b7f4">More...</a><br /></td></tr>
<tr class="separator:a9516c752e87a1cc87e7bc5763b61b7f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3008e042f920b06e2a67b1aa31a1803"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:af3008e042f920b06e2a67b1aa31a1803"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af3008e042f920b06e2a67b1aa31a1803">size</a> (C const &amp;c) noexcept(noexcept(c.size())) -&gt; decltype(c.size())</td></tr>
<tr class="memdesc:af3008e042f920b06e2a67b1aa31a1803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the given container c or array array. Returns <a class="el" href="namespaceetl.html#ac88d35eb701e83ae17b613e3041ef063" title="Returns the size of the given container c or array array. Returns N. ">c.size()</a>, converted to the return type if necessary.  <a href="#af3008e042f920b06e2a67b1aa31a1803">More...</a><br /></td></tr>
<tr class="separator:af3008e042f920b06e2a67b1aa31a1803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88d35eb701e83ae17b613e3041ef063"><td class="memTemplParams" colspan="2">template&lt;class T , etl::size_t N&gt; </td></tr>
<tr class="memitem:ac88d35eb701e83ae17b613e3041ef063"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac88d35eb701e83ae17b613e3041ef063">size</a> (const T(&amp;<a class="el" href="structetl_1_1array.html">array</a>)[N]) noexcept -&gt; <a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">etl::size_t</a></td></tr>
<tr class="memdesc:ac88d35eb701e83ae17b613e3041ef063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the given container c or array array. Returns N.  <a href="#ac88d35eb701e83ae17b613e3041ef063">More...</a><br /></td></tr>
<tr class="separator:ac88d35eb701e83ae17b613e3041ef063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7a0e8153fc36ebd0147b94c7359ae8"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a8a7a0e8153fc36ebd0147b94c7359ae8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8a7a0e8153fc36ebd0147b94c7359ae8">empty</a> (const C &amp;c) noexcept(noexcept(c.empty())) -&gt; decltype(c.empty())</td></tr>
<tr class="memdesc:a8a7a0e8153fc36ebd0147b94c7359ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given container is empty.  <a href="#a8a7a0e8153fc36ebd0147b94c7359ae8">More...</a><br /></td></tr>
<tr class="separator:a8a7a0e8153fc36ebd0147b94c7359ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3868c40892e752ac869410ba4b0f0407"><td class="memTemplParams" colspan="2">template&lt;typename T , etl::size_t N&gt; </td></tr>
<tr class="memitem:a3868c40892e752ac869410ba4b0f0407"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3868c40892e752ac869410ba4b0f0407">empty</a> (T(&amp;<a class="el" href="structetl_1_1array.html">array</a>)[N]) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a3868c40892e752ac869410ba4b0f0407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given container is empty.  <a href="#a3868c40892e752ac869410ba4b0f0407">More...</a><br /></td></tr>
<tr class="separator:a3868c40892e752ac869410ba4b0f0407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259846a061a975e4b40bc6f370701ac6"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a259846a061a975e4b40bc6f370701ac6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a259846a061a975e4b40bc6f370701ac6">data</a> (C &amp;c) noexcept(noexcept(c.data())) -&gt; decltype(c.data())</td></tr>
<tr class="memdesc:a259846a061a975e4b40bc6f370701ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the block of memory containing the elements of the container. Returns <a class="el" href="namespaceetl.html#ad94411a453e2a44d4e6b6bf3160b4cf0" title="Returns a pointer to the block of memory containing the elements of the container. Returns &amp;array[0]. ">c.data()</a>.  <a href="#a259846a061a975e4b40bc6f370701ac6">More...</a><br /></td></tr>
<tr class="separator:a259846a061a975e4b40bc6f370701ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe1659c6a0ad781385c8c81fbd5ce2d"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a1fe1659c6a0ad781385c8c81fbd5ce2d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1fe1659c6a0ad781385c8c81fbd5ce2d">data</a> (const C &amp;c) noexcept(noexcept(c.data())) -&gt; decltype(c.data())</td></tr>
<tr class="memdesc:a1fe1659c6a0ad781385c8c81fbd5ce2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the block of memory containing the elements of the container. Returns <a class="el" href="namespaceetl.html#ad94411a453e2a44d4e6b6bf3160b4cf0" title="Returns a pointer to the block of memory containing the elements of the container. Returns &amp;array[0]. ">c.data()</a>.  <a href="#a1fe1659c6a0ad781385c8c81fbd5ce2d">More...</a><br /></td></tr>
<tr class="separator:a1fe1659c6a0ad781385c8c81fbd5ce2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94411a453e2a44d4e6b6bf3160b4cf0"><td class="memTemplParams" colspan="2">template&lt;typename T , etl::size_t N&gt; </td></tr>
<tr class="memitem:ad94411a453e2a44d4e6b6bf3160b4cf0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad94411a453e2a44d4e6b6bf3160b4cf0">data</a> (T(&amp;<a class="el" href="structetl_1_1array.html">array</a>)[N]) noexcept -&gt; T *</td></tr>
<tr class="memdesc:ad94411a453e2a44d4e6b6bf3160b4cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the block of memory containing the elements of the container. Returns &amp;array[0].  <a href="#ad94411a453e2a44d4e6b6bf3160b4cf0">More...</a><br /></td></tr>
<tr class="separator:ad94411a453e2a44d4e6b6bf3160b4cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45065b143a47fb9249bda8d57ccca63"><td class="memTemplParams" colspan="2">template&lt;class It , class Distance &gt; </td></tr>
<tr class="memitem:ac45065b143a47fb9249bda8d57ccca63"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac45065b143a47fb9249bda8d57ccca63">advance</a> (It &amp;it, Distance n) -&gt; void</td></tr>
<tr class="memdesc:ac45065b143a47fb9249bda8d57ccca63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments given iterator it by n elements. If n is negative, the iterator is decremented. In this case, InputIt must meet the requirements of LegacyBidirectionalIterator, otherwise the behavior is undefined.  <a href="#ac45065b143a47fb9249bda8d57ccca63">More...</a><br /></td></tr>
<tr class="separator:ac45065b143a47fb9249bda8d57ccca63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5fe5f67d90d1f2c3c3d293099fe12e9"><td class="memTemplParams" colspan="2">template&lt;class It &gt; </td></tr>
<tr class="memitem:aa5fe5f67d90d1f2c3c3d293099fe12e9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa5fe5f67d90d1f2c3c3d293099fe12e9">distance</a> (It first, It last) -&gt; typename <a class="el" href="structetl_1_1iterator__traits.html">etl::iterator_traits</a>&lt; It &gt;::difference_type</td></tr>
<tr class="memdesc:aa5fe5f67d90d1f2c3c3d293099fe12e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of hops from first to last.  <a href="#aa5fe5f67d90d1f2c3c3d293099fe12e9">More...</a><br /></td></tr>
<tr class="separator:aa5fe5f67d90d1f2c3c3d293099fe12e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afedaa2543b2404906532e1d425eabbd2"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:afedaa2543b2404906532e1d425eabbd2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afedaa2543b2404906532e1d425eabbd2">next</a> (InputIt it, typename <a class="el" href="structetl_1_1iterator__traits.html">etl::iterator_traits</a>&lt; InputIt &gt;::difference_type n=1) -&gt; InputIt</td></tr>
<tr class="memdesc:afedaa2543b2404906532e1d425eabbd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the nth successor of iterator it.  <a href="#afedaa2543b2404906532e1d425eabbd2">More...</a><br /></td></tr>
<tr class="separator:afedaa2543b2404906532e1d425eabbd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad580aca5d1f9f6d65f28f4270cb765ed"><td class="memTemplParams" colspan="2">template&lt;class BidirIt &gt; </td></tr>
<tr class="memitem:ad580aca5d1f9f6d65f28f4270cb765ed"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad580aca5d1f9f6d65f28f4270cb765ed">prev</a> (BidirIt it, typename <a class="el" href="structetl_1_1iterator__traits.html">etl::iterator_traits</a>&lt; BidirIt &gt;::difference_type n=1) -&gt; BidirIt</td></tr>
<tr class="memdesc:ad580aca5d1f9f6d65f28f4270cb765ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the nth predecessor of iterator it.  <a href="#ad580aca5d1f9f6d65f28f4270cb765ed">More...</a><br /></td></tr>
<tr class="separator:ad580aca5d1f9f6d65f28f4270cb765ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ea18354d7bfc7358bf9c13004f0233"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:ab4ea18354d7bfc7358bf9c13004f0233"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab4ea18354d7bfc7358bf9c13004f0233">back_inserter</a> (Container &amp;container) -&gt; <a class="el" href="classetl_1_1back__insert__iterator.html">back_insert_iterator</a>&lt; Container &gt;</td></tr>
<tr class="separator:ab4ea18354d7bfc7358bf9c13004f0233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e969dbba1b9a1c3889a417e695fb296"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:a1e969dbba1b9a1c3889a417e695fb296"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1e969dbba1b9a1c3889a417e695fb296">front_inserter</a> (Container &amp;c) -&gt; <a class="el" href="classetl_1_1front__insert__iterator.html">etl::front_insert_iterator</a>&lt; Container &gt;</td></tr>
<tr class="memdesc:a1e969dbba1b9a1c3889a417e695fb296"><td class="mdescLeft">&#160;</td><td class="mdescRight">front_inserter is a convenience function template that constructs a <a class="el" href="classetl_1_1front__insert__iterator.html" title="etl::front_insert_iterator is an LegacyOutputIterator that prepends elements to a container for which...">etl::front_insert_iterator</a> for the container c with the type deduced from the type of the argument.  <a href="#a1e969dbba1b9a1c3889a417e695fb296">More...</a><br /></td></tr>
<tr class="separator:a1e969dbba1b9a1c3889a417e695fb296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbedfa50bab7817a29802cce148c7def"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:adbedfa50bab7817a29802cce148c7def"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adbedfa50bab7817a29802cce148c7def">addressof</a> (T &amp;arg) noexcept -&gt; typename <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt; <a class="el" href="namespaceetl.html#a63efd09c0ee7195824be65423adadedc">etl::is_object_v</a>&lt; T &gt;, T *&gt;</td></tr>
<tr class="memdesc:adbedfa50bab7817a29802cce148c7def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the actual address of the object or function arg, even in presence of overloaded operator&amp;.  <a href="#adbedfa50bab7817a29802cce148c7def">More...</a><br /></td></tr>
<tr class="separator:adbedfa50bab7817a29802cce148c7def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13856fe74510e89b04a2310cbc9bde59"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a13856fe74510e89b04a2310cbc9bde59"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a13856fe74510e89b04a2310cbc9bde59">addressof</a> (T const &amp;&amp;)=delete</td></tr>
<tr class="memdesc:a13856fe74510e89b04a2310cbc9bde59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rvalue overload is deleted to prevent taking the address of const rvalues.  <a href="#a13856fe74510e89b04a2310cbc9bde59">More...</a><br /></td></tr>
<tr class="separator:a13856fe74510e89b04a2310cbc9bde59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1709580f4bcc18d6efb2b7e4d5c1b728"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1709580f4bcc18d6efb2b7e4d5c1b728"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1709580f4bcc18d6efb2b7e4d5c1b728">destroy_at</a> (T *p) -&gt; void</td></tr>
<tr class="memdesc:a1709580f4bcc18d6efb2b7e4d5c1b728"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not an array type, calls the destructor of the object pointed to by p, as if by p-&gt;~T(). If T is an array type, recursively destroys elements of *p in order, as if by calling <a class="el" href="namespaceetl.html#ab44bc4884adc1e9dc20ddf2363f3da66" title="Destroys the objects in the range [first, last). ">etl::destroy</a>(etl::begin(*p), etl::end(*p)).  <a href="#a1709580f4bcc18d6efb2b7e4d5c1b728">More...</a><br /></td></tr>
<tr class="separator:a1709580f4bcc18d6efb2b7e4d5c1b728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44bc4884adc1e9dc20ddf2363f3da66"><td class="memTemplParams" colspan="2">template&lt;class ForwardIt &gt; </td></tr>
<tr class="memitem:ab44bc4884adc1e9dc20ddf2363f3da66"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab44bc4884adc1e9dc20ddf2363f3da66">destroy</a> (ForwardIt first, ForwardIt last) -&gt; void</td></tr>
<tr class="memdesc:ab44bc4884adc1e9dc20ddf2363f3da66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the objects in the range [first, last).  <a href="#ab44bc4884adc1e9dc20ddf2363f3da66">More...</a><br /></td></tr>
<tr class="separator:ab44bc4884adc1e9dc20ddf2363f3da66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440d38af8f9b00df3d5c1369450ba44a"><td class="memTemplParams" colspan="2">template&lt;class ForwardIt , class Size &gt; </td></tr>
<tr class="memitem:a440d38af8f9b00df3d5c1369450ba44a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a440d38af8f9b00df3d5c1369450ba44a">destroy_n</a> (ForwardIt first, Size n) -&gt; ForwardIt</td></tr>
<tr class="memdesc:a440d38af8f9b00df3d5c1369450ba44a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the n objects in the range starting at first.  <a href="#a440d38af8f9b00df3d5c1369450ba44a">More...</a><br /></td></tr>
<tr class="separator:a440d38af8f9b00df3d5c1369450ba44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe443a26a34b79fc921c4583df576333"><td class="memTemplParams" colspan="2">template&lt;class InputIt , class Type &gt; </td></tr>
<tr class="memitem:afe443a26a34b79fc921c4583df576333"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afe443a26a34b79fc921c4583df576333">accumulate</a> (InputIt first, InputIt last, Type init) noexcept -&gt; Type</td></tr>
<tr class="memdesc:afe443a26a34b79fc921c4583df576333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of the given value init and the elements in the range [first, last). Uses operator+ to sum up the elements.  <a href="#afe443a26a34b79fc921c4583df576333">More...</a><br /></td></tr>
<tr class="separator:afe443a26a34b79fc921c4583df576333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9413959b7ee39d393e7c35ad2cd78294"><td class="memTemplParams" colspan="2">template&lt;class InputIt , class Type , class BinaryOperation &gt; </td></tr>
<tr class="memitem:a9413959b7ee39d393e7c35ad2cd78294"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9413959b7ee39d393e7c35ad2cd78294">accumulate</a> (InputIt first, InputIt last, Type init, BinaryOperation op) noexcept -&gt; Type</td></tr>
<tr class="memdesc:a9413959b7ee39d393e7c35ad2cd78294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of the given value init and the elements in the range [first, last). Uses the BinaryOperation to sum up the elements.  <a href="#a9413959b7ee39d393e7c35ad2cd78294">More...</a><br /></td></tr>
<tr class="separator:a9413959b7ee39d393e7c35ad2cd78294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594a7b7fb202c9a1b6d82115e7a172e3"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a594a7b7fb202c9a1b6d82115e7a172e3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a594a7b7fb202c9a1b6d82115e7a172e3">abs</a> (Type input) noexcept -&gt; Type</td></tr>
<tr class="memdesc:a594a7b7fb202c9a1b6d82115e7a172e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value.  <a href="#a594a7b7fb202c9a1b6d82115e7a172e3">More...</a><br /></td></tr>
<tr class="separator:a594a7b7fb202c9a1b6d82115e7a172e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44562b8c2da2eb5f51eb8e98d09ea697"><td class="memTemplParams" colspan="2">template&lt;class ForwardIt , class T &gt; </td></tr>
<tr class="memitem:a44562b8c2da2eb5f51eb8e98d09ea697"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a44562b8c2da2eb5f51eb8e98d09ea697">iota</a> (ForwardIt first, ForwardIt last, T value) -&gt; void</td></tr>
<tr class="memdesc:a44562b8c2da2eb5f51eb8e98d09ea697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the range [first, last) with sequentially increasing values, starting with value and repetitively evaluating ++value.  <a href="#a44562b8c2da2eb5f51eb8e98d09ea697">More...</a><br /></td></tr>
<tr class="separator:a44562b8c2da2eb5f51eb8e98d09ea697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b02b91109bd6987f6dd8c0cfe583d5"><td class="memTemplParams" colspan="2">template&lt;class InputIt1 , class InputIt2 , class T &gt; </td></tr>
<tr class="memitem:a42b02b91109bd6987f6dd8c0cfe583d5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a42b02b91109bd6987f6dd8c0cfe583d5">inner_product</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, T init) -&gt; T</td></tr>
<tr class="memdesc:a42b02b91109bd6987f6dd8c0cfe583d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes inner product (i.e. sum of products) or performs ordered map/reduce operation on the range [first1, last1) and the range beginning at first2.  <a href="#a42b02b91109bd6987f6dd8c0cfe583d5">More...</a><br /></td></tr>
<tr class="separator:a42b02b91109bd6987f6dd8c0cfe583d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0039bdc9a6970a2089121ae3ee285b1"><td class="memTemplParams" colspan="2">template&lt;class InputIt1 , class InputIt2 , class T , class BinaryOperation1 , class BinaryOperation2 &gt; </td></tr>
<tr class="memitem:ae0039bdc9a6970a2089121ae3ee285b1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae0039bdc9a6970a2089121ae3ee285b1">inner_product</a> (InputIt1 first1, InputIt1 last1, InputIt2 first2, T init, BinaryOperation1 op1, BinaryOperation2 op2) -&gt; T</td></tr>
<tr class="memdesc:ae0039bdc9a6970a2089121ae3ee285b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes inner product (i.e. sum of products) or performs ordered map/reduce operation on the range [first1, last1) and the range beginning at first2.  <a href="#ae0039bdc9a6970a2089121ae3ee285b1">More...</a><br /></td></tr>
<tr class="separator:ae0039bdc9a6970a2089121ae3ee285b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717726a2fed08cececaa93b504419300"><td class="memTemplParams" colspan="2">template&lt;class InputIt , class OutputIt , class BinaryOperation &gt; </td></tr>
<tr class="memitem:a717726a2fed08cececaa93b504419300"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a717726a2fed08cececaa93b504419300">partial_sum</a> (InputIt first, InputIt last, OutputIt destination, BinaryOperation op) -&gt; OutputIt</td></tr>
<tr class="memdesc:a717726a2fed08cececaa93b504419300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the partial sums of the elements in the subranges of the range [first, last) and writes them to the range beginning at destination. This version uses the given binary function op, both applying <a class="el" href="namespaceetl.html#ad0a5b274f170d18a9e175fddf538a4bc" title="Moves the elements in the range [first, last), to another range beginning at d_first, starting from first and proceeding to last - 1. After this operation the elements in the moved-from range will still contain valid values of the appropriate type, but not necessarily the same values as before the move. ">etl::move</a> to their operands on the left hand side.  <a href="#a717726a2fed08cececaa93b504419300">More...</a><br /></td></tr>
<tr class="separator:a717726a2fed08cececaa93b504419300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d274a25ea5a88eb47898c8832795e3e"><td class="memTemplParams" colspan="2">template&lt;class InputIt , class OutputIt &gt; </td></tr>
<tr class="memitem:a8d274a25ea5a88eb47898c8832795e3e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8d274a25ea5a88eb47898c8832795e3e">partial_sum</a> (InputIt first, InputIt last, OutputIt destination) -&gt; OutputIt</td></tr>
<tr class="memdesc:a8d274a25ea5a88eb47898c8832795e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the partial sums of the elements in the subranges of the range [first, last) and writes them to the range beginning at destination. This version uses operator+ to sum up the elements.  <a href="#a8d274a25ea5a88eb47898c8832795e3e">More...</a><br /></td></tr>
<tr class="separator:a8d274a25ea5a88eb47898c8832795e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65cd6f8748c172eab6ee36130dca3c3"><td class="memTemplParams" colspan="2">template&lt;typename M , typename N &gt; </td></tr>
<tr class="memitem:ab65cd6f8748c172eab6ee36130dca3c3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab65cd6f8748c172eab6ee36130dca3c3">gcd</a> (M m, N n) noexcept -&gt; <a class="el" href="namespaceetl.html#ac80571ce0a1bbafdb4d8e153ceade9e3">etl::common_type_t</a>&lt; M, N &gt;</td></tr>
<tr class="memdesc:ab65cd6f8748c172eab6ee36130dca3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the greatest common divisor of the integers m and n.  <a href="#ab65cd6f8748c172eab6ee36130dca3c3">More...</a><br /></td></tr>
<tr class="separator:ab65cd6f8748c172eab6ee36130dca3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d17ac0d457a45babf1c999ed6bea7f"><td class="memTemplParams" colspan="2">template&lt;class M , class N &gt; </td></tr>
<tr class="memitem:a88d17ac0d457a45babf1c999ed6bea7f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a88d17ac0d457a45babf1c999ed6bea7f">lcm</a> (M m, N n) -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt; <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt; M &gt; &amp;&amp;!<a class="el" href="namespaceetl.html#a3f74da2365a9a6f68d472686fd0f1666">etl::is_same_v</a>&lt; M, bool &gt; &amp;&amp;<a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt; N &gt; &amp;&amp;!<a class="el" href="namespaceetl.html#a3f74da2365a9a6f68d472686fd0f1666">etl::is_same_v</a>&lt; N, bool &gt;, <a class="el" href="namespaceetl.html#ac80571ce0a1bbafdb4d8e153ceade9e3">etl::common_type_t</a>&lt; M, N &gt;&gt;</td></tr>
<tr class="memdesc:a88d17ac0d457a45babf1c999ed6bea7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the least common multiple of the integers m and n.  <a href="#a88d17ac0d457a45babf1c999ed6bea7f">More...</a><br /></td></tr>
<tr class="separator:a88d17ac0d457a45babf1c999ed6bea7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add674d1e1c1fd1d72dd7b39f74a0525a"><td class="memTemplParams" colspan="2">template&lt;typename Integer &gt; </td></tr>
<tr class="memitem:add674d1e1c1fd1d72dd7b39f74a0525a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#add674d1e1c1fd1d72dd7b39f74a0525a">midpoint</a> (Integer a, Integer b) noexcept -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt; <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt; Integer &gt; &amp;&amp;!<a class="el" href="namespaceetl.html#a3f74da2365a9a6f68d472686fd0f1666">etl::is_same_v</a>&lt; Integer, bool &gt;, Integer &gt;</td></tr>
<tr class="memdesc:add674d1e1c1fd1d72dd7b39f74a0525a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns half the sum of a + b. If the sum is odd, the result is rounded towards a.  <a href="#add674d1e1c1fd1d72dd7b39f74a0525a">More...</a><br /></td></tr>
<tr class="separator:add674d1e1c1fd1d72dd7b39f74a0525a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6eb417ecc3a7b1c7e71baab1c2c522"><td class="memTemplParams" colspan="2">template&lt;typename Float &gt; </td></tr>
<tr class="memitem:acd6eb417ecc3a7b1c7e71baab1c2c522"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#acd6eb417ecc3a7b1c7e71baab1c2c522">midpoint</a> (Float a, Float b) noexcept -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt; <a class="el" href="namespaceetl.html#a5cf273d19443134cffcd66310d027ae4">etl::is_floating_point_v</a>&lt; Float &gt;, Float &gt;</td></tr>
<tr class="separator:acd6eb417ecc3a7b1c7e71baab1c2c522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f4c423421fddd2a2f941d805c05300"><td class="memTemplParams" colspan="2">template&lt;typename Pointer &gt; </td></tr>
<tr class="memitem:ad2f4c423421fddd2a2f941d805c05300"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad2f4c423421fddd2a2f941d805c05300">midpoint</a> (Pointer a, Pointer b) noexcept -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt; <a class="el" href="namespaceetl.html#ac00eca7d51c4d2c1021402ee9a70f03c">is_pointer_v</a>&lt; Pointer &gt;, Pointer &gt;</td></tr>
<tr class="separator:ad2f4c423421fddd2a2f941d805c05300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1cc2f7a422e0cadab9361b16f7e875"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a5d1cc2f7a422e0cadab9361b16f7e875"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5d1cc2f7a422e0cadab9361b16f7e875">operator==</a> (<a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;lhs, <a class="el" href="classetl_1_1optional.html">optional</a>&lt; U &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:a5d1cc2f7a422e0cadab9361b16f7e875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two optional objects, lhs and rhs.  <a href="#a5d1cc2f7a422e0cadab9361b16f7e875">More...</a><br /></td></tr>
<tr class="separator:a5d1cc2f7a422e0cadab9361b16f7e875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0199291e596a6580c028a4fbb4c1a439"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a0199291e596a6580c028a4fbb4c1a439"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0199291e596a6580c028a4fbb4c1a439">operator!=</a> (<a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;lhs, <a class="el" href="classetl_1_1optional.html">optional</a>&lt; U &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:a0199291e596a6580c028a4fbb4c1a439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two optional objects, lhs and rhs.  <a href="#a0199291e596a6580c028a4fbb4c1a439">More...</a><br /></td></tr>
<tr class="separator:a0199291e596a6580c028a4fbb4c1a439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2dad36bf3c15c14d239e80047211e27"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ad2dad36bf3c15c14d239e80047211e27"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad2dad36bf3c15c14d239e80047211e27">operator&lt;</a> (<a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;lhs, <a class="el" href="classetl_1_1optional.html">optional</a>&lt; U &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:ad2dad36bf3c15c14d239e80047211e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two optional objects, lhs and rhs.  <a href="#ad2dad36bf3c15c14d239e80047211e27">More...</a><br /></td></tr>
<tr class="separator:ad2dad36bf3c15c14d239e80047211e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cfb4c68d3b5bf2a12e64973a9ee892"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:aa8cfb4c68d3b5bf2a12e64973a9ee892"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa8cfb4c68d3b5bf2a12e64973a9ee892">operator&gt;</a> (<a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;lhs, <a class="el" href="classetl_1_1optional.html">optional</a>&lt; U &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:aa8cfb4c68d3b5bf2a12e64973a9ee892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two optional objects, lhs and rhs.  <a href="#aa8cfb4c68d3b5bf2a12e64973a9ee892">More...</a><br /></td></tr>
<tr class="separator:aa8cfb4c68d3b5bf2a12e64973a9ee892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6d41e110c97a6f118fac996337da06"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:abc6d41e110c97a6f118fac996337da06"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abc6d41e110c97a6f118fac996337da06">operator&lt;=</a> (<a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;lhs, <a class="el" href="classetl_1_1optional.html">optional</a>&lt; U &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:abc6d41e110c97a6f118fac996337da06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two optional objects, lhs and rhs.  <a href="#abc6d41e110c97a6f118fac996337da06">More...</a><br /></td></tr>
<tr class="separator:abc6d41e110c97a6f118fac996337da06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd1c4702ae19a08b1aa3f03807f1267"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a4cd1c4702ae19a08b1aa3f03807f1267"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4cd1c4702ae19a08b1aa3f03807f1267">operator&gt;=</a> (<a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;lhs, <a class="el" href="classetl_1_1optional.html">optional</a>&lt; U &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:a4cd1c4702ae19a08b1aa3f03807f1267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two optional objects, lhs and rhs.  <a href="#a4cd1c4702ae19a08b1aa3f03807f1267">More...</a><br /></td></tr>
<tr class="separator:a4cd1c4702ae19a08b1aa3f03807f1267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb0eb100ae57232d484215f1b4315d6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:afbb0eb100ae57232d484215f1b4315d6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afbb0eb100ae57232d484215f1b4315d6">operator==</a> (<a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;opt, <a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>) noexcept -&gt; bool</td></tr>
<tr class="memdesc:afbb0eb100ae57232d484215f1b4315d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <a href="#afbb0eb100ae57232d484215f1b4315d6">More...</a><br /></td></tr>
<tr class="separator:afbb0eb100ae57232d484215f1b4315d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55bdc0584358e44c777f1ff6dd845026"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a55bdc0584358e44c777f1ff6dd845026"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a55bdc0584358e44c777f1ff6dd845026">operator==</a> (<a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>, <a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;opt) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a55bdc0584358e44c777f1ff6dd845026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <a href="#a55bdc0584358e44c777f1ff6dd845026">More...</a><br /></td></tr>
<tr class="separator:a55bdc0584358e44c777f1ff6dd845026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e737d88ff2f1d432403026a91a24766"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8e737d88ff2f1d432403026a91a24766"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8e737d88ff2f1d432403026a91a24766">operator!=</a> (<a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;opt, <a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a8e737d88ff2f1d432403026a91a24766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <a href="#a8e737d88ff2f1d432403026a91a24766">More...</a><br /></td></tr>
<tr class="separator:a8e737d88ff2f1d432403026a91a24766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6bf68822d73dd9f0d84b6a5aa3f3618"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad6bf68822d73dd9f0d84b6a5aa3f3618"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad6bf68822d73dd9f0d84b6a5aa3f3618">operator!=</a> (<a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>, <a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;opt) noexcept -&gt; bool</td></tr>
<tr class="memdesc:ad6bf68822d73dd9f0d84b6a5aa3f3618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <a href="#ad6bf68822d73dd9f0d84b6a5aa3f3618">More...</a><br /></td></tr>
<tr class="separator:ad6bf68822d73dd9f0d84b6a5aa3f3618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d07feb0fa4c7f8287a166fbbe4975ee"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7d07feb0fa4c7f8287a166fbbe4975ee"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7d07feb0fa4c7f8287a166fbbe4975ee">operator&lt;</a> (<a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;, <a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a7d07feb0fa4c7f8287a166fbbe4975ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <a href="#a7d07feb0fa4c7f8287a166fbbe4975ee">More...</a><br /></td></tr>
<tr class="separator:a7d07feb0fa4c7f8287a166fbbe4975ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b91acd82b61f0b96647711aa1414b71"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0b91acd82b61f0b96647711aa1414b71"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0b91acd82b61f0b96647711aa1414b71">operator&lt;</a> (<a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>, <a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;opt) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a0b91acd82b61f0b96647711aa1414b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <a href="#a0b91acd82b61f0b96647711aa1414b71">More...</a><br /></td></tr>
<tr class="separator:a0b91acd82b61f0b96647711aa1414b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ffa5aed44c30aae39950e0d82c7a256"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0ffa5aed44c30aae39950e0d82c7a256"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0ffa5aed44c30aae39950e0d82c7a256">operator&lt;=</a> (<a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;opt, <a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a0ffa5aed44c30aae39950e0d82c7a256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <a href="#a0ffa5aed44c30aae39950e0d82c7a256">More...</a><br /></td></tr>
<tr class="separator:a0ffa5aed44c30aae39950e0d82c7a256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3003b74d5cf5363cb983a63f0beaa5b8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3003b74d5cf5363cb983a63f0beaa5b8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3003b74d5cf5363cb983a63f0beaa5b8">operator&lt;=</a> (<a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>, <a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a3003b74d5cf5363cb983a63f0beaa5b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <a href="#a3003b74d5cf5363cb983a63f0beaa5b8">More...</a><br /></td></tr>
<tr class="separator:a3003b74d5cf5363cb983a63f0beaa5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ec0f3b39223f0c48dcae6bf744ac8f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa2ec0f3b39223f0c48dcae6bf744ac8f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa2ec0f3b39223f0c48dcae6bf744ac8f">operator&gt;</a> (<a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;opt, <a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>) noexcept -&gt; bool</td></tr>
<tr class="memdesc:aa2ec0f3b39223f0c48dcae6bf744ac8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <a href="#aa2ec0f3b39223f0c48dcae6bf744ac8f">More...</a><br /></td></tr>
<tr class="separator:aa2ec0f3b39223f0c48dcae6bf744ac8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070d0943c411911df11ac5176fa48016"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a070d0943c411911df11ac5176fa48016"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a070d0943c411911df11ac5176fa48016">operator&gt;</a> (<a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>, <a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a070d0943c411911df11ac5176fa48016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <a href="#a070d0943c411911df11ac5176fa48016">More...</a><br /></td></tr>
<tr class="separator:a070d0943c411911df11ac5176fa48016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad322ae7ca3d230a2cfb6aae8d633356b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad322ae7ca3d230a2cfb6aae8d633356b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad322ae7ca3d230a2cfb6aae8d633356b">operator&gt;=</a> (<a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;, <a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>) noexcept -&gt; bool</td></tr>
<tr class="memdesc:ad322ae7ca3d230a2cfb6aae8d633356b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <a href="#ad322ae7ca3d230a2cfb6aae8d633356b">More...</a><br /></td></tr>
<tr class="separator:ad322ae7ca3d230a2cfb6aae8d633356b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe18304d67bab939fd57ac52900323a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8fe18304d67bab939fd57ac52900323a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8fe18304d67bab939fd57ac52900323a">operator&gt;=</a> (<a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>, <a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;opt) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a8fe18304d67bab939fd57ac52900323a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value.  <a href="#a8fe18304d67bab939fd57ac52900323a">More...</a><br /></td></tr>
<tr class="separator:a8fe18304d67bab939fd57ac52900323a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c80d5c10c1a11341e864197c701176"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a43c80d5c10c1a11341e864197c701176"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a43c80d5c10c1a11341e864197c701176">make_optional</a> (ValueType &amp;&amp;value) -&gt; <a class="el" href="classetl_1_1optional.html">etl::optional</a>&lt; <a class="el" href="namespaceetl.html#ad602447fa93ad71f4db547fa0ae92883">etl::decay_t</a>&lt; ValueType &gt;&gt;</td></tr>
<tr class="memdesc:a43c80d5c10c1a11341e864197c701176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed.  <a href="#a43c80d5c10c1a11341e864197c701176">More...</a><br /></td></tr>
<tr class="separator:a43c80d5c10c1a11341e864197c701176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3100dac4a3eddc7d88a828b05513ccc0"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename... Args&gt; </td></tr>
<tr class="memitem:a3100dac4a3eddc7d88a828b05513ccc0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3100dac4a3eddc7d88a828b05513ccc0">make_optional</a> (Args &amp;&amp;... args) -&gt; <a class="el" href="classetl_1_1optional.html">etl::optional</a>&lt; ValueType &gt;</td></tr>
<tr class="memdesc:a3100dac4a3eddc7d88a828b05513ccc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an optional object constructed in-place from args...  <a href="#a3100dac4a3eddc7d88a828b05513ccc0">More...</a><br /></td></tr>
<tr class="separator:a3100dac4a3eddc7d88a828b05513ccc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75cac911cf6d9b9b3b37254bc227e53"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae75cac911cf6d9b9b3b37254bc227e53"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae75cac911cf6d9b9b3b37254bc227e53">optional</a> (T) -&gt; <a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt;</td></tr>
<tr class="memdesc:ae75cac911cf6d9b9b3b37254bc227e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">One deduction guide is provided for <a class="el" href="classetl_1_1optional.html">etl::optional</a> to account for the edge cases missed by the implicit deduction guides, in particular, non-copyable arguments and array to pointer conversion.  <a href="#ae75cac911cf6d9b9b3b37254bc227e53">More...</a><br /></td></tr>
<tr class="separator:ae75cac911cf6d9b9b3b37254bc227e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9320ebd2b7f25fcb308f2dd939d356d"><td class="memTemplParams" colspan="2">template&lt;typename FuncT &gt; </td></tr>
<tr class="memitem:ad9320ebd2b7f25fcb308f2dd939d356d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad9320ebd2b7f25fcb308f2dd939d356d">scope_exit</a> (FuncT) -&gt; <a class="el" href="structetl_1_1scope__exit.html">scope_exit</a>&lt; <a class="el" href="namespaceetl.html#ad602447fa93ad71f4db547fa0ae92883">etl::decay_t</a>&lt; FuncT &gt;&gt;</td></tr>
<tr class="separator:ad9320ebd2b7f25fcb308f2dd939d356d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da3a02a79034271cbc560bc94dbe2cd"><td class="memTemplParams" colspan="2">template&lt;class Type , etl::size_t Extent&gt; </td></tr>
<tr class="memitem:a0da3a02a79034271cbc560bc94dbe2cd"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0da3a02a79034271cbc560bc94dbe2cd">span</a> (Type(&amp;)[Extent]) -&gt; <a class="el" href="classetl_1_1span.html">span</a>&lt; Type, Extent &gt;</td></tr>
<tr class="memdesc:a0da3a02a79034271cbc560bc94dbe2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction Guides. From raw array.  <a href="#a0da3a02a79034271cbc560bc94dbe2cd">More...</a><br /></td></tr>
<tr class="separator:a0da3a02a79034271cbc560bc94dbe2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ab2c6a5bc678d0ca3f5137c4004543"><td class="memTemplParams" colspan="2">template&lt;class Type , etl::size_t Size&gt; </td></tr>
<tr class="memitem:ac6ab2c6a5bc678d0ca3f5137c4004543"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac6ab2c6a5bc678d0ca3f5137c4004543">span</a> (<a class="el" href="structetl_1_1array.html">etl::array</a>&lt; Type, Size &gt; &amp;) -&gt; <a class="el" href="classetl_1_1span.html">span</a>&lt; Type, Size &gt;</td></tr>
<tr class="memdesc:ac6ab2c6a5bc678d0ca3f5137c4004543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction Guides. From <a class="el" href="namespaceetl.html#ae5a13233ebf471c62f35f40b21128884" title="Deduction guide. ">etl::array&lt;Type, Size&gt;</a>.  <a href="#ac6ab2c6a5bc678d0ca3f5137c4004543">More...</a><br /></td></tr>
<tr class="separator:ac6ab2c6a5bc678d0ca3f5137c4004543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5667307c6ae6ae51fa6d1488fbab93b"><td class="memTemplParams" colspan="2">template&lt;class Type , etl::size_t Size&gt; </td></tr>
<tr class="memitem:aa5667307c6ae6ae51fa6d1488fbab93b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa5667307c6ae6ae51fa6d1488fbab93b">span</a> (<a class="el" href="structetl_1_1array.html">etl::array</a>&lt; Type, Size &gt; const &amp;) -&gt; <a class="el" href="classetl_1_1span.html">span</a>&lt; Type const, Size &gt;</td></tr>
<tr class="memdesc:aa5667307c6ae6ae51fa6d1488fbab93b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction Guides. From <a class="el" href="namespaceetl.html#ae5a13233ebf471c62f35f40b21128884" title="Deduction guide. ">etl::array&lt;Type const, Size&gt;</a>.  <a href="#aa5667307c6ae6ae51fa6d1488fbab93b">More...</a><br /></td></tr>
<tr class="separator:aa5667307c6ae6ae51fa6d1488fbab93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e186959b2d5132ab142843576d30048"><td class="memTemplParams" colspan="2">template&lt;class Container , class Element  = etl::remove_pointer_t&lt;decltype(etl::declval&lt;Container&amp;&gt;().data())&gt;&gt; </td></tr>
<tr class="memitem:a9e186959b2d5132ab142843576d30048"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9e186959b2d5132ab142843576d30048">span</a> (Container &amp;) -&gt; <a class="el" href="classetl_1_1span.html">span</a>&lt; Element &gt;</td></tr>
<tr class="memdesc:a9e186959b2d5132ab142843576d30048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction Guides. From Container.  <a href="#a9e186959b2d5132ab142843576d30048">More...</a><br /></td></tr>
<tr class="separator:a9e186959b2d5132ab142843576d30048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc55cb127ec094c3dbdec3ed03452ebc"><td class="memTemplParams" colspan="2">template&lt;class Container , class Element  = etl::remove_pointer_t&lt;decltype(etl::declval&lt;Container const&amp;&gt;().data())&gt;&gt; </td></tr>
<tr class="memitem:adc55cb127ec094c3dbdec3ed03452ebc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adc55cb127ec094c3dbdec3ed03452ebc">span</a> (Container const &amp;) -&gt; <a class="el" href="classetl_1_1span.html">span</a>&lt; Element &gt;</td></tr>
<tr class="memdesc:adc55cb127ec094c3dbdec3ed03452ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction Guides. From Container const.  <a href="#adc55cb127ec094c3dbdec3ed03452ebc">More...</a><br /></td></tr>
<tr class="separator:adc55cb127ec094c3dbdec3ed03452ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3aa3446aca179d812252faf83360c6"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t Capacity&gt; </td></tr>
<tr class="memitem:a9d3aa3446aca179d812252faf83360c6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9d3aa3446aca179d812252faf83360c6">operator==</a> (<a class="el" href="classetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;lhs, <a class="el" href="classetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:a9d3aa3446aca179d812252faf83360c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0dfb93223a9c8e4413fe9368cd36046"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t Capacity&gt; </td></tr>
<tr class="memitem:ab0dfb93223a9c8e4413fe9368cd36046"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab0dfb93223a9c8e4413fe9368cd36046">operator&lt;</a> (<a class="el" href="classetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;lhs, <a class="el" href="classetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:ab0dfb93223a9c8e4413fe9368cd36046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2867e9d12d25137a50a1b3aee3c5a7"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t Capacity&gt; </td></tr>
<tr class="memitem:a3d2867e9d12d25137a50a1b3aee3c5a7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3d2867e9d12d25137a50a1b3aee3c5a7">operator!=</a> (<a class="el" href="classetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;lhs, <a class="el" href="classetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:a3d2867e9d12d25137a50a1b3aee3c5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715395c53fa693969e269ef5af1972e6"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t Capacity&gt; </td></tr>
<tr class="memitem:a715395c53fa693969e269ef5af1972e6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a715395c53fa693969e269ef5af1972e6">operator&lt;=</a> (<a class="el" href="classetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;lhs, <a class="el" href="classetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:a715395c53fa693969e269ef5af1972e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4fd2ea0cf33ad9339a54469a92f5121"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t Capacity&gt; </td></tr>
<tr class="memitem:ad4fd2ea0cf33ad9339a54469a92f5121"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad4fd2ea0cf33ad9339a54469a92f5121">operator&gt;</a> (<a class="el" href="classetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;lhs, <a class="el" href="classetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:ad4fd2ea0cf33ad9339a54469a92f5121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf47ed021fd1e8bfbc389525967e551"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t Capacity&gt; </td></tr>
<tr class="memitem:aebf47ed021fd1e8bfbc389525967e551"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aebf47ed021fd1e8bfbc389525967e551">operator&gt;=</a> (<a class="el" href="classetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;lhs, <a class="el" href="classetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;rhs) noexcept -&gt; bool</td></tr>
<tr class="separator:aebf47ed021fd1e8bfbc389525967e551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f6e7555448a64b1558e3f5b9771718"><td class="memTemplParams" colspan="2">template&lt;class CharType , class Traits &gt; </td></tr>
<tr class="memitem:a32f6e7555448a64b1558e3f5b9771718"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a32f6e7555448a64b1558e3f5b9771718">operator==</a> (<a class="el" href="classetl_1_1basic__string__view.html">etl::basic_string_view</a>&lt; CharType, Traits &gt; lhs, <a class="el" href="classetl_1_1basic__string__view.html">etl::basic_string_view</a>&lt; CharType, Traits &gt; rhs) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a32f6e7555448a64b1558e3f5b9771718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()):  <a href="#a32f6e7555448a64b1558e3f5b9771718">More...</a><br /></td></tr>
<tr class="separator:a32f6e7555448a64b1558e3f5b9771718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad8ec05de177a5a989ca89fb1568698"><td class="memTemplParams" colspan="2">template&lt;class CharType , class Traits &gt; </td></tr>
<tr class="memitem:aaad8ec05de177a5a989ca89fb1568698"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aaad8ec05de177a5a989ca89fb1568698">operator!=</a> (<a class="el" href="classetl_1_1basic__string__view.html">etl::basic_string_view</a>&lt; CharType, Traits &gt; lhs, <a class="el" href="classetl_1_1basic__string__view.html">etl::basic_string_view</a>&lt; CharType, Traits &gt; rhs) noexcept -&gt; bool</td></tr>
<tr class="memdesc:aaad8ec05de177a5a989ca89fb1568698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()):  <a href="#aaad8ec05de177a5a989ca89fb1568698">More...</a><br /></td></tr>
<tr class="separator:aaad8ec05de177a5a989ca89fb1568698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67cf06af339b11fe81d54b7f93c1334e"><td class="memTemplParams" colspan="2">template&lt;class CharType , class Traits &gt; </td></tr>
<tr class="memitem:a67cf06af339b11fe81d54b7f93c1334e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a67cf06af339b11fe81d54b7f93c1334e">operator&lt;</a> (<a class="el" href="classetl_1_1basic__string__view.html">etl::basic_string_view</a>&lt; CharType, Traits &gt; lhs, <a class="el" href="classetl_1_1basic__string__view.html">etl::basic_string_view</a>&lt; CharType, Traits &gt; rhs) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a67cf06af339b11fe81d54b7f93c1334e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()):  <a href="#a67cf06af339b11fe81d54b7f93c1334e">More...</a><br /></td></tr>
<tr class="separator:a67cf06af339b11fe81d54b7f93c1334e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0de7f91cc35b7999972eb423539d892"><td class="memTemplParams" colspan="2">template&lt;class CharType , class Traits &gt; </td></tr>
<tr class="memitem:ad0de7f91cc35b7999972eb423539d892"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad0de7f91cc35b7999972eb423539d892">operator&lt;=</a> (<a class="el" href="classetl_1_1basic__string__view.html">etl::basic_string_view</a>&lt; CharType, Traits &gt; lhs, <a class="el" href="classetl_1_1basic__string__view.html">etl::basic_string_view</a>&lt; CharType, Traits &gt; rhs) noexcept -&gt; bool</td></tr>
<tr class="memdesc:ad0de7f91cc35b7999972eb423539d892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()):  <a href="#ad0de7f91cc35b7999972eb423539d892">More...</a><br /></td></tr>
<tr class="separator:ad0de7f91cc35b7999972eb423539d892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610759a20e2af85ebdd5bdf54a5418a5"><td class="memTemplParams" colspan="2">template&lt;class CharType , class Traits &gt; </td></tr>
<tr class="memitem:a610759a20e2af85ebdd5bdf54a5418a5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a610759a20e2af85ebdd5bdf54a5418a5">operator&gt;</a> (<a class="el" href="classetl_1_1basic__string__view.html">etl::basic_string_view</a>&lt; CharType, Traits &gt; lhs, <a class="el" href="classetl_1_1basic__string__view.html">etl::basic_string_view</a>&lt; CharType, Traits &gt; rhs) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a610759a20e2af85ebdd5bdf54a5418a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()):  <a href="#a610759a20e2af85ebdd5bdf54a5418a5">More...</a><br /></td></tr>
<tr class="separator:a610759a20e2af85ebdd5bdf54a5418a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4151e119ab2900682096503b5592cdd1"><td class="memTemplParams" colspan="2">template&lt;class CharType , class Traits &gt; </td></tr>
<tr class="memitem:a4151e119ab2900682096503b5592cdd1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4151e119ab2900682096503b5592cdd1">operator&gt;=</a> (<a class="el" href="classetl_1_1basic__string__view.html">etl::basic_string_view</a>&lt; CharType, Traits &gt; lhs, <a class="el" href="classetl_1_1basic__string__view.html">etl::basic_string_view</a>&lt; CharType, Traits &gt; rhs) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a4151e119ab2900682096503b5592cdd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()):  <a href="#a4151e119ab2900682096503b5592cdd1">More...</a><br /></td></tr>
<tr class="separator:a4151e119ab2900682096503b5592cdd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df6d2b5d1046470baf1626470258ed2"><td class="memTemplParams" colspan="2">template&lt;int index, typename First , typename... Rest&gt; </td></tr>
<tr class="memitem:a9df6d2b5d1046470baf1626470258ed2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9df6d2b5d1046470baf1626470258ed2">get</a> (const <a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; First, Rest... &gt; &amp;t) -&gt; decltype(detail::get_impl&lt; index, First, Rest... &gt;::value(&amp;t))</td></tr>
<tr class="separator:a9df6d2b5d1046470baf1626470258ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4147daa38c6c4c1e59540fa0fa27a292"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4147daa38c6c4c1e59540fa0fa27a292"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292">declval</a> () noexcept -&gt; typename <a class="el" href="structetl_1_1add__rvalue__reference.html">etl::add_rvalue_reference</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a4147daa38c6c4c1e59540fa0fa27a292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts any type T to a reference type, making it possible to use member functions in decltype expressions without the need to go through constructors.  <a href="#a4147daa38c6c4c1e59540fa0fa27a292">More...</a><br /></td></tr>
<tr class="separator:a4147daa38c6c4c1e59540fa0fa27a292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec5c14f53ef79e0b6debfffb6ce947f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4ec5c14f53ef79e0b6debfffb6ce947f">is_constant_evaluated</a> () noexcept -&gt; bool</td></tr>
<tr class="memdesc:a4ec5c14f53ef79e0b6debfffb6ce947f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects whether the function call occurs within a constant-evaluated context. Returns true if the evaluation of the call occurs within the evaluation of an expression or conversion that is manifestly constant-evaluated; otherwise returns false.  <a href="#a4ec5c14f53ef79e0b6debfffb6ce947f">More...</a><br /></td></tr>
<tr class="separator:a4ec5c14f53ef79e0b6debfffb6ce947f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4165fb01e5de4a84bfd7367b5133cb3d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4165fb01e5de4a84bfd7367b5133cb3d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4165fb01e5de4a84bfd7367b5133cb3d">move</a> (T &amp;&amp;t) noexcept -&gt; typename <a class="el" href="structetl_1_1remove__reference.html">etl::remove_reference</a>&lt; T &gt;::type &amp;&amp;</td></tr>
<tr class="memdesc:a4165fb01e5de4a84bfd7367b5133cb3d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceetl.html#ad0a5b274f170d18a9e175fddf538a4bc" title="Moves the elements in the range [first, last), to another range beginning at d_first, starting from first and proceeding to last - 1. After this operation the elements in the moved-from range will still contain valid values of the appropriate type, but not necessarily the same values as before the move. ">etl::move</a> is used to indicate that an object t may be "moved from", i.e. allowing the efficient transfer of resources from t to another object. In particular, <a class="el" href="namespaceetl.html#ad0a5b274f170d18a9e175fddf538a4bc" title="Moves the elements in the range [first, last), to another range beginning at d_first, starting from first and proceeding to last - 1. After this operation the elements in the moved-from range will still contain valid values of the appropriate type, but not necessarily the same values as before the move. ">etl::move</a> produces an xvalue expression that identifies its argument t. It is exactly equivalent to a static_cast to an rvalue reference type.  <a href="#a4165fb01e5de4a84bfd7367b5133cb3d">More...</a><br /></td></tr>
<tr class="separator:a4165fb01e5de4a84bfd7367b5133cb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b9621f8af141d0572885428d2880d9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a40b9621f8af141d0572885428d2880d9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a40b9621f8af141d0572885428d2880d9">forward</a> (<a class="el" href="namespaceetl.html#a26ceb8de4fe37ef6a14f78dd10d95bb6">etl::remove_reference_t</a>&lt; T &gt; &amp;param) noexcept -&gt; T &amp;&amp;</td></tr>
<tr class="memdesc:a40b9621f8af141d0572885428d2880d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards lvalues as either lvalues or as rvalues, depending on T.  <a href="#a40b9621f8af141d0572885428d2880d9">More...</a><br /></td></tr>
<tr class="separator:a40b9621f8af141d0572885428d2880d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb1fda04868d6ffa0343a463beba0e7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aecb1fda04868d6ffa0343a463beba0e7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aecb1fda04868d6ffa0343a463beba0e7">forward</a> (<a class="el" href="namespaceetl.html#a26ceb8de4fe37ef6a14f78dd10d95bb6">etl::remove_reference_t</a>&lt; T &gt; &amp;&amp;param) noexcept -&gt; T &amp;&amp;</td></tr>
<tr class="memdesc:aecb1fda04868d6ffa0343a463beba0e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards rvalues as rvalues and prohibits forwarding of rvalues as lvalues.  <a href="#aecb1fda04868d6ffa0343a463beba0e7">More...</a><br /></td></tr>
<tr class="separator:aecb1fda04868d6ffa0343a463beba0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287776d62f51d8f2b70314a1ca7022d5"><td class="memTemplParams" colspan="2">template&lt;class T , class U  = T&gt; </td></tr>
<tr class="memitem:a287776d62f51d8f2b70314a1ca7022d5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a287776d62f51d8f2b70314a1ca7022d5">exchange</a> (T &amp;obj, U &amp;&amp;new_value) -&gt; T</td></tr>
<tr class="memdesc:a287776d62f51d8f2b70314a1ca7022d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the value of obj with new_value and returns the old value of obj.  <a href="#a287776d62f51d8f2b70314a1ca7022d5">More...</a><br /></td></tr>
<tr class="separator:a287776d62f51d8f2b70314a1ca7022d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3a2df3d684f12d436ea1d16e2de630"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6c3a2df3d684f12d436ea1d16e2de630"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6c3a2df3d684f12d436ea1d16e2de630">as_const</a> (T &amp;t) noexcept -&gt; <a class="el" href="namespaceetl.html#a20607674e1e3cd49d5f0b815b33b2c1d">etl::add_const_t</a>&lt; T &gt; &amp;</td></tr>
<tr class="memdesc:a6c3a2df3d684f12d436ea1d16e2de630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms lvalue reference to const type of t.  <a href="#a6c3a2df3d684f12d436ea1d16e2de630">More...</a><br /></td></tr>
<tr class="separator:a6c3a2df3d684f12d436ea1d16e2de630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96cf5452578f57be8c16cc9b4688f8af"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a96cf5452578f57be8c16cc9b4688f8af"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a96cf5452578f57be8c16cc9b4688f8af">as_const</a> (const T &amp;&amp;) -&gt; void=delete</td></tr>
<tr class="memdesc:a96cf5452578f57be8c16cc9b4688f8af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const rvalue reference overload is deleted to disallow rvalue arguments.  <a href="#a96cf5452578f57be8c16cc9b4688f8af">More...</a><br /></td></tr>
<tr class="separator:a96cf5452578f57be8c16cc9b4688f8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf43ebd431e0effc1fcd56e1cdb3a58c"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:adf43ebd431e0effc1fcd56e1cdb3a58c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adf43ebd431e0effc1fcd56e1cdb3a58c">cmp_equal</a> (T t, U u) noexcept -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt; detail::is_integer_and_not_char&lt; T &gt;::value &amp;&amp;detail::is_integer_and_not_char&lt; U &gt;::value, bool &gt;</td></tr>
<tr class="memdesc:adf43ebd431e0effc1fcd56e1cdb3a58c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion.  <a href="#adf43ebd431e0effc1fcd56e1cdb3a58c">More...</a><br /></td></tr>
<tr class="separator:adf43ebd431e0effc1fcd56e1cdb3a58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67fad2bcf2015251e85a6881458656c5"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a67fad2bcf2015251e85a6881458656c5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a67fad2bcf2015251e85a6881458656c5">cmp_not_equal</a> (T t, U u) noexcept -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt; detail::is_integer_and_not_char&lt; T &gt;::value &amp;&amp;detail::is_integer_and_not_char&lt; U &gt;::value, bool &gt;</td></tr>
<tr class="memdesc:a67fad2bcf2015251e85a6881458656c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion.  <a href="#a67fad2bcf2015251e85a6881458656c5">More...</a><br /></td></tr>
<tr class="separator:a67fad2bcf2015251e85a6881458656c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2faa4ff3aa7b68304c111c33000601"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a8c2faa4ff3aa7b68304c111c33000601"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8c2faa4ff3aa7b68304c111c33000601">cmp_less</a> (T t, U u) noexcept -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt; detail::is_integer_and_not_char&lt; T &gt;::value &amp;&amp;detail::is_integer_and_not_char&lt; U &gt;::value, bool &gt;</td></tr>
<tr class="memdesc:a8c2faa4ff3aa7b68304c111c33000601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion.  <a href="#a8c2faa4ff3aa7b68304c111c33000601">More...</a><br /></td></tr>
<tr class="separator:a8c2faa4ff3aa7b68304c111c33000601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726b4eedfb2a4ae9c478e0e98588a2e8"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a726b4eedfb2a4ae9c478e0e98588a2e8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a726b4eedfb2a4ae9c478e0e98588a2e8">cmp_greater</a> (T t, U u) noexcept -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt; detail::is_integer_and_not_char&lt; T &gt;::value &amp;&amp;detail::is_integer_and_not_char&lt; U &gt;::value, bool &gt;</td></tr>
<tr class="memdesc:a726b4eedfb2a4ae9c478e0e98588a2e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion.  <a href="#a726b4eedfb2a4ae9c478e0e98588a2e8">More...</a><br /></td></tr>
<tr class="separator:a726b4eedfb2a4ae9c478e0e98588a2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331ef5587f806c7dc56a94dfaaf8e819"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a331ef5587f806c7dc56a94dfaaf8e819"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a331ef5587f806c7dc56a94dfaaf8e819">cmp_less_equal</a> (T t, U u) noexcept -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt; detail::is_integer_and_not_char&lt; T &gt;::value &amp;&amp;detail::is_integer_and_not_char&lt; U &gt;::value, bool &gt;</td></tr>
<tr class="memdesc:a331ef5587f806c7dc56a94dfaaf8e819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion.  <a href="#a331ef5587f806c7dc56a94dfaaf8e819">More...</a><br /></td></tr>
<tr class="separator:a331ef5587f806c7dc56a94dfaaf8e819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb292194946c9d80e86df97adf5635b"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a0eb292194946c9d80e86df97adf5635b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0eb292194946c9d80e86df97adf5635b">cmp_greater_equal</a> (T t, U u) noexcept -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt; detail::is_integer_and_not_char&lt; T &gt;::value &amp;&amp;detail::is_integer_and_not_char&lt; U &gt;::value, bool &gt;</td></tr>
<tr class="memdesc:a0eb292194946c9d80e86df97adf5635b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion.  <a href="#a0eb292194946c9d80e86df97adf5635b">More...</a><br /></td></tr>
<tr class="separator:a0eb292194946c9d80e86df97adf5635b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa374f8a8aadeee045b4a6d154baa5d7c"><td class="memTemplParams" colspan="2">template&lt;class R , class T &gt; </td></tr>
<tr class="memitem:aa374f8a8aadeee045b4a6d154baa5d7c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa374f8a8aadeee045b4a6d154baa5d7c">in_range</a> (T t) noexcept -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt; detail::is_integer_and_not_char&lt; T &gt;::value, bool &gt;</td></tr>
<tr class="memdesc:aa374f8a8aadeee045b4a6d154baa5d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the value of t is in the range of values that can be represented in R, that is, if t can be converted to R without data loss.  <a href="#aa374f8a8aadeee045b4a6d154baa5d7c">More...</a><br /></td></tr>
<tr class="separator:aa374f8a8aadeee045b4a6d154baa5d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638ad4db4d90fecc8d08227b1c214148"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a638ad4db4d90fecc8d08227b1c214148"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a638ad4db4d90fecc8d08227b1c214148">make_pair</a> (T1 &amp;&amp;t, T2 &amp;&amp;u) -&gt; <a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; typename <a class="el" href="structetl_1_1decay.html">etl::decay</a>&lt; T1 &gt;::type, typename <a class="el" href="structetl_1_1decay.html">etl::decay</a>&lt; T2 &gt;::type &gt;</td></tr>
<tr class="memdesc:a638ad4db4d90fecc8d08227b1c214148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="structetl_1_1pair.html" title="etl::pair is a class template that provides a way to store two heterogeneous objects as a single unit...">etl::pair</a> object, deducing the target type from the types of arguments.  <a href="#a638ad4db4d90fecc8d08227b1c214148">More...</a><br /></td></tr>
<tr class="separator:a638ad4db4d90fecc8d08227b1c214148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a4e54525fb4847cb202baaff5657d8"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:ae2a4e54525fb4847cb202baaff5657d8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae2a4e54525fb4847cb202baaff5657d8">operator==</a> (<a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; T1, T2 &gt; const &amp;lhs, <a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; T1, T2 &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:ae2a4e54525fb4847cb202baaff5657d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if both elements of lhs and rhs are equal, that is, compares lhs.first with rhs.first and lhs.second with rhs.second.  <a href="#ae2a4e54525fb4847cb202baaff5657d8">More...</a><br /></td></tr>
<tr class="separator:ae2a4e54525fb4847cb202baaff5657d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a799dae79119bbb5d967d25f990939522"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a799dae79119bbb5d967d25f990939522"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a799dae79119bbb5d967d25f990939522">operator!=</a> (<a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; T1, T2 &gt; const &amp;lhs, <a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; T1, T2 &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:a799dae79119bbb5d967d25f990939522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if both elements of lhs and rhs are equal, that is, compares lhs.first with rhs.first and lhs.second with rhs.second.  <a href="#a799dae79119bbb5d967d25f990939522">More...</a><br /></td></tr>
<tr class="separator:a799dae79119bbb5d967d25f990939522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7b429dca0b762facbaea24836f0995"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a2c7b429dca0b762facbaea24836f0995"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2c7b429dca0b762facbaea24836f0995">operator&lt;</a> (<a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; T1, T2 &gt; const &amp;lhs, <a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; T1, T2 &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:a2c7b429dca0b762facbaea24836f0995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements.  <a href="#a2c7b429dca0b762facbaea24836f0995">More...</a><br /></td></tr>
<tr class="separator:a2c7b429dca0b762facbaea24836f0995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7562e604a7a1298eda82e34e2f8dab40"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a7562e604a7a1298eda82e34e2f8dab40"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a7562e604a7a1298eda82e34e2f8dab40">operator&lt;=</a> (<a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; T1, T2 &gt; const &amp;lhs, <a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; T1, T2 &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:a7562e604a7a1298eda82e34e2f8dab40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements.  <a href="#a7562e604a7a1298eda82e34e2f8dab40">More...</a><br /></td></tr>
<tr class="separator:a7562e604a7a1298eda82e34e2f8dab40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08cb376464287fd4c82dc6d4ca604081"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a08cb376464287fd4c82dc6d4ca604081"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a08cb376464287fd4c82dc6d4ca604081">operator&gt;</a> (<a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; T1, T2 &gt; const &amp;lhs, <a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; T1, T2 &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:a08cb376464287fd4c82dc6d4ca604081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements.  <a href="#a08cb376464287fd4c82dc6d4ca604081">More...</a><br /></td></tr>
<tr class="separator:a08cb376464287fd4c82dc6d4ca604081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48ced933809d3ce47af09003416996d"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:ae48ced933809d3ce47af09003416996d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae48ced933809d3ce47af09003416996d">operator&gt;=</a> (<a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; T1, T2 &gt; const &amp;lhs, <a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; T1, T2 &gt; const &amp;rhs) -&gt; bool</td></tr>
<tr class="memdesc:ae48ced933809d3ce47af09003416996d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements.  <a href="#ae48ced933809d3ce47af09003416996d">More...</a><br /></td></tr>
<tr class="separator:ae48ced933809d3ce47af09003416996d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4805fd3b0cdc0a1a3db6475f16708849"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4805fd3b0cdc0a1a3db6475f16708849">operator==</a> (<a class="el" href="structetl_1_1monostate.html">monostate</a>, <a class="el" href="structetl_1_1monostate.html">monostate</a>) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a4805fd3b0cdc0a1a3db6475f16708849"><td class="mdescLeft">&#160;</td><td class="mdescRight">All instances of <a class="el" href="structetl_1_1monostate.html" title="Unit type intended for use as a well-behaved empty alternative in etl::variant. In particular...">etl::monostate</a> compare equal.  <a href="#a4805fd3b0cdc0a1a3db6475f16708849">More...</a><br /></td></tr>
<tr class="separator:a4805fd3b0cdc0a1a3db6475f16708849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde631d12e3fa3eadef0726f8a1218ec"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abde631d12e3fa3eadef0726f8a1218ec">operator!=</a> (<a class="el" href="structetl_1_1monostate.html">monostate</a>, <a class="el" href="structetl_1_1monostate.html">monostate</a>) noexcept -&gt; bool</td></tr>
<tr class="memdesc:abde631d12e3fa3eadef0726f8a1218ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">All instances of <a class="el" href="structetl_1_1monostate.html" title="Unit type intended for use as a well-behaved empty alternative in etl::variant. In particular...">etl::monostate</a> compare equal.  <a href="#abde631d12e3fa3eadef0726f8a1218ec">More...</a><br /></td></tr>
<tr class="separator:abde631d12e3fa3eadef0726f8a1218ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d6295f5e016b5d4473335bb3bdc056"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad3d6295f5e016b5d4473335bb3bdc056">operator&lt;</a> (<a class="el" href="structetl_1_1monostate.html">monostate</a>, <a class="el" href="structetl_1_1monostate.html">monostate</a>) noexcept -&gt; bool</td></tr>
<tr class="memdesc:ad3d6295f5e016b5d4473335bb3bdc056"><td class="mdescLeft">&#160;</td><td class="mdescRight">All instances of <a class="el" href="structetl_1_1monostate.html" title="Unit type intended for use as a well-behaved empty alternative in etl::variant. In particular...">etl::monostate</a> compare equal.  <a href="#ad3d6295f5e016b5d4473335bb3bdc056">More...</a><br /></td></tr>
<tr class="separator:ad3d6295f5e016b5d4473335bb3bdc056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e919d889b1cffc2fe30748064be47d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae7e919d889b1cffc2fe30748064be47d">operator&gt;</a> (<a class="el" href="structetl_1_1monostate.html">monostate</a>, <a class="el" href="structetl_1_1monostate.html">monostate</a>) noexcept -&gt; bool</td></tr>
<tr class="memdesc:ae7e919d889b1cffc2fe30748064be47d"><td class="mdescLeft">&#160;</td><td class="mdescRight">All instances of <a class="el" href="structetl_1_1monostate.html" title="Unit type intended for use as a well-behaved empty alternative in etl::variant. In particular...">etl::monostate</a> compare equal.  <a href="#ae7e919d889b1cffc2fe30748064be47d">More...</a><br /></td></tr>
<tr class="separator:ae7e919d889b1cffc2fe30748064be47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e6f06421ee1d47e10ac411d5266606"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a15e6f06421ee1d47e10ac411d5266606">operator&lt;=</a> (<a class="el" href="structetl_1_1monostate.html">monostate</a>, <a class="el" href="structetl_1_1monostate.html">monostate</a>) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a15e6f06421ee1d47e10ac411d5266606"><td class="mdescLeft">&#160;</td><td class="mdescRight">All instances of <a class="el" href="structetl_1_1monostate.html" title="Unit type intended for use as a well-behaved empty alternative in etl::variant. In particular...">etl::monostate</a> compare equal.  <a href="#a15e6f06421ee1d47e10ac411d5266606">More...</a><br /></td></tr>
<tr class="separator:a15e6f06421ee1d47e10ac411d5266606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9427318b650a4b9bc68d9c363e7b6a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3c9427318b650a4b9bc68d9c363e7b6a">operator&gt;=</a> (<a class="el" href="structetl_1_1monostate.html">monostate</a>, <a class="el" href="structetl_1_1monostate.html">monostate</a>) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a3c9427318b650a4b9bc68d9c363e7b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">All instances of <a class="el" href="structetl_1_1monostate.html" title="Unit type intended for use as a well-behaved empty alternative in etl::variant. In particular...">etl::monostate</a> compare equal.  <a href="#a3c9427318b650a4b9bc68d9c363e7b6a">More...</a><br /></td></tr>
<tr class="separator:a3c9427318b650a4b9bc68d9c363e7b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61440f28934330fcfa979f4a1fba3c54"><td class="memTemplParams" colspan="2">template&lt;class T , class... Types&gt; </td></tr>
<tr class="memitem:a61440f28934330fcfa979f4a1fba3c54"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a61440f28934330fcfa979f4a1fba3c54">holds_alternative</a> (<a class="el" href="classetl_1_1variant.html">etl::variant</a>&lt; Types... &gt; const &amp;v) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a61440f28934330fcfa979f4a1fba3c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the variant v holds the alternative T. The call is ill-formed if T does not appear exactly once in Types...  <a href="#a61440f28934330fcfa979f4a1fba3c54">More...</a><br /></td></tr>
<tr class="separator:a61440f28934330fcfa979f4a1fba3c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8169996f70a6db66068896e1f2d6d774"><td class="memTemplParams" colspan="2">template&lt;etl::size_t I, class... Types&gt; </td></tr>
<tr class="memitem:a8169996f70a6db66068896e1f2d6d774"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8169996f70a6db66068896e1f2d6d774">get_if</a> (<a class="el" href="classetl_1_1variant.html">etl::variant</a>&lt; Types... &gt; *pv) noexcept -&gt; <a class="el" href="namespaceetl.html#afd20d67cb221212f49a97e02a7c1ca25">etl::add_pointer_t</a>&lt; <a class="el" href="namespaceetl.html#aef7110ca07ee5b481d99d9ae57a977ed">etl::variant_alternative_t</a>&lt; I, <a class="el" href="classetl_1_1variant.html">etl::variant</a>&lt; Types... &gt;&gt;&gt;</td></tr>
<tr class="memdesc:a8169996f70a6db66068896e1f2d6d774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index-based non-throwing accessor: If pv is not a null pointer and pv-&gt;index() == I, returns a pointer to the value stored in the variant pointed to by pv. Otherwise, returns a null pointer value. The call is ill-formed if I is not a valid index in the variant.  <a href="#a8169996f70a6db66068896e1f2d6d774">More...</a><br /></td></tr>
<tr class="separator:a8169996f70a6db66068896e1f2d6d774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6793464788b24ea02472dc48eb208218"><td class="memTemplParams" colspan="2">template&lt;etl::size_t I, class... Types&gt; </td></tr>
<tr class="memitem:a6793464788b24ea02472dc48eb208218"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6793464788b24ea02472dc48eb208218">get_if</a> (<a class="el" href="classetl_1_1variant.html">etl::variant</a>&lt; Types... &gt; const *pv) noexcept -&gt; <a class="el" href="namespaceetl.html#afd20d67cb221212f49a97e02a7c1ca25">etl::add_pointer_t</a>&lt; <a class="el" href="namespaceetl.html#aef7110ca07ee5b481d99d9ae57a977ed">etl::variant_alternative_t</a>&lt; I, <a class="el" href="classetl_1_1variant.html">etl::variant</a>&lt; Types... &gt;&gt; const &gt;</td></tr>
<tr class="memdesc:a6793464788b24ea02472dc48eb208218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index-based non-throwing accessor: If pv is not a null pointer and pv-&gt;index() == I, returns a pointer to the value stored in the variant pointed to by pv. Otherwise, returns a null pointer value. The call is ill-formed if I is not a valid index in the variant.  <a href="#a6793464788b24ea02472dc48eb208218">More...</a><br /></td></tr>
<tr class="separator:a6793464788b24ea02472dc48eb208218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad763c7f65a817a0ba3f58cf0d5672d1b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad763c7f65a817a0ba3f58cf0d5672d1b">is_language_standard</a> (<a class="el" href="namespaceetl.html#a3d70da9977ec456339973b30e372fcbd">language_standard</a> ls) -&gt; bool</td></tr>
<tr class="memdesc:ad763c7f65a817a0ba3f58cf0d5672d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the given standard and the currently configurated in the compiler match.  <a href="#ad763c7f65a817a0ba3f58cf0d5672d1b">More...</a><br /></td></tr>
<tr class="separator:ad763c7f65a817a0ba3f58cf0d5672d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8a84a5c6ba35f67fbc2ca6092eedde"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abe8a84a5c6ba35f67fbc2ca6092eedde">is_greater_language_standard</a> (<a class="el" href="namespaceetl.html#a3d70da9977ec456339973b30e372fcbd">language_standard</a> ls) -&gt; bool</td></tr>
<tr class="separator:abe8a84a5c6ba35f67fbc2ca6092eedde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1849ec064e37fdc587449c92492d25"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ada1849ec064e37fdc587449c92492d25"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ada1849ec064e37fdc587449c92492d25">ignore_unused</a> (Types &amp;&amp;...) -&gt; void</td></tr>
<tr class="separator:ada1849ec064e37fdc587449c92492d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:abf153d087d14c7ed7794a0a7d4f5d08d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:abf153d087d14c7ed7794a0a7d4f5d08d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">etl::size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abf153d087d14c7ed7794a0a7d4f5d08d">tuple_size_v</a> = <a class="el" href="structetl_1_1tuple__size.html">tuple_size</a>&lt;T&gt;::value</td></tr>
<tr class="separator:abf153d087d14c7ed7794a0a7d4f5d08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9e177fde5dc55ea58bb3771c37051a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structetl_1_1defer__lock__t.html">defer_lock_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3e9e177fde5dc55ea58bb3771c37051a">defer_lock</a> {}</td></tr>
<tr class="memdesc:a3e9e177fde5dc55ea58bb3771c37051a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instances of empty struct tag types. See <a class="el" href="structetl_1_1defer__lock__t.html" title="Empty class tag types used to specify locking strategy for etl::lock_guard, etl::scoped_lock, etl::unique_lock, and etl::shared_lock. ">defer_lock_t</a>.  <a href="#a3e9e177fde5dc55ea58bb3771c37051a">More...</a><br /></td></tr>
<tr class="separator:a3e9e177fde5dc55ea58bb3771c37051a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086e79db17e8b72ae86d834fad514b2e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structetl_1_1try__to__lock__t.html">try_to_lock_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a086e79db17e8b72ae86d834fad514b2e">try_to_lock</a> {}</td></tr>
<tr class="memdesc:a086e79db17e8b72ae86d834fad514b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instances of empty struct tag types. See <a class="el" href="structetl_1_1try__to__lock__t.html" title="Empty class tag types used to specify locking strategy for etl::lock_guard, etl::scoped_lock, etl::unique_lock, and etl::shared_lock. ">try_to_lock_t</a>.  <a href="#a086e79db17e8b72ae86d834fad514b2e">More...</a><br /></td></tr>
<tr class="separator:a086e79db17e8b72ae86d834fad514b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ee00292ff760cd8ecf8b41bb4de696"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structetl_1_1adopt__lock__t.html">adopt_lock_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a03ee00292ff760cd8ecf8b41bb4de696">adopt_lock</a> {}</td></tr>
<tr class="memdesc:a03ee00292ff760cd8ecf8b41bb4de696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instances of empty struct tag types. See <a class="el" href="structetl_1_1adopt__lock__t.html" title="Empty class tag types used to specify locking strategy for etl::lock_guard, etl::scoped_lock, etl::unique_lock, and etl::shared_lock. ">adopt_lock_t</a>.  <a href="#a03ee00292ff760cd8ecf8b41bb4de696">More...</a><br /></td></tr>
<tr class="separator:a03ee00292ff760cd8ecf8b41bb4de696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d7a7601aedf2ce125a34a9d83b80a7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a93d7a7601aedf2ce125a34a9d83b80a7">nullopt</a> = <a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a> {{}}</td></tr>
<tr class="memdesc:a93d7a7601aedf2ce125a34a9d83b80a7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceetl.html#a93d7a7601aedf2ce125a34a9d83b80a7" title="etl::nullopt is a constant of type etl::nullopt_t that is used to indicate optional type with uniniti...">etl::nullopt</a> is a constant of type <a class="el" href="structetl_1_1nullopt__t.html" title="etl::nullopt_t is an empty class type used to indicate optional type with uninitialized state...">etl::nullopt_t</a> that is used to indicate optional type with uninitialized state.  <a href="#a93d7a7601aedf2ce125a34a9d83b80a7">More...</a><br /></td></tr>
<tr class="separator:a93d7a7601aedf2ce125a34a9d83b80a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717a065b4d593697dc186ca84f51ffb8"><td class="memTemplParams" colspan="2">template&lt;class R1 , class R2 &gt; </td></tr>
<tr class="memitem:a717a065b4d593697dc186ca84f51ffb8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a717a065b4d593697dc186ca84f51ffb8">ratio_equal_v</a> = <a class="el" href="structetl_1_1ratio__equal.html">ratio_equal</a>&lt;R1, R2&gt;::value</td></tr>
<tr class="separator:a717a065b4d593697dc186ca84f51ffb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf88cdc68bd2c8d7aa353d030c3c1e6c"><td class="memTemplParams" colspan="2">template&lt;class R1 , class R2 &gt; </td></tr>
<tr class="memitem:adf88cdc68bd2c8d7aa353d030c3c1e6c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adf88cdc68bd2c8d7aa353d030c3c1e6c">ratio_not_equal_v</a> = <a class="el" href="structetl_1_1ratio__not__equal.html">ratio_not_equal</a>&lt;R1, R2&gt;::value</td></tr>
<tr class="separator:adf88cdc68bd2c8d7aa353d030c3c1e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d7dd3cfa6494a27aaf40f11ec60b62"><td class="memTemplParams" colspan="2">template&lt;class R1 , class R2 &gt; </td></tr>
<tr class="memitem:aa8d7dd3cfa6494a27aaf40f11ec60b62"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa8d7dd3cfa6494a27aaf40f11ec60b62">ratio_less_v</a> = <a class="el" href="structetl_1_1ratio__less.html">ratio_less</a>&lt;R1, R2&gt;::value</td></tr>
<tr class="separator:aa8d7dd3cfa6494a27aaf40f11ec60b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e01f9b1a6c95f6f7b793bdfb54755d"><td class="memTemplParams" colspan="2">template&lt;class R1 , class R2 &gt; </td></tr>
<tr class="memitem:a31e01f9b1a6c95f6f7b793bdfb54755d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a31e01f9b1a6c95f6f7b793bdfb54755d">ratio_less_equal_v</a> = <a class="el" href="structetl_1_1ratio__less__equal.html">ratio_less_equal</a>&lt;R1, R2&gt;::value</td></tr>
<tr class="separator:a31e01f9b1a6c95f6f7b793bdfb54755d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce653ddb9ec91f96bda7e292725dc0e"><td class="memTemplParams" colspan="2">template&lt;class R1 , class R2 &gt; </td></tr>
<tr class="memitem:abce653ddb9ec91f96bda7e292725dc0e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abce653ddb9ec91f96bda7e292725dc0e">ratio_greater_v</a> = <a class="el" href="structetl_1_1ratio__greater.html">ratio_greater</a>&lt;R1, R2&gt;::value</td></tr>
<tr class="separator:abce653ddb9ec91f96bda7e292725dc0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed208c9b18aabc1288d0721225be488"><td class="memTemplParams" colspan="2">template&lt;class R1 , class R2 &gt; </td></tr>
<tr class="memitem:a1ed208c9b18aabc1288d0721225be488"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1ed208c9b18aabc1288d0721225be488">ratio_greater_equal_v</a> = <a class="el" href="structetl_1_1ratio__greater__equal.html">ratio_greater_equal</a>&lt;R1, R2&gt;::value</td></tr>
<tr class="separator:a1ed208c9b18aabc1288d0721225be488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae174223df490e6263d4648a86326c902"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae174223df490e6263d4648a86326c902">dynamic_extent</a> = <a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">size_t</a>(-1)</td></tr>
<tr class="memdesc:ae174223df490e6263d4648a86326c902"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceetl.html#ae174223df490e6263d4648a86326c902" title="etl::dynamic_extent is a constant of type etl::size_t that is used to differentiate etl::span of stat...">etl::dynamic_extent</a> is a constant of type <a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">etl::size_t</a> that is used to differentiate <a class="el" href="classetl_1_1span.html" title="A non-owning view over a contiguous sequence of objects. ">etl::span</a> of static and dynamic extent.  <a href="#ae174223df490e6263d4648a86326c902">More...</a><br /></td></tr>
<tr class="separator:ae174223df490e6263d4648a86326c902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d9f32a20bf813fd8ce025d0aebbff5"><td class="memTemplParams" colspan="2">template&lt;class... B&gt; </td></tr>
<tr class="memitem:af0d9f32a20bf813fd8ce025d0aebbff5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af0d9f32a20bf813fd8ce025d0aebbff5">conjunction_v</a> = <a class="el" href="structetl_1_1conjunction.html">conjunction</a>&lt;B...&gt;::value</td></tr>
<tr class="separator:af0d9f32a20bf813fd8ce025d0aebbff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f460d9cd9dc39f08fc926828d8b442"><td class="memTemplParams" colspan="2">template&lt;class... B&gt; </td></tr>
<tr class="memitem:a29f460d9cd9dc39f08fc926828d8b442"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a29f460d9cd9dc39f08fc926828d8b442">disjunction_v</a> = <a class="el" href="structetl_1_1disjunction.html">disjunction</a>&lt;B...&gt;::value</td></tr>
<tr class="separator:a29f460d9cd9dc39f08fc926828d8b442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0422e10e238c05956150aa5f4ed77e"><td class="memTemplParams" colspan="2">template&lt;class B &gt; </td></tr>
<tr class="memitem:a2e0422e10e238c05956150aa5f4ed77e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2e0422e10e238c05956150aa5f4ed77e">negation_v</a> = <a class="el" href="structetl_1_1negation.html">negation</a>&lt;B&gt;::value</td></tr>
<tr class="separator:a2e0422e10e238c05956150aa5f4ed77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f74da2365a9a6f68d472686fd0f1666"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a3f74da2365a9a6f68d472686fd0f1666"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3f74da2365a9a6f68d472686fd0f1666">is_same_v</a> = <a class="el" href="structetl_1_1is__same.html">is_same</a>&lt;T, U&gt;::value</td></tr>
<tr class="separator:a3f74da2365a9a6f68d472686fd0f1666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149f8ba4063995f2c8ed7248d93a4d9e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a149f8ba4063995f2c8ed7248d93a4d9e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a149f8ba4063995f2c8ed7248d93a4d9e">is_void_v</a> = <a class="el" href="structetl_1_1is__void.html">is_void</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a149f8ba4063995f2c8ed7248d93a4d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef2a50a29c8803d461abedd7437effd"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0ef2a50a29c8803d461abedd7437effd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">is_integral_v</a> = <a class="el" href="structetl_1_1is__integral.html">is_integral</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a0ef2a50a29c8803d461abedd7437effd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf273d19443134cffcd66310d027ae4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5cf273d19443134cffcd66310d027ae4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5cf273d19443134cffcd66310d027ae4">is_floating_point_v</a> = <a class="el" href="structetl_1_1is__floating__point.html">is_floating_point</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a5cf273d19443134cffcd66310d027ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40862de0c689f5281b8d680741bc7cf9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a40862de0c689f5281b8d680741bc7cf9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a40862de0c689f5281b8d680741bc7cf9">is_const_v</a> = <a class="el" href="structetl_1_1is__const.html">is_const</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a40862de0c689f5281b8d680741bc7cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76b943cef158f554f60c8d61b6835bc"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa76b943cef158f554f60c8d61b6835bc"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa76b943cef158f554f60c8d61b6835bc">is_volatile_v</a> = <a class="el" href="structetl_1_1is__volatile.html">is_volatile</a>&lt;T&gt;::value</td></tr>
<tr class="separator:aa76b943cef158f554f60c8d61b6835bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258143fbbaaef57434ff042f35db08a6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a258143fbbaaef57434ff042f35db08a6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a258143fbbaaef57434ff042f35db08a6">is_empty_v</a> = <a class="el" href="structetl_1_1is__empty.html">is_empty</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a258143fbbaaef57434ff042f35db08a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22294e9170ea0547c68724eabe0c8c5a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a22294e9170ea0547c68724eabe0c8c5a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a22294e9170ea0547c68724eabe0c8c5a">is_reference_v</a> = <a class="el" href="structetl_1_1is__reference.html">is_reference</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a22294e9170ea0547c68724eabe0c8c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016c8419365e8e3697a56040d335bca4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a016c8419365e8e3697a56040d335bca4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a016c8419365e8e3697a56040d335bca4">is_null_pointer_v</a> = <a class="el" href="structetl_1_1is__null__pointer.html">is_null_pointer</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a016c8419365e8e3697a56040d335bca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa46050181985a6156a6c800c86a7d8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:afaa46050181985a6156a6c800c86a7d8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afaa46050181985a6156a6c800c86a7d8">is_array_v</a> = <a class="el" href="structetl_1_1is__array.html">is_array</a>&lt;T&gt;::value</td></tr>
<tr class="separator:afaa46050181985a6156a6c800c86a7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3b44fa05f956c1efc4f34af98bd1f0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aec3b44fa05f956c1efc4f34af98bd1f0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aec3b44fa05f956c1efc4f34af98bd1f0">is_function_v</a> = <a class="el" href="structetl_1_1is__function.html">is_function</a>&lt;T&gt;::value</td></tr>
<tr class="separator:aec3b44fa05f956c1efc4f34af98bd1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00eca7d51c4d2c1021402ee9a70f03c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac00eca7d51c4d2c1021402ee9a70f03c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac00eca7d51c4d2c1021402ee9a70f03c">is_pointer_v</a> = <a class="el" href="structetl_1_1is__pointer.html">is_pointer</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ac00eca7d51c4d2c1021402ee9a70f03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf67506d7e83cba3f386c212a824e9c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:abdf67506d7e83cba3f386c212a824e9c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#abdf67506d7e83cba3f386c212a824e9c">is_lvalue_reference_v</a> = <a class="el" href="structetl_1_1is__lvalue__reference.html">is_lvalue_reference</a>&lt;T&gt;::value</td></tr>
<tr class="separator:abdf67506d7e83cba3f386c212a824e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2cba0c4e29fbd91ba77cbf6b9744ebc"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af2cba0c4e29fbd91ba77cbf6b9744ebc"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af2cba0c4e29fbd91ba77cbf6b9744ebc">is_rvalue_reference_v</a> = <a class="el" href="structetl_1_1is__rvalue__reference.html">is_rvalue_reference</a>&lt;T&gt;::value</td></tr>
<tr class="separator:af2cba0c4e29fbd91ba77cbf6b9744ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d441fab48eb459b77f6f5829f7fc75"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af8d441fab48eb459b77f6f5829f7fc75"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af8d441fab48eb459b77f6f5829f7fc75">is_class_v</a> = <a class="el" href="structetl_1_1is__class.html">is_class</a>&lt;T&gt;::value</td></tr>
<tr class="separator:af8d441fab48eb459b77f6f5829f7fc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4784b73e6d758a37358b62211a308ef"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa4784b73e6d758a37358b62211a308ef"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa4784b73e6d758a37358b62211a308ef">is_enum_v</a> = <a class="el" href="structetl_1_1is__enum.html">is_enum</a>&lt;T&gt;::value</td></tr>
<tr class="separator:aa4784b73e6d758a37358b62211a308ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d4c31d288adf2cb4c5d7fd14c32f00"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a51d4c31d288adf2cb4c5d7fd14c32f00"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a51d4c31d288adf2cb4c5d7fd14c32f00">is_union_v</a> = <a class="el" href="structetl_1_1is__union.html">is_union</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a51d4c31d288adf2cb4c5d7fd14c32f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbaaa5057d498812ee848f491a20649a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:adbaaa5057d498812ee848f491a20649a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adbaaa5057d498812ee848f491a20649a">is_member_pointer_v</a> = <a class="el" href="structetl_1_1is__member__pointer.html">is_member_pointer</a>&lt;T&gt;::value</td></tr>
<tr class="separator:adbaaa5057d498812ee848f491a20649a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690a598d20472c340a3e6969d5fe58af"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a690a598d20472c340a3e6969d5fe58af"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a690a598d20472c340a3e6969d5fe58af">is_member_function_pointer_v</a> = <a class="el" href="structetl_1_1is__member__function__pointer.html">is_member_function_pointer</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a690a598d20472c340a3e6969d5fe58af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05fe5ff6b0b6727ff7c98a53e5eb1c80"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a05fe5ff6b0b6727ff7c98a53e5eb1c80"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a05fe5ff6b0b6727ff7c98a53e5eb1c80">is_member_object_pointer_v</a> = <a class="el" href="structetl_1_1is__member__object__pointer.html">is_member_object_pointer</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a05fe5ff6b0b6727ff7c98a53e5eb1c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105e2a5ac8fc634dcc71675e27e3f95e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a105e2a5ac8fc634dcc71675e27e3f95e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a105e2a5ac8fc634dcc71675e27e3f95e">is_arithmetic_v</a> = <a class="el" href="structetl_1_1is__arithmetic.html">is_arithmetic</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a105e2a5ac8fc634dcc71675e27e3f95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b1115f04c131e47ab31a50aa2194b2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af6b1115f04c131e47ab31a50aa2194b2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af6b1115f04c131e47ab31a50aa2194b2">is_fundamental_v</a> = <a class="el" href="structetl_1_1is__fundamental.html">is_fundamental</a>&lt;T&gt;::value</td></tr>
<tr class="separator:af6b1115f04c131e47ab31a50aa2194b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43d223a689de0810df63d7c223d4228"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab43d223a689de0810df63d7c223d4228"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab43d223a689de0810df63d7c223d4228">is_scalar_v</a> = <a class="el" href="structetl_1_1is__scalar.html">is_scalar</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ab43d223a689de0810df63d7c223d4228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63efd09c0ee7195824be65423adadedc"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a63efd09c0ee7195824be65423adadedc"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a63efd09c0ee7195824be65423adadedc">is_object_v</a> = <a class="el" href="structetl_1_1is__object.html">is_object</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a63efd09c0ee7195824be65423adadedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45e49677aea4d7ed533e7c73ea7f2b6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab45e49677aea4d7ed533e7c73ea7f2b6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab45e49677aea4d7ed533e7c73ea7f2b6">is_compound_v</a> = <a class="el" href="structetl_1_1is__compound.html">is_compound</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ab45e49677aea4d7ed533e7c73ea7f2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d2eef20a4d7f2fcfb333c7e5c23444"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae6d2eef20a4d7f2fcfb333c7e5c23444"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae6d2eef20a4d7f2fcfb333c7e5c23444">is_bounded_array_v</a> = <a class="el" href="structetl_1_1is__bounded__array.html">is_bounded_array</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ae6d2eef20a4d7f2fcfb333c7e5c23444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c65af89fc55014250b54559626d075"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a00c65af89fc55014250b54559626d075"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a00c65af89fc55014250b54559626d075">is_unbounded_array_v</a> = <a class="el" href="structetl_1_1is__unbounded__array.html">is_unbounded_array</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a00c65af89fc55014250b54559626d075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab616d6855ca5fc60968a153587b2b4"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:a1ab616d6855ca5fc60968a153587b2b4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1ab616d6855ca5fc60968a153587b2b4">is_constructible_v</a> = <a class="el" href="namespaceetl.html#a55bc1fa71ef93a7cd65389359e61683c">is_constructible</a>&lt;T, Args...&gt;::value</td></tr>
<tr class="separator:a1ab616d6855ca5fc60968a153587b2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a74c34b46b65c2b8fa633d1e6211b25"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:a0a74c34b46b65c2b8fa633d1e6211b25"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0a74c34b46b65c2b8fa633d1e6211b25">is_trivially_constructible_v</a> = <a class="el" href="structetl_1_1is__trivially__constructible.html">is_trivially_constructible</a>&lt;T, Args...&gt;::value</td></tr>
<tr class="separator:a0a74c34b46b65c2b8fa633d1e6211b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff5fc00d3b16aa2421ea49dae4e864e"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:a4ff5fc00d3b16aa2421ea49dae4e864e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4ff5fc00d3b16aa2421ea49dae4e864e">is_nothrow_constructible_v</a> = <a class="el" href="structetl_1_1is__nothrow__constructible.html">is_nothrow_constructible</a>&lt;T, Args...&gt;::value</td></tr>
<tr class="separator:a4ff5fc00d3b16aa2421ea49dae4e864e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0093a625b8acbeac1878b9a9668a2563"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0093a625b8acbeac1878b9a9668a2563"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0093a625b8acbeac1878b9a9668a2563">is_default_constructible_v</a> = <a class="el" href="structetl_1_1is__default__constructible.html">is_default_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a0093a625b8acbeac1878b9a9668a2563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f37ab88cda78781a7aca13f18adac97"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6f37ab88cda78781a7aca13f18adac97"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6f37ab88cda78781a7aca13f18adac97">is_trivially_default_constructible_v</a> = <a class="el" href="structetl_1_1is__trivially__default__constructible.html">is_trivially_default_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a6f37ab88cda78781a7aca13f18adac97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e312d7578609fe1f21277a6d7a1606"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a12e312d7578609fe1f21277a6d7a1606"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a12e312d7578609fe1f21277a6d7a1606">is_nothrow_default_constructible_v</a> = <a class="el" href="structetl_1_1is__nothrow__default__constructible.html">is_nothrow_default_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a12e312d7578609fe1f21277a6d7a1606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045ef39158833b2ba6592fa8a1d0ebc1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a045ef39158833b2ba6592fa8a1d0ebc1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a045ef39158833b2ba6592fa8a1d0ebc1">is_copy_constructible_v</a> = <a class="el" href="structetl_1_1is__copy__constructible.html">is_copy_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a045ef39158833b2ba6592fa8a1d0ebc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56b91d45ec88c108b77f55e9f6bc187"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac56b91d45ec88c108b77f55e9f6bc187"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac56b91d45ec88c108b77f55e9f6bc187">is_trivially_copy_constructible_v</a> = <a class="el" href="structetl_1_1is__trivially__copy__constructible.html">is_trivially_copy_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ac56b91d45ec88c108b77f55e9f6bc187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05ca75073ae3731fef7c09200d9f693"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab05ca75073ae3731fef7c09200d9f693"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab05ca75073ae3731fef7c09200d9f693">is_nothrow_copy_constructible_v</a> = <a class="el" href="structetl_1_1is__nothrow__copy__constructible.html">is_nothrow_copy_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ab05ca75073ae3731fef7c09200d9f693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b776d5da5e25514489bfd330d7940d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a82b776d5da5e25514489bfd330d7940d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a82b776d5da5e25514489bfd330d7940d">is_move_constructible_v</a> = <a class="el" href="structetl_1_1is__move__constructible.html">is_move_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a82b776d5da5e25514489bfd330d7940d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a74767dc0b6e2022826126e3581d7ed"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6a74767dc0b6e2022826126e3581d7ed"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6a74767dc0b6e2022826126e3581d7ed">is_trivially_move_constructible_v</a> = <a class="el" href="structetl_1_1is__trivially__move__constructible.html">is_trivially_move_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a6a74767dc0b6e2022826126e3581d7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00f5b3ced7a1f4ebd3e7b1119a4c12a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac00f5b3ced7a1f4ebd3e7b1119a4c12a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac00f5b3ced7a1f4ebd3e7b1119a4c12a">is_nothrow_move_constructible_v</a> = <a class="el" href="structetl_1_1is__nothrow__move__constructible.html">is_nothrow_move_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ac00f5b3ced7a1f4ebd3e7b1119a4c12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ff2b6f5e9a98730031297120e28af4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a34ff2b6f5e9a98730031297120e28af4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a34ff2b6f5e9a98730031297120e28af4">is_destructible_v</a> = <a class="el" href="structetl_1_1is__destructible.html">is_destructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a34ff2b6f5e9a98730031297120e28af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4bab71f6cd300d48e15293f0f45eed0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad4bab71f6cd300d48e15293f0f45eed0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad4bab71f6cd300d48e15293f0f45eed0">is_trivially_destructible_v</a> = <a class="el" href="structetl_1_1is__trivially__destructible.html">is_trivially_destructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ad4bab71f6cd300d48e15293f0f45eed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92bb068a979f4237eb8c218d4f0112f2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a92bb068a979f4237eb8c218d4f0112f2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a92bb068a979f4237eb8c218d4f0112f2">is_nothrow_destructible_v</a> = <a class="el" href="structetl_1_1is__nothrow__destructible.html">is_nothrow_destructible</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a92bb068a979f4237eb8c218d4f0112f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f3f4c2468d1d1f33a449bf167efbbc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a46f3f4c2468d1d1f33a449bf167efbbc"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a46f3f4c2468d1d1f33a449bf167efbbc">has_virtual_destructor_v</a> = <a class="el" href="structetl_1_1has__virtual__destructor.html">has_virtual_destructor</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a46f3f4c2468d1d1f33a449bf167efbbc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a href="https://en.cppreference.com/w/cpp/types/has_virtual_destructor">https://en.cppreference.com/w/cpp/types/has_virtual_destructor</a>  <a href="#a46f3f4c2468d1d1f33a449bf167efbbc">More...</a><br /></td></tr>
<tr class="separator:a46f3f4c2468d1d1f33a449bf167efbbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae630f4cbcf30c3c7912d50547711e86d"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ae630f4cbcf30c3c7912d50547711e86d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ae630f4cbcf30c3c7912d50547711e86d">is_assignable_v</a> = <a class="el" href="structetl_1_1is__assignable.html">is_assignable</a>&lt;T, U&gt;::value</td></tr>
<tr class="separator:ae630f4cbcf30c3c7912d50547711e86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2cfce5bc9de7ea45285ad503a807a9b"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ad2cfce5bc9de7ea45285ad503a807a9b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad2cfce5bc9de7ea45285ad503a807a9b">is_trivially_assignable_v</a> = <a class="el" href="structetl_1_1is__trivially__assignable.html">is_trivially_assignable</a>&lt;T, U&gt;::value</td></tr>
<tr class="separator:ad2cfce5bc9de7ea45285ad503a807a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865b2c54ee24d227ee6f222e49fd076c"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a865b2c54ee24d227ee6f222e49fd076c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a865b2c54ee24d227ee6f222e49fd076c">is_nothrow_assignable_v</a> = <a class="el" href="structetl_1_1is__nothrow__assignable.html">is_nothrow_assignable</a>&lt;T, U&gt;::value</td></tr>
<tr class="separator:a865b2c54ee24d227ee6f222e49fd076c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e13a2d8cce95954bee3d62ec059851"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a17e13a2d8cce95954bee3d62ec059851"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a17e13a2d8cce95954bee3d62ec059851">is_copy_assignable_v</a> = <a class="el" href="structetl_1_1is__copy__assignable.html">is_copy_assignable</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a17e13a2d8cce95954bee3d62ec059851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4028d9154b8d629e56fd488b33587786"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4028d9154b8d629e56fd488b33587786"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4028d9154b8d629e56fd488b33587786">is_trivially_copy_assignable_v</a> = <a class="el" href="structetl_1_1is__trivially__copy__assignable.html">is_trivially_copy_assignable</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a4028d9154b8d629e56fd488b33587786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5684c28598fd5bde573fccdf36cccda9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5684c28598fd5bde573fccdf36cccda9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5684c28598fd5bde573fccdf36cccda9">is_nothrow_copy_assignable_v</a> = <a class="el" href="structetl_1_1is__nothrow__copy__assignable.html">is_nothrow_copy_assignable</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a5684c28598fd5bde573fccdf36cccda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad208b3b6c99d59cdc5d698310e59143e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad208b3b6c99d59cdc5d698310e59143e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad208b3b6c99d59cdc5d698310e59143e">is_move_assignable_v</a> = <a class="el" href="structetl_1_1is__move__assignable.html">is_move_assignable</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ad208b3b6c99d59cdc5d698310e59143e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3673480825caede3c2d5095f8a39fe0d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3673480825caede3c2d5095f8a39fe0d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3673480825caede3c2d5095f8a39fe0d">is_trivially_move_assignable_v</a> = <a class="el" href="structetl_1_1is__trivially__move__assignable.html">is_trivially_move_assignable</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a3673480825caede3c2d5095f8a39fe0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d18b577003e8d090a82e4c6d497cdd"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab5d18b577003e8d090a82e4c6d497cdd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab5d18b577003e8d090a82e4c6d497cdd">is_nothrow_move_assignable_v</a> = <a class="el" href="structetl_1_1is__nothrow__move__assignable.html">is_nothrow_move_assignable</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ab5d18b577003e8d090a82e4c6d497cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46cb1671f31576cce07cf1bac1e99f7c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a46cb1671f31576cce07cf1bac1e99f7c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a46cb1671f31576cce07cf1bac1e99f7c">is_swappable_v</a> = <a class="el" href="structetl_1_1is__swappable.html">is_swappable</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a46cb1671f31576cce07cf1bac1e99f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe0a7655d7b161139e48f8eb34838ac"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4fe0a7655d7b161139e48f8eb34838ac"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4fe0a7655d7b161139e48f8eb34838ac">is_nothrow_swappable_v</a> = <a class="el" href="structetl_1_1is__nothrow__swappable.html">is_nothrow_swappable</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a4fe0a7655d7b161139e48f8eb34838ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3b937c99443cbaf5f1817d061261bd"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5b3b937c99443cbaf5f1817d061261bd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5b3b937c99443cbaf5f1817d061261bd">is_trivially_copyable_v</a> = <a class="el" href="classetl_1_1is__trivially__copyable.html">is_trivially_copyable</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a5b3b937c99443cbaf5f1817d061261bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc5a4c4924b529a3f8760925c283ce6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1dc5a4c4924b529a3f8760925c283ce6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1dc5a4c4924b529a3f8760925c283ce6">is_trivial_v</a> = <a class="el" href="structetl_1_1is__trivial.html">is_trivial</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a1dc5a4c4924b529a3f8760925c283ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbd05dc09b68b19c63d7b4fbf6f1108"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3bbd05dc09b68b19c63d7b4fbf6f1108"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3bbd05dc09b68b19c63d7b4fbf6f1108">is_unsigned_v</a> = <a class="el" href="structetl_1_1is__unsigned.html">is_unsigned</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a3bbd05dc09b68b19c63d7b4fbf6f1108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3fadd2a1e349c45f524ab5444220ff"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aff3fadd2a1e349c45f524ab5444220ff"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aff3fadd2a1e349c45f524ab5444220ff">is_signed_v</a> = <a class="el" href="structetl_1_1is__signed.html">is_signed</a>&lt;T&gt;::value</td></tr>
<tr class="separator:aff3fadd2a1e349c45f524ab5444220ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00bab8d0b02bcb2974969b9d69639bb"><td class="memTemplParams" colspan="2">template&lt;class Base , class Derived &gt; </td></tr>
<tr class="memitem:af00bab8d0b02bcb2974969b9d69639bb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af00bab8d0b02bcb2974969b9d69639bb">is_base_of_v</a> = <a class="el" href="structetl_1_1is__base__of.html">is_base_of</a>&lt;Base, Derived&gt;::value</td></tr>
<tr class="separator:af00bab8d0b02bcb2974969b9d69639bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56baa007c444a18e18b603a55d9957bf"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a56baa007c444a18e18b603a55d9957bf"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">etl::size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a56baa007c444a18e18b603a55d9957bf">rank_v</a> = <a class="el" href="structetl_1_1rank.html">rank</a>&lt;Type&gt;::value</td></tr>
<tr class="separator:a56baa007c444a18e18b603a55d9957bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15279e84c7ec40ef8a2d460b81b7fb7"><td class="memTemplParams" colspan="2">template&lt;class From , class To &gt; </td></tr>
<tr class="memitem:aa15279e84c7ec40ef8a2d460b81b7fb7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa15279e84c7ec40ef8a2d460b81b7fb7">is_convertible_v</a> = <a class="el" href="structetl_1_1is__convertible.html">is_convertible</a>&lt;From, To&gt;::value</td></tr>
<tr class="separator:aa15279e84c7ec40ef8a2d460b81b7fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69282b501974163cc5557d48739f21c4"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structetl_1_1piecewise__construct__t.html">piecewise_construct_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a69282b501974163cc5557d48739f21c4">piecewise_construct</a> {}</td></tr>
<tr class="memdesc:a69282b501974163cc5557d48739f21c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constant <a class="el" href="namespaceetl.html#a69282b501974163cc5557d48739f21c4" title="The constant etl::piecewise_construct is an instance of an empty struct tag type etl::piecewise_const...">etl::piecewise_construct</a> is an instance of an empty struct tag type <a class="el" href="structetl_1_1piecewise__construct__t.html" title="etl::piecewise_construct_t is an empty class tag type used to disambiguate between different function...">etl::piecewise_construct_t</a>.  <a href="#a69282b501974163cc5557d48739f21c4">More...</a><br /></td></tr>
<tr class="separator:a69282b501974163cc5557d48739f21c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2e748d9aa9eee89e9ae27c1783dbea"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4e2e748d9aa9eee89e9ae27c1783dbea">in_place</a> = <a class="el" href="structetl_1_1in__place__t.html">in_place_t</a> {}</td></tr>
<tr class="separator:a4e2e748d9aa9eee89e9ae27c1783dbea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9c16f25058085d7b41037104bfea25"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9e9c16f25058085d7b41037104bfea25"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a9e9c16f25058085d7b41037104bfea25">in_place_type</a> = <a class="el" href="structetl_1_1in__place__type__t.html">in_place_type_t</a>&lt;T&gt; {}</td></tr>
<tr class="separator:a9e9c16f25058085d7b41037104bfea25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c179dea2a5063201728cd0823d49e4f"><td class="memTemplParams" colspan="2">template&lt;size_t I&gt; </td></tr>
<tr class="memitem:a1c179dea2a5063201728cd0823d49e4f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1c179dea2a5063201728cd0823d49e4f">in_place_index</a> = <a class="el" href="structetl_1_1in__place__index__t.html">in_place_index_t</a>&lt;I&gt; {}</td></tr>
<tr class="separator:a1c179dea2a5063201728cd0823d49e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d369052fc23b452882a9fd514abb87"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a28d369052fc23b452882a9fd514abb87">variant_npos</a> = static_cast&lt;<a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">etl::size_t</a>&gt;(-1)</td></tr>
<tr class="memdesc:a28d369052fc23b452882a9fd514abb87"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a special value equal to the largest value representable by the type <a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">etl::size_t</a>, used as the return value of index() when valueless_by_exception() is true.  <a href="#a28d369052fc23b452882a9fd514abb87">More...</a><br /></td></tr>
<tr class="separator:a28d369052fc23b452882a9fd514abb87"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace for the etl library. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a20607674e1e3cd49d5f0b815b33b2c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20607674e1e3cd49d5f0b815b33b2c1d">&#9670;&nbsp;</a></span>add_const_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a20607674e1e3cd49d5f0b815b33b2c1d">etl::add_const_t</a> = typedef typename <a class="el" href="structetl_1_1add__const.html">add_const</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a40eedf5bef2e5ff8e5c7ca337cdc3ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40eedf5bef2e5ff8e5c7ca337cdc3ee1">&#9670;&nbsp;</a></span>add_cv_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a40eedf5bef2e5ff8e5c7ca337cdc3ee1">etl::add_cv_t</a> = typedef typename <a class="el" href="structetl_1_1add__cv.html">add_cv</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a662329de2bc2a83d5e45d1ccad797f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a662329de2bc2a83d5e45d1ccad797f17">&#9670;&nbsp;</a></span>add_lvalue_reference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a662329de2bc2a83d5e45d1ccad797f17">etl::add_lvalue_reference_t</a> = typedef typename <a class="el" href="structetl_1_1add__lvalue__reference.html">add_lvalue_reference</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afd20d67cb221212f49a97e02a7c1ca25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd20d67cb221212f49a97e02a7c1ca25">&#9670;&nbsp;</a></span>add_pointer_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#afd20d67cb221212f49a97e02a7c1ca25">etl::add_pointer_t</a> = typedef typename <a class="el" href="structetl_1_1add__pointer.html">add_pointer</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a17c37a443b0cb66dc9b3c4374967b68f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c37a443b0cb66dc9b3c4374967b68f">&#9670;&nbsp;</a></span>add_rvalue_reference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a17c37a443b0cb66dc9b3c4374967b68f">etl::add_rvalue_reference_t</a> = typedef typename <a class="el" href="structetl_1_1add__rvalue__reference.html">add_rvalue_reference</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e3ae65a8164f8204c7f0ab6076b2cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e3ae65a8164f8204c7f0ab6076b2cbc">&#9670;&nbsp;</a></span>add_volatile_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a4e3ae65a8164f8204c7f0ab6076b2cbc">etl::add_volatile_t</a> = typedef typename <a class="el" href="structetl_1_1add__volatile.html">add_volatile</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a16ded42403ee495bd465c070c0262b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16ded42403ee495bd465c070c0262b8a">&#9670;&nbsp;</a></span>aligned_storage_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t Len, etl::size_t Align = alignof(etl::max_align_t)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a16ded42403ee495bd465c070c0262b8a">etl::aligned_storage_t</a> = typedef typename <a class="el" href="structetl_1_1aligned__storage.html">aligned_storage</a>&lt;Len, Align&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7cc2ccd245f477d45cf1f6957c8f8993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc2ccd245f477d45cf1f6957c8f8993">&#9670;&nbsp;</a></span>atto</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a7cc2ccd245f477d45cf1f6957c8f8993">etl::atto</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000'000'000'000'000&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa19ff9e7939158584698cee4260e4471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa19ff9e7939158584698cee4260e4471">&#9670;&nbsp;</a></span>bool_constant</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool B&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#aa19ff9e7939158584698cee4260e4471">etl::bool_constant</a> = typedef <a class="el" href="structetl_1_1integral__constant.html">integral_constant</a>&lt;bool, B&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a95d8c20c69482c794a0cfb9e4428ca8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d8c20c69482c794a0cfb9e4428ca8d">&#9670;&nbsp;</a></span>centi</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a95d8c20c69482c794a0cfb9e4428ca8d">etl::centi</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 100&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac80571ce0a1bbafdb4d8e153ceade9e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac80571ce0a1bbafdb4d8e153ceade9e3">&#9670;&nbsp;</a></span>common_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#ac80571ce0a1bbafdb4d8e153ceade9e3">etl::common_type_t</a> = typedef typename <a class="el" href="structetl_1_1common__type.html">common_type</a>&lt;T...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa508ba172c61957cf6c18357210f08f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa508ba172c61957cf6c18357210f08f6">&#9670;&nbsp;</a></span>conditional_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool B, class T , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#aa508ba172c61957cf6c18357210f08f6">etl::conditional_t</a> = typedef typename <a class="el" href="structetl_1_1conditional.html">conditional</a>&lt;B, T, F&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acae5b099e4ead54343e6304a6371985b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae5b099e4ead54343e6304a6371985b">&#9670;&nbsp;</a></span>deca</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#acae5b099e4ead54343e6304a6371985b">etl::deca</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;10, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad602447fa93ad71f4db547fa0ae92883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad602447fa93ad71f4db547fa0ae92883">&#9670;&nbsp;</a></span>decay_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#ad602447fa93ad71f4db547fa0ae92883">etl::decay_t</a> = typedef typename <a class="el" href="structetl_1_1decay.html">decay</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a59f2e2c10ab4b06ed261d1e4a8358895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f2e2c10ab4b06ed261d1e4a8358895">&#9670;&nbsp;</a></span>deci</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a59f2e2c10ab4b06ed261d1e4a8358895">etl::deci</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 10&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c91cfdd41de11ccf80532067354fe92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c91cfdd41de11ccf80532067354fe92">&#9670;&nbsp;</a></span>double_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a9c91cfdd41de11ccf80532067354fe92">etl::double_t</a> = typedef double</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Most efficient floating-point type at least as wide as double. </p>

</div>
</div>
<a id="a2a2df4ab89284c8c5866afea3100f290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a2df4ab89284c8c5866afea3100f290">&#9670;&nbsp;</a></span>enable_if_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool B, class T  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a> = typedef typename <a class="el" href="structetl_1_1enable__if.html">enable_if</a>&lt;B, T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a525a461cc6d062b7138a777cadacac47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a525a461cc6d062b7138a777cadacac47">&#9670;&nbsp;</a></span>exa</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a525a461cc6d062b7138a777cadacac47">etl::exa</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000'000'000'000'000, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a466dc202e27dec8fa05a9fcc6ef47e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a466dc202e27dec8fa05a9fcc6ef47e27">&#9670;&nbsp;</a></span>false_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a466dc202e27dec8fa05a9fcc6ef47e27">etl::false_type</a> = typedef <a class="el" href="namespaceetl.html#aa19ff9e7939158584698cee4260e4471">bool_constant</a>&lt;false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a837dad904f094bc29e24139565eec1c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a837dad904f094bc29e24139565eec1c5">&#9670;&nbsp;</a></span>femto</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a837dad904f094bc29e24139565eec1c5">etl::femto</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000'000'000'000&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a04532556e568bb7cc276440befc7f441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04532556e568bb7cc276440befc7f441">&#9670;&nbsp;</a></span>float_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a04532556e568bb7cc276440befc7f441">etl::float_t</a> = typedef float</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Most efficient floating-point type at least as wide as float. </p>

</div>
</div>
<a id="aeaa010c22727dfd8ede60afef156650c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa010c22727dfd8ede60afef156650c">&#9670;&nbsp;</a></span>giga</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#aeaa010c22727dfd8ede60afef156650c">etl::giga</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000'000, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aba04e5fa0d29bc9f6a9f3fa4f9ff3dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba04e5fa0d29bc9f6a9f3fa4f9ff3dbb">&#9670;&nbsp;</a></span>hecto</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#aba04e5fa0d29bc9f6a9f3fa4f9ff3dbb">etl::hecto</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;100, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ffe3c07a4dbbe98792f1936145c6876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ffe3c07a4dbbe98792f1936145c6876">&#9670;&nbsp;</a></span>int16_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a3ffe3c07a4dbbe98792f1936145c6876">etl::int16_t</a> = typedef <a class="el" href="namespaceetl.html#a3ffe3c07a4dbbe98792f1936145c6876">int16_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae779a40ac9323d2b0729f8bb95cf0fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae779a40ac9323d2b0729f8bb95cf0fd1">&#9670;&nbsp;</a></span>int32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#ae779a40ac9323d2b0729f8bb95cf0fd1">etl::int32_t</a> = typedef <a class="el" href="namespaceetl.html#ae779a40ac9323d2b0729f8bb95cf0fd1">int32_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adc4b499f2d2820b8af24be768343759b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc4b499f2d2820b8af24be768343759b">&#9670;&nbsp;</a></span>int64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#adc4b499f2d2820b8af24be768343759b">etl::int64_t</a> = typedef <a class="el" href="namespaceetl.html#adc4b499f2d2820b8af24be768343759b">int64_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afd99b481983335f785f7713b9bb4f436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd99b481983335f785f7713b9bb4f436">&#9670;&nbsp;</a></span>int8_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#afd99b481983335f785f7713b9bb4f436">etl::int8_t</a> = typedef <a class="el" href="namespaceetl.html#afd99b481983335f785f7713b9bb4f436">int8_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a178a2082210268baa21de6920cf2de96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178a2082210268baa21de6920cf2de96">&#9670;&nbsp;</a></span>intmax_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a178a2082210268baa21de6920cf2de96">etl::intmax_t</a> = typedef <a class="el" href="namespaceetl.html#a178a2082210268baa21de6920cf2de96">intmax_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4e71dd55b5fc087ed6ffc22b06b1543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e71dd55b5fc087ed6ffc22b06b1543">&#9670;&nbsp;</a></span>intptr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#aa4e71dd55b5fc087ed6ffc22b06b1543">etl::intptr_t</a> = typedef <a class="el" href="namespaceetl.html#aa4e71dd55b5fc087ed6ffc22b06b1543">intptr_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a55bc1fa71ef93a7cd65389359e61683c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55bc1fa71ef93a7cd65389359e61683c">&#9670;&nbsp;</a></span>is_constructible</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a55bc1fa71ef93a7cd65389359e61683c">etl::is_constructible</a> = typedef detail::is_constructible_helper&lt;<a class="el" href="namespaceetl.html#a8f76cc2621d7373b79e2fc034f160ee0">void_t</a>&lt;&gt;, T, Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae0f7df2b4a088f13d067ec91336ad6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0f7df2b4a088f13d067ec91336ad6d8">&#9670;&nbsp;</a></span>kilo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#ae0f7df2b4a088f13d067ec91336ad6d8">etl::kilo</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abffe34c79351f871acb3e0438b2ad488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abffe34c79351f871acb3e0438b2ad488">&#9670;&nbsp;</a></span>make_signed_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#abffe34c79351f871acb3e0438b2ad488">etl::make_signed_t</a> = typedef typename <a class="el" href="structetl_1_1make__signed.html">make_signed</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acb2df53f4e399975501cf8300d451814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb2df53f4e399975501cf8300d451814">&#9670;&nbsp;</a></span>make_unsigned_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#acb2df53f4e399975501cf8300d451814">etl::make_unsigned_t</a> = typedef typename <a class="el" href="structetl_1_1make__unsigned.html">make_unsigned</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afb8b8f156e99d25877de869998eca882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb8b8f156e99d25877de869998eca882">&#9670;&nbsp;</a></span>mega</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#afb8b8f156e99d25877de869998eca882">etl::mega</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a56ee5013d725632677b4d1d93204c07b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56ee5013d725632677b4d1d93204c07b">&#9670;&nbsp;</a></span>micro</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a56ee5013d725632677b4d1d93204c07b">etl::micro</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc43923bf9757db3bbaa5a6e4d36a3c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc43923bf9757db3bbaa5a6e4d36a3c6">&#9670;&nbsp;</a></span>milli</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#afc43923bf9757db3bbaa5a6e4d36a3c6">etl::milli</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab16ea857b72e93345fcd6fb255f7fe86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab16ea857b72e93345fcd6fb255f7fe86">&#9670;&nbsp;</a></span>nano</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#ab16ea857b72e93345fcd6fb255f7fe86">etl::nano</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000'000&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adf4272f3f16bf2234ac8248db615f133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf4272f3f16bf2234ac8248db615f133">&#9670;&nbsp;</a></span>nullptr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#adf4272f3f16bf2234ac8248db615f133">etl::nullptr_t</a> = typedef decltype(nullptr)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac2de582631c8b0507fa316267f24ae3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2de582631c8b0507fa316267f24ae3b">&#9670;&nbsp;</a></span>peta</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#ac2de582631c8b0507fa316267f24ae3b">etl::peta</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000'000'000'000, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab85e2cc66c84a64edf096334ea68d82f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab85e2cc66c84a64edf096334ea68d82f">&#9670;&nbsp;</a></span>pico</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#ab85e2cc66c84a64edf096334ea68d82f">etl::pico</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1, 1'000'000'000'000&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a56e0abf50b318376b511f461e8baca33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56e0abf50b318376b511f461e8baca33">&#9670;&nbsp;</a></span>ptrdiff_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a56e0abf50b318376b511f461e8baca33">etl::ptrdiff_t</a> = typedef <a class="el" href="namespaceetl.html#a56e0abf50b318376b511f461e8baca33">ptrdiff_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a515e08f8ce11f32a154acd83b2fe6b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515e08f8ce11f32a154acd83b2fe6b00">&#9670;&nbsp;</a></span>ratio_add</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R1 , class R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a515e08f8ce11f32a154acd83b2fe6b00">etl::ratio_add</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;R1::num * R2::den + R2::num * R1::den, R1::den * R2::den&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The alias template <a class="el" href="namespaceetl.html#a515e08f8ce11f32a154acd83b2fe6b00" title="The alias template etl::ratio_add denotes the result of adding two exact rational fractions represent...">etl::ratio_add</a> denotes the result of adding two exact rational fractions represented by the <a class="el" href="structetl_1_1ratio.html" title="The class template provides compile-time rational arithmetic support. Each instantiation of this temp...">etl::ratio</a> specializations R1 and R2. </p>
<p>The result is a <a class="el" href="structetl_1_1ratio.html" title="The class template provides compile-time rational arithmetic support. Each instantiation of this temp...">etl::ratio</a> specialization etl::ratio&lt;U, V&gt;, such that given Num == R1::num * R2::den + R2::num * R1::den and Denom == R1::den * R2::den (computed without arithmetic overflow), U is <a class="el" href="structetl_1_1ratio.html#a15ad9bea294aeeba2f02f33ec0283065">etl::ratio&lt;Num, Denom&gt;::num</a> and V is <a class="el" href="structetl_1_1ratio.html#acb49b27bde07d5c4878c5347454a0044">etl::ratio&lt;Num, Denom&gt;::den</a>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>Check overflow. </dd></dl>

</div>
</div>
<a id="a420acf1424e7ed7ae82f703ac31ff258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420acf1424e7ed7ae82f703ac31ff258">&#9670;&nbsp;</a></span>ratio_divide</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R1 , class R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a420acf1424e7ed7ae82f703ac31ff258">etl::ratio_divide</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;R1::num * R2::den, R1::den * R2::num&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The alias template <a class="el" href="namespaceetl.html#a420acf1424e7ed7ae82f703ac31ff258" title="The alias template etl::ratio_divide denotes the result of dividing two exact rational fractions repr...">etl::ratio_divide</a> denotes the result of dividing two exact rational fractions represented by the <a class="el" href="structetl_1_1ratio.html" title="The class template provides compile-time rational arithmetic support. Each instantiation of this temp...">etl::ratio</a> specializations R1 and R2. </p>
<p>The result is a <a class="el" href="structetl_1_1ratio.html" title="The class template provides compile-time rational arithmetic support. Each instantiation of this temp...">etl::ratio</a> specialization etl::ratio&lt;U, V&gt;, such that given Num == R1::num * R2::den and Denom == R1::den * R2::num (computed without arithmetic overflow), U is <a class="el" href="structetl_1_1ratio.html#a15ad9bea294aeeba2f02f33ec0283065">etl::ratio&lt;Num, Denom&gt;::num</a> and V is <a class="el" href="structetl_1_1ratio.html#acb49b27bde07d5c4878c5347454a0044">etl::ratio&lt;Num, Denom&gt;::den</a>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000013">Todo:</a></b></dt><dd>Check overflow. </dd></dl>

</div>
</div>
<a id="abbdaf3b94f7cb0830c812d5c8aabbe0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbdaf3b94f7cb0830c812d5c8aabbe0b">&#9670;&nbsp;</a></span>ratio_multiply</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R1 , class R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#abbdaf3b94f7cb0830c812d5c8aabbe0b">etl::ratio_multiply</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;R1::num * R2::num, R1::den * R2::den&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The alias template <a class="el" href="namespaceetl.html#abbdaf3b94f7cb0830c812d5c8aabbe0b" title="The alias template etl::ratio_multiply denotes the result of multiplying two exact rational fractions...">etl::ratio_multiply</a> denotes the result of multiplying two exact rational fractions represented by the <a class="el" href="structetl_1_1ratio.html" title="The class template provides compile-time rational arithmetic support. Each instantiation of this temp...">etl::ratio</a> specializations R1 and R2. </p>
<p>The result is a <a class="el" href="structetl_1_1ratio.html" title="The class template provides compile-time rational arithmetic support. Each instantiation of this temp...">etl::ratio</a> specialization etl::ratio&lt;U, V&gt;, such that given Num == R1::num * R2::num and Denom == R1::den * R2::den (computed without arithmetic overflow), U is <a class="el" href="structetl_1_1ratio.html#a15ad9bea294aeeba2f02f33ec0283065">etl::ratio&lt;Num, Denom&gt;::num</a> and V is <a class="el" href="structetl_1_1ratio.html#acb49b27bde07d5c4878c5347454a0044">etl::ratio&lt;Num, Denom&gt;::den</a>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000012">Todo:</a></b></dt><dd>Check overflow. </dd></dl>

</div>
</div>
<a id="a234acc6c1438740afe4f7766f1208784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234acc6c1438740afe4f7766f1208784">&#9670;&nbsp;</a></span>ratio_subtract</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R1 , class R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a234acc6c1438740afe4f7766f1208784">etl::ratio_subtract</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;R1::num * R2::den - R2::num * R1::den, R1::den * R2::den&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The alias template <a class="el" href="namespaceetl.html#a234acc6c1438740afe4f7766f1208784" title="The alias template etl::ratio_subtract denotes the result of subtracting two exact rational fractions...">etl::ratio_subtract</a> denotes the result of subtracting two exact rational fractions represented by the <a class="el" href="structetl_1_1ratio.html" title="The class template provides compile-time rational arithmetic support. Each instantiation of this temp...">etl::ratio</a> specializations R1 and R2. </p>
<p>The result is a <a class="el" href="structetl_1_1ratio.html" title="The class template provides compile-time rational arithmetic support. Each instantiation of this temp...">etl::ratio</a> specialization etl::ratio&lt;U, V&gt;, such that given Num == R1::num * R2::den - R2::num * R1::den and Denom == R1::den * R2::den (computed without arithmetic overflow), U is <a class="el" href="structetl_1_1ratio.html#a15ad9bea294aeeba2f02f33ec0283065">etl::ratio&lt;Num, Denom&gt;::num</a> and V is <a class="el" href="structetl_1_1ratio.html#acb49b27bde07d5c4878c5347454a0044">etl::ratio&lt;Num, Denom&gt;::den</a>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000011">Todo:</a></b></dt><dd>Check overflow. </dd></dl>

</div>
</div>
<a id="a96e53fc126f7c9ebf9901856b9c2db22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96e53fc126f7c9ebf9901856b9c2db22">&#9670;&nbsp;</a></span>remove_all_extents_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a96e53fc126f7c9ebf9901856b9c2db22">etl::remove_all_extents_t</a> = typedef typename <a class="el" href="structetl_1_1remove__all__extents.html">remove_all_extents</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If T is a multidimensional array of some type X, provides the member typedef type equal to X, otherwise type is T. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1remove__all__extents.html" title="If T is a multidimensional array of some type X, provides the member typedef type equal to X...">remove_all_extents</a> is undefined. </p>

</div>
</div>
<a id="a87e058aba499e52cc4ed554dd7d65332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e058aba499e52cc4ed554dd7d65332">&#9670;&nbsp;</a></span>remove_const_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a87e058aba499e52cc4ed554dd7d65332">etl::remove_const_t</a> = typedef typename <a class="el" href="structetl_1_1remove__const.html">remove_const</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a70fb46b3c4c98f5f23b76cb25f343373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70fb46b3c4c98f5f23b76cb25f343373">&#9670;&nbsp;</a></span>remove_cv_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a70fb46b3c4c98f5f23b76cb25f343373">etl::remove_cv_t</a> = typedef typename <a class="el" href="structetl_1_1remove__cv.html">remove_cv</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad85fb8c9d4542d450aa421f420184ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad85fb8c9d4542d450aa421f420184ca1">&#9670;&nbsp;</a></span>remove_cvref_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#ad85fb8c9d4542d450aa421f420184ca1">etl::remove_cvref_t</a> = typedef typename <a class="el" href="structetl_1_1remove__cvref.html">remove_cvref</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2368185596474aaf04490908f75e3a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2368185596474aaf04490908f75e3a18">&#9670;&nbsp;</a></span>remove_extent_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a2368185596474aaf04490908f75e3a18">etl::remove_extent_t</a> = typedef typename <a class="el" href="structetl_1_1remove__extent.html">remove_extent</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7dab9cb6af8b33ea5f7c09c58e75bfb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dab9cb6af8b33ea5f7c09c58e75bfb7">&#9670;&nbsp;</a></span>remove_pointer_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a7dab9cb6af8b33ea5f7c09c58e75bfb7">etl::remove_pointer_t</a> = typedef typename <a class="el" href="structetl_1_1remove__pointer.html">remove_pointer</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a26ceb8de4fe37ef6a14f78dd10d95bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ceb8de4fe37ef6a14f78dd10d95bb6">&#9670;&nbsp;</a></span>remove_reference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a26ceb8de4fe37ef6a14f78dd10d95bb6">etl::remove_reference_t</a> = typedef typename <a class="el" href="structetl_1_1remove__reference.html">remove_reference</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af4593c7817c464ffa0d88cc07eb35e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4593c7817c464ffa0d88cc07eb35e83">&#9670;&nbsp;</a></span>remove_volatile_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#af4593c7817c464ffa0d88cc07eb35e83">etl::remove_volatile_t</a> = typedef typename <a class="el" href="structetl_1_1remove__volatile.html">remove_volatile</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac853a6316b146d25fdfbb5865821cedd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac853a6316b146d25fdfbb5865821cedd">&#9670;&nbsp;</a></span>size_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">etl::size_t</a> = typedef <a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">size_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9bffa043c410459eda373247f384b9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bffa043c410459eda373247f384b9e2">&#9670;&nbsp;</a></span>small_string</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a9bffa043c410459eda373247f384b9e2">etl::small_string</a> = typedef <a class="el" href="classetl_1_1basic__string.html">basic_string</a>&lt;char, 32&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a38946ce496aa3f045c07f32b2e4ca374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38946ce496aa3f045c07f32b2e4ca374">&#9670;&nbsp;</a></span>streamoff</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a38946ce496aa3f045c07f32b2e4ca374">etl::streamoff</a> = typedef int</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af2769dde06d41131748597077535e2cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2769dde06d41131748597077535e2cc">&#9670;&nbsp;</a></span>string</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t Capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#af2769dde06d41131748597077535e2cc">etl::string</a> = typedef <a class="el" href="classetl_1_1basic__string.html">basic_string</a>&lt;char, Capacity&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a41ec92a1e825e31fc024b95f85aed1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ec92a1e825e31fc024b95f85aed1da">&#9670;&nbsp;</a></span>string_view</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a41ec92a1e825e31fc024b95f85aed1da">etl::string_view</a> = typedef <a class="el" href="classetl_1_1basic__string__view.html">basic_string_view</a>&lt;char, <a class="el" href="structetl_1_1char__traits.html">etl::char_traits</a>&lt;char&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedefs for common character type. </p>

</div>
</div>
<a id="a9d864adecb109d82a13a134020536ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d864adecb109d82a13a134020536ce7">&#9670;&nbsp;</a></span>tera</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a9d864adecb109d82a13a134020536ce7">etl::tera</a> = typedef <a class="el" href="structetl_1_1ratio.html">ratio</a>&lt;1'000'000'000'000, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa107a29afbb5288d6dceb9fae86b07b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa107a29afbb5288d6dceb9fae86b07b8">&#9670;&nbsp;</a></span>true_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#aa107a29afbb5288d6dceb9fae86b07b8">etl::true_type</a> = typedef <a class="el" href="namespaceetl.html#aa19ff9e7939158584698cee4260e4471">bool_constant</a>&lt;true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af61de6f15f82704d69a80d859a757298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61de6f15f82704d69a80d859a757298">&#9670;&nbsp;</a></span>uint16_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#af61de6f15f82704d69a80d859a757298">etl::uint16_t</a> = typedef <a class="el" href="namespaceetl.html#af61de6f15f82704d69a80d859a757298">uint16_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8e6df1710afc95336b7bee2714144b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e6df1710afc95336b7bee2714144b2">&#9670;&nbsp;</a></span>uint32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#ac8e6df1710afc95336b7bee2714144b2">etl::uint32_t</a> = typedef <a class="el" href="namespaceetl.html#ac8e6df1710afc95336b7bee2714144b2">uint32_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc782f054552345b4cd2428dbc92a4ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc782f054552345b4cd2428dbc92a4ca">&#9670;&nbsp;</a></span>uint64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#afc782f054552345b4cd2428dbc92a4ca">etl::uint64_t</a> = typedef <a class="el" href="namespaceetl.html#afc782f054552345b4cd2428dbc92a4ca">uint64_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a001f884b28f990ecdc3543a19440befb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a001f884b28f990ecdc3543a19440befb">&#9670;&nbsp;</a></span>uint8_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a001f884b28f990ecdc3543a19440befb">etl::uint8_t</a> = typedef <a class="el" href="namespaceetl.html#a001f884b28f990ecdc3543a19440befb">uint8_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a91f7969d130419941da3aeccefc32e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f7969d130419941da3aeccefc32e6a">&#9670;&nbsp;</a></span>uintmax_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a91f7969d130419941da3aeccefc32e6a">etl::uintmax_t</a> = typedef <a class="el" href="namespaceetl.html#a91f7969d130419941da3aeccefc32e6a">uintmax_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2fca78d7da557daded3df9fbffccc06c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fca78d7da557daded3df9fbffccc06c">&#9670;&nbsp;</a></span>uintptr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a2fca78d7da557daded3df9fbffccc06c">etl::uintptr_t</a> = typedef <a class="el" href="namespaceetl.html#a2fca78d7da557daded3df9fbffccc06c">uintptr_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aef7110ca07ee5b481d99d9ae57a977ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef7110ca07ee5b481d99d9ae57a977ed">&#9670;&nbsp;</a></span>variant_alternative_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#aef7110ca07ee5b481d99d9ae57a977ed">etl::variant_alternative_t</a> = typedef typename <a class="el" href="structetl_1_1variant__alternative.html">variant_alternative</a>&lt;I, T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f76cc2621d7373b79e2fc034f160ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f76cc2621d7373b79e2fc034f160ee0">&#9670;&nbsp;</a></span>void_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceetl.html#a8f76cc2621d7373b79e2fc034f160ee0">etl::void_t</a> = typedef void</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a3fe360a11ae9b0c5886f80ce2ff28a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe360a11ae9b0c5886f80ce2ff28a9d">&#9670;&nbsp;</a></span>byte</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> : <a class="el" href="namespaceetl.html#a001f884b28f990ecdc3543a19440befb">uint8_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aadba129a7dc760f449b09b7fafeb63a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadba129a7dc760f449b09b7fafeb63a8">&#9670;&nbsp;</a></span>endian</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceetl.html#aadba129a7dc760f449b09b7fafeb63a8">etl::endian</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates the endianness of all scalar types. </p>
<p>If all scalar types are little-endian, <a class="el" href="namespaceetl.html#aadba129a7dc760f449b09b7fafeb63a8a8e5f3adee38c8fccc13c1f3be0143796">etl::endian::native</a> equals <a class="el" href="namespaceetl.html#aadba129a7dc760f449b09b7fafeb63a8aaae6635e044ac56046b2893a529b5114">etl::endian::little</a>. If all scalar types are big-endian, <a class="el" href="namespaceetl.html#aadba129a7dc760f449b09b7fafeb63a8a8e5f3adee38c8fccc13c1f3be0143796">etl::endian::native</a> equals <a class="el" href="namespaceetl.html#aadba129a7dc760f449b09b7fafeb63a8ad861877da56b8b4ceb35c8cbfdf65bb4">etl::endian::big</a></p>
<p>https://en.cppreference.com/w/cpp/types/endian </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aadba129a7dc760f449b09b7fafeb63a8aaae6635e044ac56046b2893a529b5114"></a>little&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aadba129a7dc760f449b09b7fafeb63a8ad861877da56b8b4ceb35c8cbfdf65bb4"></a>big&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aadba129a7dc760f449b09b7fafeb63a8a8e5f3adee38c8fccc13c1f3be0143796"></a>native&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="abf855e66ccd0c031e0994ed578f1c170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf855e66ccd0c031e0994ed578f1c170">&#9670;&nbsp;</a></span>errc</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170">etl::errc</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The scoped enumeration <a class="el" href="namespaceetl.html#abf855e66ccd0c031e0994ed578f1c170" title="The scoped enumeration etl::errc defines the values of portable error conditions that correspond to t...">etl::errc</a> defines the values of portable error conditions that correspond to the POSIX error codes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a8ab69162f060cc46b805b3265ad1cdf1"></a>address_family_not_supported&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a8e2bc80599069d337b43dff6edfb6891"></a>address_in_use&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a20abf2ffbf6e82e36405843f269d6438"></a>address_not_available&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170ab5580b198f691ab2df12f5e2ab974373"></a>already_connected&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a1b245b26b5ea3428c050d7f1503d7715"></a>argument_list_too_long&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a4b82222a0895b538d0597092b3ceab3e"></a>argument_out_of_domain&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170aaf169f73a82794128aa491c4b4f1c071"></a>bad_address&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a9941c5c8c58ff058b870e94e96ac38e1"></a>bad_file_descriptor&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170ac7944ab5d2e25bf75b267d070b506d1c"></a>bad_message&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a2f0338eed54503152be1d31c93c9c2f1"></a>broken_pipe&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a2f8f27a7eef1ad585c7ab6f25a6c2c79"></a>connection_aborted&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a81cf222a9b1530171fdfd66c3f734989"></a>connection_already_in_progress&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a53793ee58fc24168a0d6549c3cb2df8e"></a>connection_refused&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170abf39bfc8665384194e343c08ab344405"></a>connection_reset&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a6177070a517d51a4382ab0d7c88e5b58"></a>cross_device_link&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a326032e01f2a5e14c7f730f4d03d753a"></a>destination_address_required&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170ab3ab5338a00f49c4451851cc5442f370"></a>device_or_resource_busy&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a6a336135d33e62f49edc55f29354e12e"></a>directory_not_empty&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a4dfaf9c996cf045f32d17edc9754fc95"></a>executable_format_error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a41edf636e3c7b59f797348fc58472258"></a>file_exists&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170aa1e14bfb89b41ddf654b1772c8fd2e74"></a>file_too_large&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a6e56e6ed055b9771b8192a4f229fee27"></a>filename_too_long&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170aa33c516bbdfb179cef733c8daeb97bed"></a>function_not_supported&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170afe2377fbd16d7f335474e1df7d6376bf"></a>host_unreachable&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a054e5b4ff59331386872de744d661719"></a>identifier_removed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a53a9e57a679708b2d8ff0ccd8ec96b18"></a>illegal_byte_sequence&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a45fe7da1767194b580aeba752d7b44ae"></a>inappropriate_io_control_operation&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170afadb76763385627e57ec386c9b6038f0"></a>interrupted&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170ae55d43eabeefe5a8271b4a3c898bd18f"></a>invalid_argument&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170abd86a2c65caf6a270b916234ab321ce3"></a>invalid_seek&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170acccc32f2a5f7dc7b87d2f85daea66789"></a>io_error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170af3c51d7ea75a76f26c0a2bdc00c4e006"></a>is_a_directory&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170ade5f4bc2f8a4690176e22e83196b9fd3"></a>message_size&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a93b16d34b1689f66f0cfed60e99c0009"></a>network_down&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a0e1d200ae35ede416bf85f84093ce37a"></a>network_reset&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a608a68344b4eb1fe0690861a83828816"></a>network_unreachable&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a618ead44397b73cf0baa08b460b66c39"></a>no_buffer_space&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170ad08d4c854a6810cebd2a8ab61876f919"></a>no_child_process&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170add431dfaf61ea842693dca8be1ebcaf7"></a>no_link&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a58688487c3e24313637a76bd29881e64"></a>no_lock_available&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170aeec0f03ad92584c78835c10ab79d7f42"></a>no_message_available&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170acec935db07cfc57caafa37e98eafb213"></a>no_message&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170abed8a9032d9366c28582a0ad59a31525"></a>no_protocol_option&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a1a5334dd8d1ca56e33887bd44630641b"></a>no_space_on_device&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170ad8b1d94a0ac09c6d55b2ed68f0836142"></a>no_stream_resources&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a5c83a012eac17bbf458df5804801e373"></a>no_such_device_or_address&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170af42b2e58729e2783b683c8610977fc22"></a>no_such_device&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a2e70fc89b08f26fa3fc77694c91e8f7a"></a>no_such_file_or_directory&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170ad91a9b8a734f2bef4b778f89806cbab7"></a>no_such_process&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a21e867ca95e1dfecff4701863547dcec"></a>not_a_directory&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a22ac64bb14c46bcbc338a21950b6e722"></a>not_a_socket&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a6e752b7a04543e5052b2d0dd05eca0fa"></a>not_a_stream&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a69c2dbb5917ca550a862e9c1c839bca1"></a>not_connected&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170aafdb5594dc3e484fc1bfd7c564d550c1"></a>not_enough_memory&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170aa55e82356e9721946aa9ba954733c6f0"></a>not_supported&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170afd3d0bdcc9eb9e68534b7d055c5fe586"></a>operation_canceled&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a4c7eb50b6d86ac8a130ebebc18dbe263"></a>operation_in_progress&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a8344b3d509942f035d5e303022f9b986"></a>operation_not_permitted&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a69bf074bf052ee4c9047b62fe7c24569"></a>operation_not_supported&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a738abdaead9cd7b2e2ea19a34764b385"></a>operation_would_block&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a2abac2fa6722c56b2ea17ac6c4097f68"></a>owner_dead&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170ae8ee838822072f02738dbd7d97ea03fc"></a>permission_denied&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a9665c745d0a9132d8da6ed55e89a0564"></a>protocol_error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170aa2635acef8b9a3e1c40923829722d472"></a>protocol_not_supported&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a06108efce8ef1cd8aa4cc440f8b4317f"></a>read_only_file_system&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170aed65f7649c6f0e365673d65a9d8119d8"></a>resource_deadlock_would_occur&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170ae46a97ea2906921c8c626890bde832cf"></a>resource_unavailable_try_again&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a8e0fafb181567cc468e1ee81983d739d"></a>result_out_of_range&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a6805059549401365b824b54573a6f46e"></a>state_not_recoverable&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170ac1a620a30954dc9402a811453c2c3e3f"></a>stream_timeout&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170ad2f80f12d22bb099fcf1062db660b567"></a>text_file_busy&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a56c27b1ab1a5a5a0eae853cabb4dc0c1"></a>timed_out&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a3130d1d4e000cdc1e7c47013e313c10e"></a>too_many_files_open_in_system&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170aed2c33c8fe874cfeba6f4a7747c62d05"></a>too_many_files_open&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170abfe22fc9b27a8ff13186aba60b6bc5c8"></a>too_many_links&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a33c78baca1480479c88aa4d50cb68206"></a>too_many_symbolic_link_levels&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a143653b075bff946193644ba6d97fa5d"></a>value_too_large&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abf855e66ccd0c031e0994ed578f1c170a81cac28a38438710de9856af4a8bcd0b"></a>wrong_protocol_type&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ad4892bd9af0bd3ad759fb95ab241247c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4892bd9af0bd3ad759fb95ab241247c">&#9670;&nbsp;</a></span>float_denorm_style</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceetl.html#ad4892bd9af0bd3ad759fb95ab241247c">etl::float_denorm_style</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad4892bd9af0bd3ad759fb95ab241247cadc095ee49d9e6884cd67bc20a4c73287"></a>denorm_indeterminate&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad4892bd9af0bd3ad759fb95ab241247caf254439f29ec6166a1a6fb7b09efd141"></a>denorm_absent&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad4892bd9af0bd3ad759fb95ab241247ca5a085126714d6734d58691edaa278aa5"></a>denorm_present&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a0cdec522db16c755ade7c7222bf8af92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cdec522db16c755ade7c7222bf8af92">&#9670;&nbsp;</a></span>float_round_style</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceetl.html#a0cdec522db16c755ade7c7222bf8af92">etl::float_round_style</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0cdec522db16c755ade7c7222bf8af92afd0fa1de009f9a47f51a0ec9c23aa10b"></a>round_indeterminate&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cdec522db16c755ade7c7222bf8af92a00004115cf199c1cd29d07f78679a63d"></a>round_toward_zero&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cdec522db16c755ade7c7222bf8af92a1fc678348a02cf4262fb59153d5b73c3"></a>round_to_nearest&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cdec522db16c755ade7c7222bf8af92a274b79e7a1a164b8b9eea17dda4751c0"></a>round_toward_infinity&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cdec522db16c755ade7c7222bf8af92ac6babddc09b7dbf6e3daf12455e3417f"></a>round_toward_neg_infinity&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a3d70da9977ec456339973b30e372fcbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d70da9977ec456339973b30e372fcbd">&#9670;&nbsp;</a></span>language_standard</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceetl.html#a3d70da9977ec456339973b30e372fcbd">etl::language_standard</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration for the currently selected C++ standard version. </p>
<p>Unlike the official macro __cplusplus, these values only include the published year. This is to make the actual values smaller and therfore fit on smaller word sized chips. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3d70da9977ec456339973b30e372fcbda807ac7fd9764fb3e810d9f1048cd63ca"></a>cpp_98&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3d70da9977ec456339973b30e372fcbdabbe07f980d9fa36187463846b2811aed"></a>cpp_11&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3d70da9977ec456339973b30e372fcbdaee3f3f8ff98b05c178cea91bf69cde50"></a>cpp_14&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3d70da9977ec456339973b30e372fcbda6289bbfa378818f7066ccad5847da5a2"></a>cpp_17&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3d70da9977ec456339973b30e372fcbda4c7aabdc3eb0d845c62edfb822b0fe5a"></a>cpp_20&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a594a7b7fb202c9a1b6d82115e7a172e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a594a7b7fb202c9a1b6d82115e7a172e3">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::abs </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td> -&gt; Type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the absolute value. </p>

</div>
</div>
<a id="afe443a26a34b79fc921c4583df576333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe443a26a34b79fc921c4583df576333">&#9670;&nbsp;</a></span>accumulate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt , class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::accumulate </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sum of the given value init and the elements in the range [first, last). Uses operator+ to sum up the elements. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="numeric_8cpp-example.html#a3">numeric.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="a9413959b7ee39d393e7c35ad2cd78294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9413959b7ee39d393e7c35ad2cd78294">&#9670;&nbsp;</a></span>accumulate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt , class Type , class BinaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::accumulate </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOperation&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Type
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sum of the given value init and the elements in the range [first, last). Uses the BinaryOperation to sum up the elements. </p>

</div>
</div>
<a id="adbedfa50bab7817a29802cce148c7def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbedfa50bab7817a29802cce148c7def">&#9670;&nbsp;</a></span>addressof() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto etl::addressof </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; typename <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt;<a class="el" href="namespaceetl.html#a63efd09c0ee7195824be65423adadedc">etl::is_object_v</a>&lt;T&gt;, T*&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains the actual address of the object or function arg, even in presence of overloaded operator&amp;. </p>

</div>
</div>
<a id="a13856fe74510e89b04a2310cbc9bde59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13856fe74510e89b04a2310cbc9bde59">&#9670;&nbsp;</a></span>addressof() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto etl::addressof </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rvalue overload is deleted to prevent taking the address of const rvalues. </p>

</div>
</div>
<a id="ac45065b143a47fb9249bda8d57ccca63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45065b143a47fb9249bda8d57ccca63">&#9670;&nbsp;</a></span>advance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class It , class Distance &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::advance </td>
          <td>(</td>
          <td class="paramtype">It &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Distance&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increments given iterator it by n elements. If n is negative, the iterator is decremented. In this case, InputIt must meet the requirements of LegacyBidirectionalIterator, otherwise the behavior is undefined. </p>
<p>https://en.cppreference.com/w/cpp/iterator/advance </p>

</div>
</div>
<a id="ad9b7eed2eaa0b58da478a2d559164bb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9b7eed2eaa0b58da478a2d559164bb4">&#9670;&nbsp;</a></span>all_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::all_of </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if unary predicate p returns true for all elements in the range [first, last). </p>

</div>
</div>
<a id="a74cda9bdcb48dfe219176e8fbe4f3aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74cda9bdcb48dfe219176e8fbe4f3aa6">&#9670;&nbsp;</a></span>any_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::any_of </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if unary predicate p returns true for at least one element in the range [first, last). </p>

</div>
</div>
<a id="ae5a13233ebf471c62f35f40b21128884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5a13233ebf471c62f35f40b21128884">&#9670;&nbsp;</a></span>array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1array.html">etl::array</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U...&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structetl_1_1array.html">array</a>&lt; T, 1+sizeof...(U)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide. </p>

</div>
</div>
<a id="a6c3a2df3d684f12d436ea1d16e2de630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c3a2df3d684f12d436ea1d16e2de630">&#9670;&nbsp;</a></span>as_const() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::as_const </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a20607674e1e3cd49d5f0b815b33b2c1d">etl::add_const_t</a>&lt;T&gt;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forms lvalue reference to const type of t. </p>

</div>
</div>
<a id="a96cf5452578f57be8c16cc9b4688f8af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96cf5452578f57be8c16cc9b4688f8af">&#9670;&nbsp;</a></span>as_const() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::as_const </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  void=delete</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const rvalue reference overload is deleted to disallow rvalue arguments. </p>

</div>
</div>
<a id="a9788f03be1d72496a6c116e12ffd008a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9788f03be1d72496a6c116e12ffd008a">&#9670;&nbsp;</a></span>atol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto etl::atol </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> -&gt; long
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the C-string str interpreting its content as an integral number, which is returned as a value of type long int. </p>

</div>
</div>
<a id="ab4ea18354d7bfc7358bf9c13004f0233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4ea18354d7bfc7358bf9c13004f0233">&#9670;&nbsp;</a></span>back_inserter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::back_inserter </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classetl_1_1back__insert__iterator.html">back_insert_iterator</a>&lt;Container&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>back_inserter is a convenience function template that constructs a <a class="el" href="classetl_1_1back__insert__iterator.html" title="etl::back_insert_iterator is a LegacyOutputIterator that appends to a container for which it was cons...">etl::back_insert_iterator</a> for the container c with the type deduced from the type of the argument. </p>

</div>
</div>
<a id="a3031e070c39546444bdd5fda57ead3d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3031e070c39546444bdd5fda57ead3d2">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::begin </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt; decltype(c.begin())
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning of the given container c or array array. These templates rely on <a class="el" href="namespaceetl.html#ab0330eb79a39a00af31e79ece021f90f" title="Returns an iterator to the beginning of the given container c or array array. These templates rely on...">C::begin()</a> having a reasonable implementation. Returns exactly <a class="el" href="namespaceetl.html#ab0330eb79a39a00af31e79ece021f90f" title="Returns an iterator to the beginning of the given container c or array array. These templates rely on...">c.begin()</a>, which is typically an iterator to the beginning of the sequence represented by c. If C is a standard Container, this returns C::iterator when c is not const-qualified, and C::const_iterator otherwise. </p>
<p>Custom overloads of begin may be provided for classes that do not expose a suitable <a class="el" href="namespaceetl.html#a3031e070c39546444bdd5fda57ead3d2" title="Returns an iterator to the beginning of the given container c or array array. These templates rely on...">begin()</a> member function, yet can be iterated. </p>

</div>
</div>
<a id="a66664547d4c0705247e58b8580e1990e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66664547d4c0705247e58b8580e1990e">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::begin </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt; decltype(c.begin())
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning of the given container c or array array. These templates rely on <a class="el" href="namespaceetl.html#ab0330eb79a39a00af31e79ece021f90f" title="Returns an iterator to the beginning of the given container c or array array. These templates rely on...">C::begin()</a> having a reasonable implementation. Returns exactly <a class="el" href="namespaceetl.html#ab0330eb79a39a00af31e79ece021f90f" title="Returns an iterator to the beginning of the given container c or array array. These templates rely on...">c.begin()</a>, which is typically an iterator to the beginning of the sequence represented by c. If C is a standard Container, this returns C::iterator when c is not const-qualified, and C::const_iterator otherwise. </p>
<p>Custom overloads of begin may be provided for classes that do not expose a suitable <a class="el" href="namespaceetl.html#a3031e070c39546444bdd5fda57ead3d2" title="Returns an iterator to the beginning of the given container c or array array. These templates rely on...">begin()</a> member function, yet can be iterated. </p>

</div>
</div>
<a id="ab0330eb79a39a00af31e79ece021f90f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0330eb79a39a00af31e79ece021f90f">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , etl::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::begin </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td> -&gt; T*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning of the given container c or array array. These templates rely on <a class="el" href="namespaceetl.html#ab0330eb79a39a00af31e79ece021f90f" title="Returns an iterator to the beginning of the given container c or array array. These templates rely on...">C::begin()</a> having a reasonable implementation. Returns a pointer to the beginning of the array. </p>
<p>Custom overloads of begin may be provided for classes that do not expose a suitable <a class="el" href="namespaceetl.html#a3031e070c39546444bdd5fda57ead3d2" title="Returns an iterator to the beginning of the given container c or array array. These templates rely on...">begin()</a> member function, yet can be iterated. </p>

</div>
</div>
<a id="ae516046f5fb54110a91f5e7759f16240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae516046f5fb54110a91f5e7759f16240">&#9670;&nbsp;</a></span>bit_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class To , class From &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::bit_cast </td>
          <td>(</td>
          <td class="paramtype">const From &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; typename <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt;
    (sizeof(To) == sizeof(From))
        &amp;&amp; <a class="el" href="namespaceetl.html#a5b3b937c99443cbaf5f1817d061261bd">etl::is_trivially_copyable_v</a>&lt;From&gt; &amp;&amp; <a class="el" href="namespaceetl.html#a5b3b937c99443cbaf5f1817d061261bd">etl::is_trivially_copyable_v</a>&lt;To&gt;,
    To&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a value of type To by reinterpreting the object representation of from. Every bit in the value representation of the returned To object is equal to the corresponding bit in the object representation of from. </p>
<p>The values of padding bits in the returned To object are unspecified. If there is no value of type To corresponding to the value representation produced, the behavior is undefined. If there are multiple such values, which value is produced is unspecified. This overload only participates in overload resolution if sizeof(To) == sizeof(From) and both To and From are TriviallyCopyable types.</p>
<p>https://en.cppreference.com/w/cpp/numeric/bit_cast </p>

</div>
</div>
<a id="a9317469178624538d15a8e264d22887a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9317469178624538d15a8e264d22887a">&#9670;&nbsp;</a></span>bit_width()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::bit_width </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt;detail::is_unsigned_integer&lt;T&gt;::value, int&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If x is not zero, calculates the number of bits needed to store the value x, that is, 1+log2(x). If x is zero, returns zero. </p>
<p>This overload only participates in overload resolution if T is an unsigned integer type (that is, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long, or an extended unsigned integer type). </p>

</div>
</div>
<a id="ac530ab34c9d8ef872aeb563f30be8091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac530ab34c9d8ef872aeb563f30be8091">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::cbegin </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="namespaceetl.html#a3031e070c39546444bdd5fda57ead3d2">etl::begin</a>(c))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning of the given container c or array array. These templates rely on <a class="el" href="namespaceetl.html#ab0330eb79a39a00af31e79ece021f90f" title="Returns an iterator to the beginning of the given container c or array array. These templates rely on...">C::begin()</a> having a reasonable implementation. Returns exactly etl::begin(c), with c always treated as const-qualified. If C is a standard Container, this always returns C::const_iterator. </p>
<p>Custom overloads of begin may be provided for classes that do not expose a suitable <a class="el" href="namespaceetl.html#a3031e070c39546444bdd5fda57ead3d2" title="Returns an iterator to the beginning of the given container c or array array. These templates rely on...">begin()</a> member function, yet can be iterated. </p>

</div>
</div>
<a id="a9516c752e87a1cc87e7bc5763b61b7f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9516c752e87a1cc87e7bc5763b61b7f4">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::cend </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="namespaceetl.html#abf9eb859a31968a9179b29b638cd054b">etl::end</a>(c))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end (i.e. the element after the last element) of the given container c or array array. These templates rely on <a class="el" href="namespaceetl.html#a6f5d203d41447f951c386a27ef969327" title="Returns an iterator to the end (i.e. the element after the last element) of the given container c or ...">C::end()</a> having a reasonable implementation. </p>

</div>
</div>
<a id="af90379160c94dc0396b5f32204c790bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af90379160c94dc0396b5f32204c790bf">&#9670;&nbsp;</a></span>clamp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::clamp </td>
          <td>(</td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>hi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Type const&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If v compares less than lo, returns lo; otherwise if hi compares less than v, returns hi; otherwise returns v. Uses operator&lt; to compare the values. </p>

</div>
</div>
<a id="abfa416a307b0bb33666d34845c42ba2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfa416a307b0bb33666d34845c42ba2b">&#9670;&nbsp;</a></span>clamp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::clamp </td>
          <td>(</td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Type const&amp;
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adf43ebd431e0effc1fcd56e1cdb3a58c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf43ebd431e0effc1fcd56e1cdb3a58c">&#9670;&nbsp;</a></span>cmp_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::cmp_equal </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt;detail::is_integer_and_not_char&lt;T&gt;::value
                       &amp;&amp; detail::is_integer_and_not_char&lt;U&gt;::value,
                   bool&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion. </p>
<p>It is a compile-time error if either T or U is not a signed or unsigned integer type (including standard integer type and extended integer type). https://en.cppreference.com/w/cpp/utility/intcmp </p>

</div>
</div>
<a id="a726b4eedfb2a4ae9c478e0e98588a2e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a726b4eedfb2a4ae9c478e0e98588a2e8">&#9670;&nbsp;</a></span>cmp_greater()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::cmp_greater </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt;detail::is_integer_and_not_char&lt;T&gt;::value
                       &amp;&amp; detail::is_integer_and_not_char&lt;U&gt;::value,
                   bool&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion. </p>
<p>It is a compile-time error if either T or U is not a signed or unsigned integer type (including standard integer type and extended integer type). https://en.cppreference.com/w/cpp/utility/intcmp </p>

</div>
</div>
<a id="a0eb292194946c9d80e86df97adf5635b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb292194946c9d80e86df97adf5635b">&#9670;&nbsp;</a></span>cmp_greater_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::cmp_greater_equal </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt;detail::is_integer_and_not_char&lt;T&gt;::value
                       &amp;&amp; detail::is_integer_and_not_char&lt;U&gt;::value,
                   bool&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion. </p>
<p>It is a compile-time error if either T or U is not a signed or unsigned integer type (including standard integer type and extended integer type). https://en.cppreference.com/w/cpp/utility/intcmp </p>

</div>
</div>
<a id="a8c2faa4ff3aa7b68304c111c33000601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c2faa4ff3aa7b68304c111c33000601">&#9670;&nbsp;</a></span>cmp_less()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::cmp_less </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt;detail::is_integer_and_not_char&lt;T&gt;::value
                       &amp;&amp; detail::is_integer_and_not_char&lt;U&gt;::value,
                   bool&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion. </p>
<p>It is a compile-time error if either T or U is not a signed or unsigned integer type (including standard integer type and extended integer type). https://en.cppreference.com/w/cpp/utility/intcmp </p>

</div>
</div>
<a id="a331ef5587f806c7dc56a94dfaaf8e819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331ef5587f806c7dc56a94dfaaf8e819">&#9670;&nbsp;</a></span>cmp_less_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::cmp_less_equal </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt;detail::is_integer_and_not_char&lt;T&gt;::value
                       &amp;&amp; detail::is_integer_and_not_char&lt;U&gt;::value,
                   bool&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion. </p>
<p>It is a compile-time error if either T or U is not a signed or unsigned integer type (including standard integer type and extended integer type). https://en.cppreference.com/w/cpp/utility/intcmp </p>

</div>
</div>
<a id="a67fad2bcf2015251e85a6881458656c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67fad2bcf2015251e85a6881458656c5">&#9670;&nbsp;</a></span>cmp_not_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::cmp_not_equal </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt;detail::is_integer_and_not_char&lt;T&gt;::value
                       &amp;&amp; detail::is_integer_and_not_char&lt;U&gt;::value,
                   bool&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the values of two integers t and u. Unlike builtin comparison operators, negative signed integers always compare less than (and not equal to) unsigned integers: the comparison is safe against lossy integer conversion. </p>
<p>It is a compile-time error if either T or U is not a signed or unsigned integer type (including standard integer type and extended integer type). https://en.cppreference.com/w/cpp/utility/intcmp </p>

</div>
</div>
<a id="ad3271ee1abafc543f4bf69cc20b01ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3271ee1abafc543f4bf69cc20b01ded">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename OutputIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::copy </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIt
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the elements in the range, defined by [first, last), to another range beginning at destination. </p>
<p>Copies all elements in the range [first, last) starting from first and proceeding to last - 1. The behavior is undefined if destination is within the range [first, last). In this case, <a class="el" href="namespaceetl.html#a9cac48e35a645442922221597ece14b1" title="Copies the elements from the range, defined by [first, last), to another range ending at d_last...">etl::copy_backward</a> may be used instead.</p>
<dl class="section return"><dt>Returns</dt><dd>Output iterator to the element in the destination range, one past the last element copied. </dd></dl>

</div>
</div>
<a id="a9cac48e35a645442922221597ece14b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cac48e35a645442922221597ece14b1">&#9670;&nbsp;</a></span>copy_backward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BidirIt1 , typename BidirIt2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::copy_backward </td>
          <td>(</td>
          <td class="paramtype">BidirIt1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIt1&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIt2&#160;</td>
          <td class="paramname"><em>d_last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; BidirIt2
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the elements from the range, defined by [first, last), to another range ending at d_last. The elements are copied in reverse order (the last element is copied first), but their relative order is preserved. </p>
<p>The behavior is undefined if d_last is within (first, last]. <a class="el" href="namespaceetl.html#ad3271ee1abafc543f4bf69cc20b01ded" title="Copies the elements in the range, defined by [first, last), to another range beginning at destination...">etl::copy</a> must be used instead of <a class="el" href="namespaceetl.html#a9cac48e35a645442922221597ece14b1" title="Copies the elements from the range, defined by [first, last), to another range ending at d_last...">etl::copy_backward</a> in that case.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the last element copied. </dd></dl>

</div>
</div>
<a id="a2066fbbe3ee185ee159011308414d8ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2066fbbe3ee185ee159011308414d8ed">&#9670;&nbsp;</a></span>copy_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename OutputIt , typename UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::copy_if </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>d_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIt
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the elements in the range, defined by [first, last), to another range beginning at destination. </p>
<p>Only copies the elements for which the predicate pred returns true. The relative order of the elements that are copied is preserved. The behavior is undefined if the source and the destination ranges overlap.</p>
<dl class="section return"><dt>Returns</dt><dd>Output iterator to the element in the destination range, one past the last element copied. </dd></dl>

</div>
</div>
<a id="aa65063d9f87cd088156f3d49bb32f2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa65063d9f87cd088156f3d49bb32f2e5">&#9670;&nbsp;</a></span>copy_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename Size , typename OutputIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::copy_n </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Size&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIt
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies exactly count values from the range beginning at first to the range beginning at result. Formally, for each integer 0  i &lt; count, performs *(result + i) = *(first + i). Overlap of ranges is formally permitted, but leads to unpredictable ordering of the results. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator in the destination range, pointing past the last element copied if count&gt;0 or result otherwise. </dd></dl>

</div>
</div>
<a id="afe8c29a359a0bffc469225b6aeb0ae64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe8c29a359a0bffc469225b6aeb0ae64">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIter , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::count </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt;InputIter&gt;::difference_type
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of elements in the range [first, last) satisfying specific criteria. Counts the elements that are equal to value. </p>

</div>
</div>
<a id="af949f9bf15cdfd7e8282705ab00ddcc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af949f9bf15cdfd7e8282705ab00ddcc3">&#9670;&nbsp;</a></span>count_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIter , typename UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::count_if </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="structetl_1_1iterator__traits.html">iterator_traits</a>&lt;InputIter&gt;::difference_type
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of elements in the range [first, last) satisfying specific criteria. Counts elements for which predicate p returns true. </p>

</div>
</div>
<a id="a036c43ee12867c8bc74fe95022f175c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036c43ee12867c8bc74fe95022f175c3">&#9670;&nbsp;</a></span>countl_one()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::countl_one </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt;detail::is_unsigned_integer&lt;T&gt;::value, int&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of consecutive 1 ("one") bits in the value of x, starting from the most significant bit ("left"). </p>
<p>This overload only participates in overload resolution if T is an unsigned integer type (that is, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long, or an extended unsigned integer type).</p>
<dl class="section return"><dt>Returns</dt><dd>The number of consecutive 1 bits in the value of x, starting from the most significant bit. </dd></dl>

</div>
</div>
<a id="a89028d9dc63da94a3c786df4c0a09f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89028d9dc63da94a3c786df4c0a09f03">&#9670;&nbsp;</a></span>countl_zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::countl_zero </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt;detail::is_unsigned_integer&lt;T&gt;::value, int&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of consecutive 0 bits in the value of x, starting from the most significant bit ("left"). </p>
<p>This overload only participates in overload resolution if T is an unsigned integer type (that is, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long, or an extended unsigned integer type).</p>
<dl class="section return"><dt>Returns</dt><dd>The number of consecutive 0 bits in the value of x, starting from the most significant bit. </dd></dl>

</div>
</div>
<a id="a259846a061a975e4b40bc6f370701ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259846a061a975e4b40bc6f370701ac6">&#9670;&nbsp;</a></span>data() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::data </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt; decltype(c.data())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the block of memory containing the elements of the container. Returns <a class="el" href="namespaceetl.html#ad94411a453e2a44d4e6b6bf3160b4cf0" title="Returns a pointer to the block of memory containing the elements of the container. Returns &amp;array[0]. ">c.data()</a>. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="map_8cpp-example.html#a2">map.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="a1fe1659c6a0ad781385c8c81fbd5ce2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe1659c6a0ad781385c8c81fbd5ce2d">&#9670;&nbsp;</a></span>data() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::data </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt; decltype(c.data())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the block of memory containing the elements of the container. Returns <a class="el" href="namespaceetl.html#ad94411a453e2a44d4e6b6bf3160b4cf0" title="Returns a pointer to the block of memory containing the elements of the container. Returns &amp;array[0]. ">c.data()</a>. </p>

</div>
</div>
<a id="ad94411a453e2a44d4e6b6bf3160b4cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94411a453e2a44d4e6b6bf3160b4cf0">&#9670;&nbsp;</a></span>data() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , etl::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::data </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td> -&gt; T*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the block of memory containing the elements of the container. Returns &amp;array[0]. </p>

</div>
</div>
<a id="a4147daa38c6c4c1e59540fa0fa27a292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4147daa38c6c4c1e59540fa0fa27a292">&#9670;&nbsp;</a></span>declval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto etl::declval </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  typename <a class="el" href="structetl_1_1add__rvalue__reference.html">etl::add_rvalue_reference</a>&lt; T &gt;::type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts any type T to a reference type, making it possible to use member functions in decltype expressions without the need to go through constructors. </p>

</div>
</div>
<a id="ab44bc4884adc1e9dc20ddf2363f3da66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab44bc4884adc1e9dc20ddf2363f3da66">&#9670;&nbsp;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::destroy </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the objects in the range [first, last). </p>

</div>
</div>
<a id="a1709580f4bcc18d6efb2b7e4d5c1b728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1709580f4bcc18d6efb2b7e4d5c1b728">&#9670;&nbsp;</a></span>destroy_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::destroy_at </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> -&gt; void
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If T is not an array type, calls the destructor of the object pointed to by p, as if by p-&gt;~T(). If T is an array type, recursively destroys elements of *p in order, as if by calling <a class="el" href="namespaceetl.html#ab44bc4884adc1e9dc20ddf2363f3da66" title="Destroys the objects in the range [first, last). ">etl::destroy</a>(etl::begin(*p), etl::end(*p)). </p>

</div>
</div>
<a id="a440d38af8f9b00df3d5c1369450ba44a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a440d38af8f9b00df3d5c1369450ba44a">&#9670;&nbsp;</a></span>destroy_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIt , class Size &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::destroy_n </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Size&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIt
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the n objects in the range starting at first. </p>

</div>
</div>
<a id="aa5fe5f67d90d1f2c3c3d293099fe12e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5fe5f67d90d1f2c3c3d293099fe12e9">&#9670;&nbsp;</a></span>distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class It &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::distance </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename <a class="el" href="structetl_1_1iterator__traits.html">etl::iterator_traits</a>&lt;It&gt;::difference_type
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of hops from first to last. </p>
<p>https://en.cppreference.com/w/cpp/iterator/distance </p>

</div>
</div>
<a id="a8a7a0e8153fc36ebd0147b94c7359ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7a0e8153fc36ebd0147b94c7359ae8">&#9670;&nbsp;</a></span>empty() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::empty </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt; decltype(c.empty())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the given container is empty. </p>

</div>
</div>
<a id="a3868c40892e752ac869410ba4b0f0407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3868c40892e752ac869410ba4b0f0407">&#9670;&nbsp;</a></span>empty() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , etl::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::empty </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the given container is empty. </p>

</div>
</div>
<a id="abf9eb859a31968a9179b29b638cd054b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf9eb859a31968a9179b29b638cd054b">&#9670;&nbsp;</a></span>end() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::end </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt; decltype(c.end())
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the end (i.e. the element after the last element) of the given container c or array array. These templates rely on <a class="el" href="namespaceetl.html#a6f5d203d41447f951c386a27ef969327" title="Returns an iterator to the end (i.e. the element after the last element) of the given container c or ...">C::end()</a> having a reasonable implementation. </p>

</div>
</div>
<a id="afb97ec3cd4ce3928f2e25709ee21afa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb97ec3cd4ce3928f2e25709ee21afa0">&#9670;&nbsp;</a></span>end() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::end </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt; decltype(c.end())
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the end (i.e. the element after the last element) of the given container c or array array. These templates rely on <a class="el" href="namespaceetl.html#a6f5d203d41447f951c386a27ef969327" title="Returns an iterator to the end (i.e. the element after the last element) of the given container c or ...">C::end()</a> having a reasonable implementation. </p>

</div>
</div>
<a id="a6f5d203d41447f951c386a27ef969327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f5d203d41447f951c386a27ef969327">&#9670;&nbsp;</a></span>end() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , etl::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::end </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td> -&gt; T*
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the end (i.e. the element after the last element) of the given container c or array array. These templates rely on <a class="el" href="namespaceetl.html#a6f5d203d41447f951c386a27ef969327" title="Returns an iterator to the end (i.e. the element after the last element) of the given container c or ...">C::end()</a> having a reasonable implementation. </p>

</div>
</div>
<a id="a1ee66cde5734c21ca66a2e818a82f5dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ee66cde5734c21ca66a2e818a82f5dd">&#9670;&nbsp;</a></span>equal() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::equal </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the range [first1, last1) is equal to the range [first2, first2. </p>
<ul>
<li>(last1 - first1)), and false otherwise. </li>
</ul>

</div>
</div>
<a id="a934bfc901fe1ed60e93f7f9b9fb34079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a934bfc901fe1ed60e93f7f9b9fb34079">&#9670;&nbsp;</a></span>equal() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::equal </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the range [first1, last1) is equal to the range [first2, first2. </p>
<ul>
<li>(last1 - first1)), and false otherwise. </li>
</ul>

</div>
</div>
<a id="ab1ede11426eb69032bea8482caa55d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ede11426eb69032bea8482caa55d51">&#9670;&nbsp;</a></span>equal() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::equal </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the range [first1, last1) is equal to the range [first2, last2), and false otherwise. </p>

</div>
</div>
<a id="a19bb44dc832eef8b58d30b1cc70411ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19bb44dc832eef8b58d30b1cc70411ff">&#9670;&nbsp;</a></span>equal() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::equal </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>last2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the range [first1, last1) is equal to the range [first2, last2), and false otherwise. </p>

</div>
</div>
<a id="a287776d62f51d8f2b70314a1ca7022d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a287776d62f51d8f2b70314a1ca7022d5">&#9670;&nbsp;</a></span>exchange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U  = T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::exchange </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; T
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the value of obj with new_value and returns the old value of obj. </p>
<dl class="section return"><dt>Returns</dt><dd>The old value of obj. </dd></dl>

</div>
</div>
<a id="aa11bb84e871a5db6b2a230e5ef065234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa11bb84e871a5db6b2a230e5ef065234">&#9670;&nbsp;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::fill </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns the given value to the elements in the range [first, last). </p>

</div>
</div>
<a id="ac504b45acce22fba5a962a6ba642c942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac504b45acce22fba5a962a6ba642c942">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIter , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::find </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; InputIter
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for an element equal to value. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="algorithm_8cpp-example.html#a6">algorithm.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="a0ee167552576c5bc91dc94fd1fc8324d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee167552576c5bc91dc94fd1fc8324d">&#9670;&nbsp;</a></span>find_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIter , typename UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::find_if </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; InputIter
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for an element for which predicate p returns true. </p>

</div>
</div>
<a id="a2a9d16dde42342fd1e6b91ea378af979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a9d16dde42342fd1e6b91ea378af979">&#9670;&nbsp;</a></span>find_if_not()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIter , typename UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::find_if_not </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; InputIter
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for an element for which predicate q returns false. </p>

</div>
</div>
<a id="a013f931a99670b660a20f65b845013a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a013f931a99670b660a20f65b845013a3">&#9670;&nbsp;</a></span>for_each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename UnaryFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::for_each </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunction&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; UnaryFunction
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the given function object f to the result of dereferencing every iterator in the range [first, last] in order. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="algorithm_8cpp-example.html#a2">algorithm.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="a9c3c610f3a94e96a8a1c8cac49e70388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c3c610f3a94e96a8a1c8cac49e70388">&#9670;&nbsp;</a></span>for_each_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIter , typename Size , typename UnaryFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::for_each_n </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Size&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunction&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; InputIter
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the given function object <code>f</code> to the result of dereferencing every iterator in the range [ <code>first</code>, first+n] in order. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="algorithm_8cpp-example.html#a5">algorithm.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="a40b9621f8af141d0572885428d2880d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b9621f8af141d0572885428d2880d9">&#9670;&nbsp;</a></span>forward() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::forward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a26ceb8de4fe37ef6a14f78dd10d95bb6">etl::remove_reference_t</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td> -&gt; T&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forwards lvalues as either lvalues or as rvalues, depending on T. </p>
<p>When t is a forwarding reference (a function argument that is declared as an rvalue reference to a cv-unqualified function template parameter), this overload forwards the argument to another function with the value category it had when passed to the calling function.</p>
<p>https://en.cppreference.com/w/cpp/utility/forward </p>

</div>
</div>
<a id="aecb1fda04868d6ffa0343a463beba0e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb1fda04868d6ffa0343a463beba0e7">&#9670;&nbsp;</a></span>forward() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::forward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a26ceb8de4fe37ef6a14f78dd10d95bb6">etl::remove_reference_t</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td> -&gt; T&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forwards rvalues as rvalues and prohibits forwarding of rvalues as lvalues. </p>
<p>This overload makes it possible to forward a result of an expression (such as function call), which may be rvalue or lvalue, as the original value category of a forwarding reference argument.</p>
<p>https://en.cppreference.com/w/cpp/utility/forward </p>

</div>
</div>
<a id="a1e969dbba1b9a1c3889a417e695fb296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e969dbba1b9a1c3889a417e695fb296">&#9670;&nbsp;</a></span>front_inserter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::front_inserter </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classetl_1_1front__insert__iterator.html">etl::front_insert_iterator</a>&lt;Container&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>front_inserter is a convenience function template that constructs a <a class="el" href="classetl_1_1front__insert__iterator.html" title="etl::front_insert_iterator is an LegacyOutputIterator that prepends elements to a container for which...">etl::front_insert_iterator</a> for the container c with the type deduced from the type of the argument. </p>

</div>
</div>
<a id="ab65cd6f8748c172eab6ee36130dca3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab65cd6f8748c172eab6ee36130dca3c3">&#9670;&nbsp;</a></span>gcd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename N &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::gcd </td>
          <td>(</td>
          <td class="paramtype">M&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#ac80571ce0a1bbafdb4d8e153ceade9e3">etl::common_type_t</a>&lt;M, N&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the greatest common divisor of the integers m and n. </p>
<dl class="section return"><dt>Returns</dt><dd>If both m and n are zero, returns zero. Otherwise, returns the greatest common divisor of |m| and |n|. </dd></dl>

</div>
</div>
<a id="a0b963791bdb1da038a64b23555f245c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b963791bdb1da038a64b23555f245c4">&#9670;&nbsp;</a></span>generate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename Generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::generate </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Generator&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns each element in range [first, last) a value generated by the given function object g. </p>
<p>https://en.cppreference.com/w/cpp/algorithm/generate </p>

</div>
</div>
<a id="ab984bfa2eb0fd6da7369b629ca3acdc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab984bfa2eb0fd6da7369b629ca3acdc7">&#9670;&nbsp;</a></span>generate_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputIt , typename SizeT , typename Generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::generate_n </td>
          <td>(</td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeT&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Generator&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIt
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns values, generated by given function object g, to the first count elements in the range beginning at first, if count&gt;0. Does nothing otherwise. </p>
<p>https://en.cppreference.com/w/cpp/algorithm/generate_n </p>

</div>
</div>
<a id="a9df6d2b5d1046470baf1626470258ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df6d2b5d1046470baf1626470258ed2">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int index, typename First , typename... Rest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structetl_1_1tuple.html">tuple</a>&lt; First, Rest... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; decltype(detail::get_impl&lt;index, First, Rest...&gt;::value(&amp;t))
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8169996f70a6db66068896e1f2d6d774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8169996f70a6db66068896e1f2d6d774">&#9670;&nbsp;</a></span>get_if() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t I, class... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::get_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1variant.html">etl::variant</a>&lt; Types... &gt; *&#160;</td>
          <td class="paramname"><em>pv</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#afd20d67cb221212f49a97e02a7c1ca25">etl::add_pointer_t</a>&lt;<a class="el" href="namespaceetl.html#aef7110ca07ee5b481d99d9ae57a977ed">etl::variant_alternative_t</a>&lt;I, <a class="el" href="classetl_1_1variant.html">etl::variant</a>&lt;Types...&gt;&gt;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index-based non-throwing accessor: If pv is not a null pointer and pv-&gt;index() == I, returns a pointer to the value stored in the variant pointed to by pv. Otherwise, returns a null pointer value. The call is ill-formed if I is not a valid index in the variant. </p>
<p>Type-based non-throwing accessor: The call is ill-formed if T is not a unique element of Types....</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000028">Todo:</a></b></dt><dd>Implement </dd></dl>

</div>
</div>
<a id="a6793464788b24ea02472dc48eb208218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6793464788b24ea02472dc48eb208218">&#9670;&nbsp;</a></span>get_if() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;etl::size_t I, class... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::get_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1variant.html">etl::variant</a>&lt; Types... &gt; const *&#160;</td>
          <td class="paramname"><em>pv</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#afd20d67cb221212f49a97e02a7c1ca25">etl::add_pointer_t</a>&lt;<a class="el" href="namespaceetl.html#aef7110ca07ee5b481d99d9ae57a977ed">etl::variant_alternative_t</a>&lt;I, <a class="el" href="classetl_1_1variant.html">etl::variant</a>&lt;Types...&gt;&gt; const&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index-based non-throwing accessor: If pv is not a null pointer and pv-&gt;index() == I, returns a pointer to the value stored in the variant pointed to by pv. Otherwise, returns a null pointer value. The call is ill-formed if I is not a valid index in the variant. </p>
<p>Type-based non-throwing accessor: The call is ill-formed if T is not a unique element of Types....</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000029">Todo:</a></b></dt><dd>Implement </dd></dl>

</div>
</div>
<a id="af4fea3bb59d69e9a23786b36024d802a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4fea3bb59d69e9a23786b36024d802a">&#9670;&nbsp;</a></span>has_single_bit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::has_single_bit </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt;detail::is_unsigned_integer&lt;T&gt;::value, bool&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if x is an integral power of two. </p>
<p>This overload only participates in overload resolution if T is an unsigned integer type (that is, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long, or an extended unsigned integer type).</p>
<dl class="section return"><dt>Returns</dt><dd>true if x is an integral power of two; otherwise false. </dd></dl>

</div>
</div>
<a id="a61440f28934330fcfa979f4a1fba3c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61440f28934330fcfa979f4a1fba3c54">&#9670;&nbsp;</a></span>holds_alternative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::holds_alternative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1variant.html">etl::variant</a>&lt; Types... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the variant v holds the alternative T. The call is ill-formed if T does not appear exactly once in Types... </p>

</div>
</div>
<a id="ada1849ec064e37fdc587449c92492d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada1849ec064e37fdc587449c92492d25">&#9670;&nbsp;</a></span>ignore_unused()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto etl::ignore_unused </td>
          <td>(</td>
          <td class="paramtype">Types &amp;&amp;&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td> -&gt; void
</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="map_8cpp-example.html#a3">map.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="aa374f8a8aadeee045b4a6d154baa5d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa374f8a8aadeee045b4a6d154baa5d7c">&#9670;&nbsp;</a></span>in_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::in_range </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt;detail::is_integer_and_not_char&lt;T&gt;::value, bool&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the value of t is in the range of values that can be represented in R, that is, if t can be converted to R without data loss. </p>
<p>It is a compile-time error if either T or R is not a signed or unsigned integer type (including standard integer type and extended integer type). This function cannot be used with <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>, char, char8_t, char16_t, char32_t, wchar_t and bool.</p>
<p>https://en.cppreference.com/w/cpp/utility/in_range </p>

</div>
</div>
<a id="acc7d9a038b385aff889235d470b837e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc7d9a038b385aff889235d470b837e4">&#9670;&nbsp;</a></span>includes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::includes </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>last2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the sorted range [first2, last2) is a subsequence of the sorted range [first1, last1). Both ranges must be sorted with operator&lt;. </p>

</div>
</div>
<a id="a2f97df033ed5dc7c5458f991078633d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f97df033ed5dc7c5458f991078633d9">&#9670;&nbsp;</a></span>includes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::includes </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the sorted range [first2, last2) is a subsequence of the sorted range [first1, last1). Both ranges must be sorted with the given comparison function comp. </p>

</div>
</div>
<a id="a42b02b91109bd6987f6dd8c0cfe583d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42b02b91109bd6987f6dd8c0cfe583d5">&#9670;&nbsp;</a></span>inner_product() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt1 , class InputIt2 , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::inner_product </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; T
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes inner product (i.e. sum of products) or performs ordered map/reduce operation on the range [first1, last1) and the range beginning at first2. </p>
<p>Initializes the accumulator acc with the initial value init and then modifies it with the expression acc = etl::move(acc) + *first1 * *first2, then modifies again with the expression acc = etl::move(acc) + *(first1+1) * *(first2+1), etc until reaching last1. For built-in meaning of + and *, this computes inner product of the two ranges. </p>

</div>
</div>
<a id="ae0039bdc9a6970a2089121ae3ee285b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0039bdc9a6970a2089121ae3ee285b1">&#9670;&nbsp;</a></span>inner_product() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt1 , class InputIt2 , class T , class BinaryOperation1 , class BinaryOperation2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::inner_product </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOperation1&#160;</td>
          <td class="paramname"><em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOperation2&#160;</td>
          <td class="paramname"><em>op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; T
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes inner product (i.e. sum of products) or performs ordered map/reduce operation on the range [first1, last1) and the range beginning at first2. </p>
<p>Initializes the accumulator acc with the initial value init and then modifies it with the expression acc = op1(etl::move(acc), op2(*first1, *first2)), then modifies again with the expression acc = op1(etl::move(acc), op2(*(first1+1), *(first2+1))), etc until reaching last1.</p>
<p>op1 or op2 must not invalidate any iterators, including the end iterators, or modify any elements of the range involved. </p>

</div>
</div>
<a id="a44562b8c2da2eb5f51eb8e98d09ea697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44562b8c2da2eb5f51eb8e98d09ea697">&#9670;&nbsp;</a></span>iota()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIt , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::iota </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the range [first, last) with sequentially increasing values, starting with value and repetitively evaluating ++value. </p>

</div>
</div>
<a id="a4ec5c14f53ef79e0b6debfffb6ce947f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec5c14f53ef79e0b6debfffb6ce947f">&#9670;&nbsp;</a></span>is_constant_evaluated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::is_constant_evaluated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detects whether the function call occurs within a constant-evaluated context. Returns true if the evaluation of the call occurs within the evaluation of an expression or conversion that is manifestly constant-evaluated; otherwise returns false. </p>
<p><a href="https://en.cppreference.com/w/cpp/types/is_constant_evaluated">https://en.cppreference.com/w/cpp/types/is_constant_evaluated</a> </p>

</div>
</div>
<a id="abe8a84a5c6ba35f67fbc2ca6092eedde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe8a84a5c6ba35f67fbc2ca6092eedde">&#9670;&nbsp;</a></span>is_greater_language_standard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::is_greater_language_standard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3d70da9977ec456339973b30e372fcbd">language_standard</a>&#160;</td>
          <td class="paramname"><em>ls</em></td><td>)</td>
          <td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad763c7f65a817a0ba3f58cf0d5672d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad763c7f65a817a0ba3f58cf0d5672d1b">&#9670;&nbsp;</a></span>is_language_standard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::is_language_standard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3d70da9977ec456339973b30e372fcbd">language_standard</a>&#160;</td>
          <td class="paramname"><em>ls</em></td><td>)</td>
          <td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true, if the given standard and the currently configurated in the compiler match. </p>

</div>
</div>
<a id="aaab088a74d056814b99f64cba7c31cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaab088a74d056814b99f64cba7c31cef">&#9670;&nbsp;</a></span>is_sorted() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::is_sorted </td>
          <td>(</td>
          <td class="paramtype">ForwardIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIter&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the elements in range [first, last) are sorted in non-descending order. Elements are compared using operator&lt;. </p>

</div>
</div>
<a id="a5a93174fd55dba4449e55dd3accbd299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a93174fd55dba4449e55dd3accbd299">&#9670;&nbsp;</a></span>is_sorted() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIter , typename Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::is_sorted </td>
          <td>(</td>
          <td class="paramtype">ForwardIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the elements in range [first, last) are sorted in non-descending order. Elements are compared using the given binary comparison function comp. </p>

</div>
</div>
<a id="a3d06375f6c6ee1b6ffe30e433b5ca742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d06375f6c6ee1b6ffe30e433b5ca742">&#9670;&nbsp;</a></span>is_sorted_until() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::is_sorted_until </td>
          <td>(</td>
          <td class="paramtype">ForwardIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIter&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIter
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Examines the range [first, last) and finds the largest range beginning at first in which the elements are sorted in non-descending order. Elements are compared using operator&lt;. </p>

</div>
</div>
<a id="af8cd072db84b3726ff5ff9734f09c81e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8cd072db84b3726ff5ff9734f09c81e">&#9670;&nbsp;</a></span>is_sorted_until() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIter , typename Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::is_sorted_until </td>
          <td>(</td>
          <td class="paramtype">ForwardIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIter
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Examines the range [first, last) and finds the largest range beginning at first in which the elements are sorted in non-descending order. Elements are compared using the given binary comparison function comp. </p>

</div>
</div>
<a id="a80bf904f99630edb18fcb3a07117779f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80bf904f99630edb18fcb3a07117779f">&#9670;&nbsp;</a></span>isfinite() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::isfinite </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the given floating point number arg has finite value i.e. it is normal, subnormal or zero, but not infinite or NaN. </p>
<p>https://en.cppreference.com/w/cpp/numeric/math/isfinite </p>

</div>
</div>
<a id="a813ce51b2632847f81eed1858528ff8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a813ce51b2632847f81eed1858528ff8e">&#9670;&nbsp;</a></span>isfinite() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::isfinite </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the given floating point number arg has finite value i.e. it is normal, subnormal or zero, but not infinite or NaN. </p>
<p>https://en.cppreference.com/w/cpp/numeric/math/isfinite </p>

</div>
</div>
<a id="ae33b9666e620117df47e7cd5c2faae53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae33b9666e620117df47e7cd5c2faae53">&#9670;&nbsp;</a></span>isfinite() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::isfinite </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the given floating point number arg has finite value i.e. it is normal, subnormal or zero, but not infinite or NaN. </p>
<p>https://en.cppreference.com/w/cpp/numeric/math/isfinite </p>

</div>
</div>
<a id="a47ef6491e0baea008f09e77e8bdd1893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ef6491e0baea008f09e77e8bdd1893">&#9670;&nbsp;</a></span>isinf() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::isinf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; bool </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the given floating point number arg is a positive or negative infinity. </p>
<dl class="section return"><dt>Returns</dt><dd>true if arg is infinite, false otherwise</dd></dl>
<p>https://en.cppreference.com/w/cpp/numeric/math/isinf </p>

</div>
</div>
<a id="a0bd9c92fc417d48f3b71a556c288f34d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd9c92fc417d48f3b71a556c288f34d">&#9670;&nbsp;</a></span>isinf() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::isinf </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; bool </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the given floating point number arg is a positive or negative infinity. </p>
<dl class="section return"><dt>Returns</dt><dd>true if arg is infinite, false otherwise</dd></dl>
<p>https://en.cppreference.com/w/cpp/numeric/math/isinf </p>

</div>
</div>
<a id="aac63899ba5cdbbcbe25e867baaa11c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac63899ba5cdbbcbe25e867baaa11c8a">&#9670;&nbsp;</a></span>isinf() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::isinf </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; bool </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the given floating point number arg is a positive or negative infinity. </p>
<dl class="section return"><dt>Returns</dt><dd>true if arg is infinite, false otherwise</dd></dl>
<p>https://en.cppreference.com/w/cpp/numeric/math/isinf </p>

</div>
</div>
<a id="a479b0c43cc953cd7843f865e75bdc53b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479b0c43cc953cd7843f865e75bdc53b">&#9670;&nbsp;</a></span>isinf() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntegralType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::isinf </td>
          <td>(</td>
          <td class="paramtype">IntegralType&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt;<a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt;IntegralType&gt;, bool&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A set of overloads or a function template accepting the arg argument of any integral type. Equivalent to cast to double. </p>
<dl class="section return"><dt>Returns</dt><dd>true if arg is infinite, false otherwise</dd></dl>
<p>https://en.cppreference.com/w/cpp/numeric/math/isinf </p>

</div>
</div>
<a id="a605d9e24e916cbbc8f38c7e377eb792d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a605d9e24e916cbbc8f38c7e377eb792d">&#9670;&nbsp;</a></span>isnan() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::isnan </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; bool </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the given floating point number arg is a not-a-number (NaN) value. </p>
<p>https://en.cppreference.com/w/cpp/numeric/math/isnan </p>

</div>
</div>
<a id="ac4da86e5987c4a4fc2368f5195645c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4da86e5987c4a4fc2368f5195645c3f">&#9670;&nbsp;</a></span>isnan() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::isnan </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; bool </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the given floating point number arg is a not-a-number (NaN) value. </p>
<p>https://en.cppreference.com/w/cpp/numeric/math/isnan </p>

</div>
</div>
<a id="a5b1b06749558d3368fe928aba61d3b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b1b06749558d3368fe928aba61d3b46">&#9670;&nbsp;</a></span>isnan() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::isnan </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; bool </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the given floating point number arg is a not-a-number (NaN) value. </p>
<p>https://en.cppreference.com/w/cpp/numeric/math/isnan </p>

</div>
</div>
<a id="aa8337c5b28ae7940b265ee8afe4c328e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8337c5b28ae7940b265ee8afe4c328e">&#9670;&nbsp;</a></span>isnan() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntegralType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::isnan </td>
          <td>(</td>
          <td class="paramtype">IntegralType&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt;<a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt;IntegralType&gt;, bool&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the given floating point number arg is a not-a-number (NaN) value. </p>
<p>https://en.cppreference.com/w/cpp/numeric/math/isnan </p>

</div>
</div>
<a id="aa18b878794474881fce640e7a163abf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa18b878794474881fce640e7a163abf3">&#9670;&nbsp;</a></span>iter_swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt1 , typename ForwardIt2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::iter_swap </td>
          <td>(</td>
          <td class="paramtype">ForwardIt1&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the values of the elements the given iterators are pointing to. </p>
<p>https://en.cppreference.com/w/cpp/algorithm/iter_swap </p>

</div>
</div>
<a id="a07b9405fac6c1a10a80eedfbe2a120b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b9405fac6c1a10a80eedfbe2a120b6">&#9670;&nbsp;</a></span>itoa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto etl::itoa </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *const&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; char*
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an integer value to a null-terminated string using the specified base and stores the result in the array given by str parameter. </p>
<p>If base is 10 and value is negative, the resulting string is preceded with a minus sign (-). With any other base, value is always considered unsigned.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>Only base 10 is currently supported. </dd></dl>

</div>
</div>
<a id="a88d17ac0d457a45babf1c999ed6bea7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d17ac0d457a45babf1c999ed6bea7f">&#9670;&nbsp;</a></span>lcm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class N &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::lcm </td>
          <td>(</td>
          <td class="paramtype">M&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt;
    <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt;
        M&gt; &amp;&amp; !<a class="el" href="namespaceetl.html#a3f74da2365a9a6f68d472686fd0f1666">etl::is_same_v</a>&lt;M, bool&gt; &amp;&amp; <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt;N&gt; &amp;&amp; !<a class="el" href="namespaceetl.html#a3f74da2365a9a6f68d472686fd0f1666">etl::is_same_v</a>&lt;N, bool&gt;,
    <a class="el" href="namespaceetl.html#ac80571ce0a1bbafdb4d8e153ceade9e3">etl::common_type_t</a>&lt;M, N&gt;&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the least common multiple of the integers m and n. </p>
<dl class="section return"><dt>Returns</dt><dd>If either m or n is zero, returns zero. Otherwise, returns the least common multiple of |m| and |n|. </dd></dl>

</div>
</div>
<a id="afe5ebb5d35320f153506765261d81a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe5ebb5d35320f153506765261d81a03">&#9670;&nbsp;</a></span>lexicographical_compare() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 , typename Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::lexicographical_compare </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the first range [first1, last1) is lexicographically less than the second range [first2, last2). Elements are compared using the given binary comparison function comp. </p>
<p>https://en.cppreference.com/w/cpp/algorithm/lexicographical_compare </p>

</div>
</div>
<a id="ae627d43cafd94be503c4082795951f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae627d43cafd94be503c4082795951f33">&#9670;&nbsp;</a></span>lexicographical_compare() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt1 , typename InputIt2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::lexicographical_compare </td>
          <td>(</td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt2&#160;</td>
          <td class="paramname"><em>last2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the first range [first1, last1) is lexicographically less than the second range [first2, last2). Elements are compared using operator&lt;. </p>
<p>https://en.cppreference.com/w/cpp/algorithm/lexicographical_compare </p>

</div>
</div>
<a id="a43c80d5c10c1a11341e864197c701176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c80d5c10c1a11341e864197c701176">&#9670;&nbsp;</a></span>make_optional() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::make_optional </td>
          <td>(</td>
          <td class="paramtype">ValueType &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classetl_1_1optional.html">etl::optional</a>&lt;<a class="el" href="namespaceetl.html#ad602447fa93ad71f4db547fa0ae92883">etl::decay_t</a>&lt;ValueType&gt;&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. </p>
<p>Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. Compares opt with a value. The values are compared (using the corresponding operator of T) only if opt contains a value. Otherwise, opt is considered less than value. If the corresponding two-way comparison expression between *opt and value is not well-formed, or if its result is not convertible to bool, the program is ill-formed. Creates an optional object from value. </p>

</div>
</div>
<a id="a3100dac4a3eddc7d88a828b05513ccc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3100dac4a3eddc7d88a828b05513ccc0">&#9670;&nbsp;</a></span>make_optional() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::make_optional </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classetl_1_1optional.html">etl::optional</a>&lt;ValueType&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an optional object constructed in-place from args... </p>

</div>
</div>
<a id="a638ad4db4d90fecc8d08227b1c214148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a638ad4db4d90fecc8d08227b1c214148">&#9670;&nbsp;</a></span>make_pair()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::make_pair </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt;typename <a class="el" href="structetl_1_1decay.html">etl::decay</a>&lt;T1&gt;::type, typename <a class="el" href="structetl_1_1decay.html">etl::decay</a>&lt;T2&gt;::type&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="structetl_1_1pair.html" title="etl::pair is a class template that provides a way to store two heterogeneous objects as a single unit...">etl::pair</a> object, deducing the target type from the types of arguments. </p>
<p>The deduced types V1 and V2 are <a class="el" href="structetl_1_1decay.html#aafdc23eff04d441f74c9e72ca18e5a09">etl::decay&lt;T1&gt;::type</a> and <a class="el" href="structetl_1_1decay.html#aafdc23eff04d441f74c9e72ca18e5a09">etl::decay&lt;T2&gt;::type</a> (the usual type transformations applied to arguments of functions passed by value).</p>
<p>https://en.cppreference.com/w/cpp/utility/pair/make_pair </p>

</div>
</div>
<a id="a7fdd0cf88f36f44f8fe8ec8327cfac74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fdd0cf88f36f44f8fe8ec8327cfac74">&#9670;&nbsp;</a></span>max() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::max </td>
          <td>(</td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Type const&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the greater of a and b. </p>

</div>
</div>
<a id="a220fbd23aca7dbc728c200471ed114c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220fbd23aca7dbc728c200471ed114c8">&#9670;&nbsp;</a></span>max() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::max </td>
          <td>(</td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Type const&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the greater of a and b, using a compare function. </p>

</div>
</div>
<a id="aa58c8973da727c50c3d0d28b83fdf304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa58c8973da727c50c3d0d28b83fdf304">&#9670;&nbsp;</a></span>max_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::max_element </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIterator
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the greatest element in the range [first, last). Elements are compared using operator&lt;. </p>

</div>
</div>
<a id="ab573cae5dd21a6ab0e00ee00da8855e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab573cae5dd21a6ab0e00ee00da8855e0">&#9670;&nbsp;</a></span>max_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::max_element </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIterator
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the greatest element in the range [first, last). Elements are compared using the given binary comparison function comp. </p>

</div>
</div>
<a id="a99a28bb04c335112b2c13d676c422e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99a28bb04c335112b2c13d676c422e66">&#9670;&nbsp;</a></span>memcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::memcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">etl::size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void*
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the first n bytes pointed to by src to the buffer pointed to by dest. Source and destination may not overlap. If source and destination might overlap, <a class="el" href="namespaceetl.html#a4604077670e2126de4d05e9d4dab2df9" title="Copy the first n bytes pointed to by src to the buffer pointed to by dest. Source and destination may...">memmove()</a> must be used instead. </p>

</div>
</div>
<a id="a4604077670e2126de4d05e9d4dab2df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4604077670e2126de4d05e9d4dab2df9">&#9670;&nbsp;</a></span>memmove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::memmove </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">etl::size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void*
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the first n bytes pointed to by src to the buffer pointed to by dest. Source and destination may overlap. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>Check original implementation. They use __np_anyptrlt which is not portable. <a href="https://clc-wiki.net/wiki/C_standard_library:string.h:memmove">https://clc-wiki.net/wiki/C_standard_library:string.h:memmove</a> </dd></dl>

</div>
</div>
<a id="a055dc327ea35a394f661ca98bf2b08ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a055dc327ea35a394f661ca98bf2b08ad">&#9670;&nbsp;</a></span>memset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::memset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">etl::size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void*
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the value of c (converted to an unsigned char) into each of the rst n characters of the object pointed to by s. </p>

</div>
</div>
<a id="add674d1e1c1fd1d72dd7b39f74a0525a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add674d1e1c1fd1d72dd7b39f74a0525a">&#9670;&nbsp;</a></span>midpoint() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::midpoint </td>
          <td>(</td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt;<a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt;Integer&gt; &amp;&amp; !<a class="el" href="namespaceetl.html#a3f74da2365a9a6f68d472686fd0f1666">etl::is_same_v</a>&lt;Integer, bool&gt;,
                        Integer&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns half the sum of a + b. If the sum is odd, the result is rounded towards a. </p>
<p>T is arithmentic type other than bool </p>

</div>
</div>
<a id="acd6eb417ecc3a7b1c7e71baab1c2c522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd6eb417ecc3a7b1c7e71baab1c2c522">&#9670;&nbsp;</a></span>midpoint() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Float &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::midpoint </td>
          <td>(</td>
          <td class="paramtype">Float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt;<a class="el" href="namespaceetl.html#a5cf273d19443134cffcd66310d027ae4">etl::is_floating_point_v</a>&lt;Float&gt;, Float&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad2f4c423421fddd2a2f941d805c05300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f4c423421fddd2a2f941d805c05300">&#9670;&nbsp;</a></span>midpoint() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Pointer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::midpoint </td>
          <td>(</td>
          <td class="paramtype">Pointer&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pointer&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">enable_if_t</a>&lt;<a class="el" href="namespaceetl.html#ac00eca7d51c4d2c1021402ee9a70f03c">is_pointer_v</a>&lt;Pointer&gt;, Pointer&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adae1500815312b248e453896d5439b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adae1500815312b248e453896d5439b63">&#9670;&nbsp;</a></span>min() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::min </td>
          <td>(</td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Type const&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smaller of a and b. </p>

</div>
</div>
<a id="a479c4a8315ae3ef2d1128858d723afc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479c4a8315ae3ef2d1128858d723afc2">&#9670;&nbsp;</a></span>min() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::min </td>
          <td>(</td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Type const&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smaller of a and b, using a compare function. </p>

</div>
</div>
<a id="a41f1e60aa2d0ca23d39bd975ed52e4b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f1e60aa2d0ca23d39bd975ed52e4b4">&#9670;&nbsp;</a></span>min_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::min_element </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIterator
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the smallest element in the range [first, last). Elements are compared using operator&lt;. </p>

</div>
</div>
<a id="ae206eeb82f5e460124ce4b40e951fa0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae206eeb82f5e460124ce4b40e951fa0d">&#9670;&nbsp;</a></span>min_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::min_element </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIterator
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the smallest element in the range [first, last). Elements are compared using the given binary comparison function comp. </p>

</div>
</div>
<a id="ab340ce2b640eb395b08fe8b266881603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab340ce2b640eb395b08fe8b266881603">&#9670;&nbsp;</a></span>mismatch() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIter1 , class InputIter2 , class BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::mismatch </td>
          <td>(</td>
          <td class="paramtype">InputIter1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt;InputIter1, InputIter2&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first mismatching pair of elements from two ranges: one defined by [first1, last1) and another defined by [first2,last2). If last2 is not provided (overloads (1-4)), it denotes first2 + (last1 - first1). </p>
<p>Elements are compared using the given binary predicate p. </p>

</div>
</div>
<a id="a5670e9bd29e9fb8b573558fe9a6bff17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5670e9bd29e9fb8b573558fe9a6bff17">&#9670;&nbsp;</a></span>mismatch() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIter1 , class InputIter2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::mismatch </td>
          <td>(</td>
          <td class="paramtype">InputIter1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter2&#160;</td>
          <td class="paramname"><em>first2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt;InputIter1, InputIter2&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first mismatching pair of elements from two ranges: one defined by [first1, last1) and another defined by [first2,last2). If last2 is not provided (overloads (1-4)), it denotes first2 + (last1 - first1). </p>
<p>Elements are compared using operator==. </p>

</div>
</div>
<a id="ace4d823211420bf94fe43c94bf902a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace4d823211420bf94fe43c94bf902a57">&#9670;&nbsp;</a></span>mismatch() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIter1 , class InputIter2 , class BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::mismatch </td>
          <td>(</td>
          <td class="paramtype">InputIter1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt;InputIter1, InputIter2&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first mismatching pair of elements from two ranges: one defined by [first1, last1) and another defined by [first2,last2). If last2 is not provided (overloads (1-4)), it denotes first2 + (last1 - first1). </p>
<p>Elements are compared using the given binary predicate p. </p>

</div>
</div>
<a id="a934b1b48023aa9532f3f329fe18f1079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a934b1b48023aa9532f3f329fe18f1079">&#9670;&nbsp;</a></span>mismatch() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIter1 , class InputIter2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::mismatch </td>
          <td>(</td>
          <td class="paramtype">InputIter1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter2&#160;</td>
          <td class="paramname"><em>last2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt;InputIter1, InputIter2&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first mismatching pair of elements from two ranges: one defined by [first1, last1) and another defined by [first2,last2). If last2 is not provided (overloads (1-4)), it denotes first2 + (last1 - first1). </p>
<p>Elements are compared using operator==. </p>

</div>
</div>
<a id="a4165fb01e5de4a84bfd7367b5133cb3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4165fb01e5de4a84bfd7367b5133cb3d">&#9670;&nbsp;</a></span>move() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::move </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; typename <a class="el" href="structetl_1_1remove__reference.html">etl::remove_reference</a>&lt;T&gt;::type&amp;&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespaceetl.html#ad0a5b274f170d18a9e175fddf538a4bc" title="Moves the elements in the range [first, last), to another range beginning at d_first, starting from first and proceeding to last - 1. After this operation the elements in the moved-from range will still contain valid values of the appropriate type, but not necessarily the same values as before the move. ">etl::move</a> is used to indicate that an object t may be "moved from", i.e. allowing the efficient transfer of resources from t to another object. In particular, <a class="el" href="namespaceetl.html#ad0a5b274f170d18a9e175fddf538a4bc" title="Moves the elements in the range [first, last), to another range beginning at d_first, starting from first and proceeding to last - 1. After this operation the elements in the moved-from range will still contain valid values of the appropriate type, but not necessarily the same values as before the move. ">etl::move</a> produces an xvalue expression that identifies its argument t. It is exactly equivalent to a static_cast to an rvalue reference type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>static_cast&lt;typename <a class="el" href="structetl_1_1remove__reference.html#a2485f631f25b8f91e902b3d127fd5d2a">etl::remove_reference&lt;T&gt;::type</a>&amp;&amp;&gt;(t) </dd></dl>

</div>
</div>
<a id="ad0a5b274f170d18a9e175fddf538a4bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a5b274f170d18a9e175fddf538a4bc">&#9670;&nbsp;</a></span>move() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIter , typename OutputIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::move </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIter&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIter
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the elements in the range [first, last), to another range beginning at d_first, starting from first and proceeding to last - 1. After this operation the elements in the moved-from range will still contain valid values of the appropriate type, but not necessarily the same values as before the move. </p>

</div>
</div>
<a id="afedaa2543b2404906532e1d425eabbd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afedaa2543b2404906532e1d425eabbd2">&#9670;&nbsp;</a></span>next()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::next </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structetl_1_1iterator__traits.html">etl::iterator_traits</a>&lt; InputIt &gt;::difference_type&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; InputIt
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the nth successor of iterator it. </p>

</div>
</div>
<a id="add22a48a49c792039e0d0ec1eef5528b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add22a48a49c792039e0d0ec1eef5528b">&#9670;&nbsp;</a></span>none_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::none_of </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if unary predicate p returns true for no elements in the range [first, last). </p>

</div>
</div>
<a id="a300d68a0b017d8b6f41d000a8800cd77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a300d68a0b017d8b6f41d000a8800cd77">&#9670;&nbsp;</a></span>operator &()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: return <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>(static_cast&lt;unsigned int&gt;(l) &amp; static_cast&lt;unsigned int&gt;(r));. </p>

</div>
</div>
<a id="a30243ddf0699dede912521c57cb92a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30243ddf0699dede912521c57cb92a25">&#9670;&nbsp;</a></span>operator &=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: return l = l &amp; r;. </p>

</div>
</div>
<a id="abde631d12e3fa3eadef0726f8a1218ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abde631d12e3fa3eadef0726f8a1218ec">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1monostate.html">monostate</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1monostate.html">monostate</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All instances of <a class="el" href="structetl_1_1monostate.html" title="Unit type intended for use as a well-behaved empty alternative in etl::variant. In particular...">etl::monostate</a> compare equal. </p>

</div>
</div>
<a id="a295bd71db44f0eff27e67e5767360cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a295bd71db44f0eff27e67e5767360cdc">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , etl::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">etl::array</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">etl::array</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the contents of lhs and rhs lexicographically. The comparison is performed by a function equivalent to <a class="el" href="namespaceetl.html#afe5ebb5d35320f153506765261d81a03" title="Checks if the first range [first1, last1) is lexicographically less than the second range [first2...">etl::lexicographical_compare</a>. </p>

</div>
</div>
<a id="a799dae79119bbb5d967d25f990939522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a799dae79119bbb5d967d25f990939522">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; T1, T2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; T1, T2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests if both elements of lhs and rhs are equal, that is, compares lhs.first with rhs.first and lhs.second with rhs.second. </p>

</div>
</div>
<a id="a0199291e596a6580c028a4fbb4c1a439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0199291e596a6580c028a4fbb4c1a439">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classetl_1_1optional.html">optional</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two optional objects, lhs and rhs. </p>

</div>
</div>
<a id="a8e737d88ff2f1d432403026a91a24766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e737d88ff2f1d432403026a91a24766">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="ad6bf68822d73dd9f0d84b6a5aa3f3618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6bf68822d73dd9f0d84b6a5aa3f3618">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="aaad8ec05de177a5a989ca89fb1568698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad8ec05de177a5a989ca89fb1568698">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharType , class Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1basic__string__view.html">etl::basic_string_view</a>&lt; CharType, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classetl_1_1basic__string__view.html">etl::basic_string_view</a>&lt; CharType, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()): </p>
<p>Two views are equal if both the size of lhs and rhs are equal and each character in lhs has an equivalent character in rhs at the same position. </p>

</div>
</div>
<a id="a3d2867e9d12d25137a50a1b3aee3c5a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d2867e9d12d25137a50a1b3aee3c5a7">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3d6295f5e016b5d4473335bb3bdc056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d6295f5e016b5d4473335bb3bdc056">&#9670;&nbsp;</a></span>operator<() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1monostate.html">monostate</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1monostate.html">monostate</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All instances of <a class="el" href="structetl_1_1monostate.html" title="Unit type intended for use as a well-behaved empty alternative in etl::variant. In particular...">etl::monostate</a> compare equal. </p>

</div>
</div>
<a id="a92e223941035502e547d8793e780a8e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e223941035502e547d8793e780a8e6">&#9670;&nbsp;</a></span>operator<() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , etl::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">etl::array</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">etl::array</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the contents of lhs and rhs lexicographically. The comparison is performed by a function equivalent to <a class="el" href="namespaceetl.html#afe5ebb5d35320f153506765261d81a03" title="Checks if the first range [first1, last1) is lexicographically less than the second range [first2...">etl::lexicographical_compare</a>. </p>

</div>
</div>
<a id="a2c7b429dca0b762facbaea24836f0995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c7b429dca0b762facbaea24836f0995">&#9670;&nbsp;</a></span>operator<() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; T1, T2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; T1, T2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements. </p>

</div>
</div>
<a id="ad2dad36bf3c15c14d239e80047211e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2dad36bf3c15c14d239e80047211e27">&#9670;&nbsp;</a></span>operator<() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classetl_1_1optional.html">optional</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two optional objects, lhs and rhs. </p>

</div>
</div>
<a id="a7d07feb0fa4c7f8287a166fbbe4975ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d07feb0fa4c7f8287a166fbbe4975ee">&#9670;&nbsp;</a></span>operator<() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="a0b91acd82b61f0b96647711aa1414b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b91acd82b61f0b96647711aa1414b71">&#9670;&nbsp;</a></span>operator<() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="a67cf06af339b11fe81d54b7f93c1334e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67cf06af339b11fe81d54b7f93c1334e">&#9670;&nbsp;</a></span>operator<() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharType , class Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1basic__string__view.html">etl::basic_string_view</a>&lt; CharType, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classetl_1_1basic__string__view.html">etl::basic_string_view</a>&lt; CharType, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()): </p>
<p>The ordering comparisons are done lexicographically &ndash; the comparison is performed by a function equivalent to <a class="el" href="namespaceetl.html#afe5ebb5d35320f153506765261d81a03" title="Checks if the first range [first1, last1) is lexicographically less than the second range [first2...">etl::lexicographical_compare</a>. </p>

</div>
</div>
<a id="ab0dfb93223a9c8e4413fe9368cd36046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0dfb93223a9c8e4413fe9368cd36046">&#9670;&nbsp;</a></span>operator<() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0480e65e737703d71651dbf0ec77f6be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0480e65e737703d71651dbf0ec77f6be">&#9670;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt;<a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt;Integer&gt;, <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: return <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>(static_cast&lt;unsigned int&gt;(b) &lt;&lt; shift); This overload only participates in overload resolution if <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v&lt;Integer&gt;</a> is true. </p>

</div>
</div>
<a id="a4d724ccacf75835ddc7e208bf977df9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d724ccacf75835ddc7e208bf977df9e">&#9670;&nbsp;</a></span>operator<<=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt;&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt;<a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt;Integer&gt;, <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&amp;&gt;

</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: return b = b &lt;&lt; shift; This overload only participates in overload resolution if <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v&lt;Integer&gt;</a> is true. </p>

</div>
</div>
<a id="a15e6f06421ee1d47e10ac411d5266606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e6f06421ee1d47e10ac411d5266606">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1monostate.html">monostate</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1monostate.html">monostate</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All instances of <a class="el" href="structetl_1_1monostate.html" title="Unit type intended for use as a well-behaved empty alternative in etl::variant. In particular...">etl::monostate</a> compare equal. </p>

</div>
</div>
<a id="ab2ed5e457d650aa10897012d52cd42fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ed5e457d650aa10897012d52cd42fa">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , etl::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">etl::array</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">etl::array</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the contents of lhs and rhs lexicographically. The comparison is performed by a function equivalent to <a class="el" href="namespaceetl.html#afe5ebb5d35320f153506765261d81a03" title="Checks if the first range [first1, last1) is lexicographically less than the second range [first2...">etl::lexicographical_compare</a>. </p>

</div>
</div>
<a id="a7562e604a7a1298eda82e34e2f8dab40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7562e604a7a1298eda82e34e2f8dab40">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; T1, T2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; T1, T2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements. </p>

</div>
</div>
<a id="abc6d41e110c97a6f118fac996337da06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc6d41e110c97a6f118fac996337da06">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classetl_1_1optional.html">optional</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two optional objects, lhs and rhs. </p>

</div>
</div>
<a id="a0ffa5aed44c30aae39950e0d82c7a256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ffa5aed44c30aae39950e0d82c7a256">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="a3003b74d5cf5363cb983a63f0beaa5b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3003b74d5cf5363cb983a63f0beaa5b8">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="ad0de7f91cc35b7999972eb423539d892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0de7f91cc35b7999972eb423539d892">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharType , class Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1basic__string__view.html">etl::basic_string_view</a>&lt; CharType, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classetl_1_1basic__string__view.html">etl::basic_string_view</a>&lt; CharType, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()): </p>
<p>The ordering comparisons are done lexicographically &ndash; the comparison is performed by a function equivalent to <a class="el" href="namespaceetl.html#afe5ebb5d35320f153506765261d81a03" title="Checks if the first range [first1, last1) is lexicographically less than the second range [first2...">etl::lexicographical_compare</a>. </p>

</div>
</div>
<a id="a715395c53fa693969e269ef5af1972e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a715395c53fa693969e269ef5af1972e6">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4805fd3b0cdc0a1a3db6475f16708849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4805fd3b0cdc0a1a3db6475f16708849">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1monostate.html">monostate</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1monostate.html">monostate</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All instances of <a class="el" href="structetl_1_1monostate.html" title="Unit type intended for use as a well-behaved empty alternative in etl::variant. In particular...">etl::monostate</a> compare equal. </p>

</div>
</div>
<a id="acd14c4b2bb371a67b0b7e5359471eb58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd14c4b2bb371a67b0b7e5359471eb58">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , etl::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">etl::array</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">etl::array</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the contents of lhs and rhs are equal, that is, they have the same number of elements and each element in lhs compares equal with the element in rhs at the same position. </p>

</div>
</div>
<a id="ae2a4e54525fb4847cb202baaff5657d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2a4e54525fb4847cb202baaff5657d8">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; T1, T2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; T1, T2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests if both elements of lhs and rhs are equal, that is, compares lhs.first with rhs.first and lhs.second with rhs.second. </p>

</div>
</div>
<a id="a5d1cc2f7a422e0cadab9361b16f7e875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1cc2f7a422e0cadab9361b16f7e875">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classetl_1_1optional.html">optional</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two optional objects, lhs and rhs. </p>

</div>
</div>
<a id="afbb0eb100ae57232d484215f1b4315d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb0eb100ae57232d484215f1b4315d6">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="a55bdc0584358e44c777f1ff6dd845026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55bdc0584358e44c777f1ff6dd845026">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="a32f6e7555448a64b1558e3f5b9771718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32f6e7555448a64b1558e3f5b9771718">&#9670;&nbsp;</a></span>operator==() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharType , class Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1basic__string__view.html">etl::basic_string_view</a>&lt; CharType, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classetl_1_1basic__string__view.html">etl::basic_string_view</a>&lt; CharType, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()): </p>
<p>Two views are equal if both the size of lhs and rhs are equal and each character in lhs has an equivalent character in rhs at the same position. </p>

</div>
</div>
<a id="a9d3aa3446aca179d812252faf83360c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d3aa3446aca179d812252faf83360c6">&#9670;&nbsp;</a></span>operator==() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7e919d889b1cffc2fe30748064be47d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e919d889b1cffc2fe30748064be47d">&#9670;&nbsp;</a></span>operator>() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1monostate.html">monostate</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1monostate.html">monostate</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All instances of <a class="el" href="structetl_1_1monostate.html" title="Unit type intended for use as a well-behaved empty alternative in etl::variant. In particular...">etl::monostate</a> compare equal. </p>

</div>
</div>
<a id="a1b2006aed7a710a77f2d7fff71d49a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2006aed7a710a77f2d7fff71d49a03">&#9670;&nbsp;</a></span>operator>() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , etl::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">etl::array</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">etl::array</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the contents of lhs and rhs lexicographically. The comparison is performed by a function equivalent to <a class="el" href="namespaceetl.html#afe5ebb5d35320f153506765261d81a03" title="Checks if the first range [first1, last1) is lexicographically less than the second range [first2...">etl::lexicographical_compare</a>. </p>

</div>
</div>
<a id="a08cb376464287fd4c82dc6d4ca604081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08cb376464287fd4c82dc6d4ca604081">&#9670;&nbsp;</a></span>operator>() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; T1, T2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; T1, T2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements. </p>

</div>
</div>
<a id="aa8cfb4c68d3b5bf2a12e64973a9ee892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8cfb4c68d3b5bf2a12e64973a9ee892">&#9670;&nbsp;</a></span>operator>() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classetl_1_1optional.html">optional</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two optional objects, lhs and rhs. </p>

</div>
</div>
<a id="aa2ec0f3b39223f0c48dcae6bf744ac8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ec0f3b39223f0c48dcae6bf744ac8f">&#9670;&nbsp;</a></span>operator>() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="a070d0943c411911df11ac5176fa48016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070d0943c411911df11ac5176fa48016">&#9670;&nbsp;</a></span>operator>() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="a610759a20e2af85ebdd5bdf54a5418a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610759a20e2af85ebdd5bdf54a5418a5">&#9670;&nbsp;</a></span>operator>() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharType , class Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1basic__string__view.html">etl::basic_string_view</a>&lt; CharType, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classetl_1_1basic__string__view.html">etl::basic_string_view</a>&lt; CharType, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()): </p>
<p>The ordering comparisons are done lexicographically &ndash; the comparison is performed by a function equivalent to <a class="el" href="namespaceetl.html#afe5ebb5d35320f153506765261d81a03" title="Checks if the first range [first1, last1) is lexicographically less than the second range [first2...">etl::lexicographical_compare</a>. </p>

</div>
</div>
<a id="ad4fd2ea0cf33ad9339a54469a92f5121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4fd2ea0cf33ad9339a54469a92f5121">&#9670;&nbsp;</a></span>operator>() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c9427318b650a4b9bc68d9c363e7b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c9427318b650a4b9bc68d9c363e7b6a">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1monostate.html">monostate</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1monostate.html">monostate</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All instances of <a class="el" href="structetl_1_1monostate.html" title="Unit type intended for use as a well-behaved empty alternative in etl::variant. In particular...">etl::monostate</a> compare equal. </p>

</div>
</div>
<a id="a963d59bdcd892d002ca5733c2627cff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a963d59bdcd892d002ca5733c2627cff4">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , etl::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">etl::array</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">etl::array</a>&lt; T, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the contents of lhs and rhs lexicographically. The comparison is performed by a function equivalent to <a class="el" href="namespaceetl.html#afe5ebb5d35320f153506765261d81a03" title="Checks if the first range [first1, last1) is lexicographically less than the second range [first2...">etl::lexicographical_compare</a>. </p>

</div>
</div>
<a id="ae48ced933809d3ce47af09003416996d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae48ced933809d3ce47af09003416996d">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; T1, T2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1pair.html">etl::pair</a>&lt; T1, T2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares lhs and rhs lexicographically by operator&lt;, that is, compares the first elements and only if they are equivalent, compares the second elements. </p>

</div>
</div>
<a id="a4cd1c4702ae19a08b1aa3f03807f1267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd1c4702ae19a08b1aa3f03807f1267">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classetl_1_1optional.html">optional</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two optional objects, lhs and rhs. </p>

</div>
</div>
<a id="ad322ae7ca3d230a2cfb6aae8d633356b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad322ae7ca3d230a2cfb6aae8d633356b">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="a8fe18304d67bab939fd57ac52900323a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe18304d67bab939fd57ac52900323a">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares opt with a nullopt. Equivalent to when comparing to an optional that does not contain a value. </p>

</div>
</div>
<a id="a4151e119ab2900682096503b5592cdd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4151e119ab2900682096503b5592cdd1">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharType , class Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1basic__string__view.html">etl::basic_string_view</a>&lt; CharType, Traits &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classetl_1_1basic__string__view.html">etl::basic_string_view</a>&lt; CharType, Traits &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two views. All comparisons are done via the compare() member function (which itself is defined in terms of Traits::compare()): </p>
<p>The ordering comparisons are done lexicographically &ndash; the comparison is performed by a function equivalent to <a class="el" href="namespaceetl.html#afe5ebb5d35320f153506765261d81a03" title="Checks if the first range [first1, last1) is lexicographically less than the second range [first2...">etl::lexicographical_compare</a>. </p>

</div>
</div>
<a id="aebf47ed021fd1e8bfbc389525967e551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf47ed021fd1e8bfbc389525967e551">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classetl_1_1static__vector.html">static_vector</a>&lt; T, Capacity &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac45fcae26cfb190fcc8ea6ab10da01f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45fcae26cfb190fcc8ea6ab10da01f0">&#9670;&nbsp;</a></span>operator>>()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt;<a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt;Integer&gt;, <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: return <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>(static_cast&lt;unsigned int&gt;(b) &gt;&gt; shift); This overload only participates in overload resolution if <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v&lt;Integer&gt;</a> is true. </p>

</div>
</div>
<a id="a12556a00fd4d36c275c51643b2c6168a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12556a00fd4d36c275c51643b2c6168a">&#9670;&nbsp;</a></span>operator>>=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator&gt;&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt;<a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt;Integer&gt;, <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&amp;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: return b = b &gt;&gt; shift; This overload only participates in overload resolution if <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v&lt;Integer&gt;</a> is true. </p>

</div>
</div>
<a id="a6ca2f44bc05dd8dbd6f9ea8beadef229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca2f44bc05dd8dbd6f9ea8beadef229">&#9670;&nbsp;</a></span>operator^()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator^ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: return <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>(static_cast&lt;unsigned int&gt;(l) ^ static_cast&lt;unsigned int&gt;(r));. </p>

</div>
</div>
<a id="a0145ea9af63899833b6bf5f9f18fb7c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0145ea9af63899833b6bf5f9f18fb7c1">&#9670;&nbsp;</a></span>operator^=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator^= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: return l = l ^ r;. </p>

</div>
</div>
<a id="a8fe220615749beb7a953b281e623e529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe220615749beb7a953b281e623e529">&#9670;&nbsp;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: return <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>(static_cast&lt;unsigned int&gt;(l) | static_cast&lt;unsigned int&gt;(r));. </p>

</div>
</div>
<a id="a73f53c7f64802ca7093607b55cb86bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f53c7f64802ca7093607b55cb86bc6">&#9670;&nbsp;</a></span>operator|=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator|= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&amp;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: return l = l | r;. </p>

</div>
</div>
<a id="a6cb428553f8379a8f3920c202cd85993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb428553f8379a8f3920c202cd85993">&#9670;&nbsp;</a></span>operator~()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::operator~ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: return <a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>(~static_cast&lt;unsigned int&gt;(b));. </p>

</div>
</div>
<a id="ae75cac911cf6d9b9b3b37254bc227e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae75cac911cf6d9b9b3b37254bc227e53">&#9670;&nbsp;</a></span>optional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classetl_1_1optional.html">etl::optional</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="classetl_1_1optional.html">optional</a>&lt; T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>One deduction guide is provided for <a class="el" href="classetl_1_1optional.html">etl::optional</a> to account for the edge cases missed by the implicit deduction guides, in particular, non-copyable arguments and array to pointer conversion. </p>

</div>
</div>
<a id="a717726a2fed08cececaa93b504419300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a717726a2fed08cececaa93b504419300">&#9670;&nbsp;</a></span>partial_sum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt , class OutputIt , class BinaryOperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::partial_sum </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOperation&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIt
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the partial sums of the elements in the subranges of the range [first, last) and writes them to the range beginning at destination. This version uses the given binary function op, both applying <a class="el" href="namespaceetl.html#ad0a5b274f170d18a9e175fddf538a4bc" title="Moves the elements in the range [first, last), to another range beginning at d_first, starting from first and proceeding to last - 1. After this operation the elements in the moved-from range will still contain valid values of the appropriate type, but not necessarily the same values as before the move. ">etl::move</a> to their operands on the left hand side. </p>
<p>BinaryFunction must not invalidate any iterators, including the end iterators, or modify any elements of the range involved.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element past the last element written.</dd></dl>
<p>https://en.cppreference.com/w/cpp/algorithm/partial_sum </p>

</div>
</div>
<a id="a8d274a25ea5a88eb47898c8832795e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d274a25ea5a88eb47898c8832795e3e">&#9670;&nbsp;</a></span>partial_sum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt , class OutputIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::partial_sum </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIt
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the partial sums of the elements in the subranges of the range [first, last) and writes them to the range beginning at destination. This version uses operator+ to sum up the elements. </p>
<p>BinaryFunction must not invalidate any iterators, including the end iterators, or modify any elements of the range involved.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element past the last element written.</dd></dl>
<p>https://en.cppreference.com/w/cpp/algorithm/partial_sum </p>

</div>
</div>
<a id="aa90bcaf1e13dfc47ddc7a62033d7cedc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa90bcaf1e13dfc47ddc7a62033d7cedc">&#9670;&nbsp;</a></span>partition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::partition </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIt
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorders the elements in the range [first, last) in such a way that all elements for which the predicate p returns true precede the elements for which predicate p returns false. Relative order of the elements is not preserved. </p>

</div>
</div>
<a id="a966b3039757a35f7b1104a7f6c9b6523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a966b3039757a35f7b1104a7f6c9b6523">&#9670;&nbsp;</a></span>popcount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::popcount </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt;detail::is_unsigned_integer&lt;T&gt;::value, int&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of 1 bits in the value of x. </p>
<p>This overload only participates in overload resolution if T is an unsigned integer type (that is, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long, or an extended unsigned integer type). </p>

</div>
</div>
<a id="ad580aca5d1f9f6d65f28f4270cb765ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad580aca5d1f9f6d65f28f4270cb765ed">&#9670;&nbsp;</a></span>prev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BidirIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::prev </td>
          <td>(</td>
          <td class="paramtype">BidirIt&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structetl_1_1iterator__traits.html">etl::iterator_traits</a>&lt; BidirIt &gt;::difference_type&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; BidirIt
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the nth predecessor of iterator it. </p>

</div>
</div>
<a id="a9590c66ecd3e2668da22396b36470994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9590c66ecd3e2668da22396b36470994">&#9670;&nbsp;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BidirIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::reverse </td>
          <td>(</td>
          <td class="paramtype">BidirIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIter&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses the order of the elements in the range [first, last). Behaves as if applying <a class="el" href="namespaceetl.html#aa18b878794474881fce640e7a163abf3" title="Swaps the values of the elements the given iterators are pointing to. ">etl::iter_swap</a> to every pair of iterators first+i, (last-i) - 1 for each non-negative i &lt; (last-first)/2. </p>

</div>
</div>
<a id="a9cbd6a789b8ca03eeb582c7e2cb433e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cbd6a789b8ca03eeb582c7e2cb433e4">&#9670;&nbsp;</a></span>reverse_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BidirIter , typename OutputIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::reverse_copy </td>
          <td>(</td>
          <td class="paramtype">BidirIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIter&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIter
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the elements from the range [ <code>first</code>, <code>last</code> ) to another range beginning at d_first in such a way that the elements in the new range are in reverse order. </p>
<p>If the source and destination ranges (that is, [first, last) and [d_first, d_first+(last-first)) respectively) overlap, the behavior is undefined. </p>

</div>
</div>
<a id="a6c225b4298d1c3ad6d3d17d92fd865b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c225b4298d1c3ad6d3d17d92fd865b5">&#9670;&nbsp;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::rotate </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>n_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIt
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a left rotation on a range of elements. </p>
<p>Specifically, <a class="el" href="namespaceetl.html#a6c225b4298d1c3ad6d3d17d92fd865b5" title="Performs a left rotation on a range of elements. ">etl::rotate</a> swaps the elements in the range [first, last) in such a way that the element n_first becomes the first element of the new range and n_first - 1 becomes the last element. A precondition of this function is that [first, n_first) and [n_first, last) are valid ranges. </p>

</div>
</div>
<a id="ad9320ebd2b7f25fcb308f2dd939d356d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9320ebd2b7f25fcb308f2dd939d356d">&#9670;&nbsp;</a></span>scope_exit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FuncT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1scope__exit.html">etl::scope_exit</a> </td>
          <td>(</td>
          <td class="paramtype">FuncT&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structetl_1_1scope__exit.html">scope_exit</a>&lt; <a class="el" href="namespaceetl.html#ad602447fa93ad71f4db547fa0ae92883">etl::decay_t</a>&lt; FuncT &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7813a73d80057255ef78a69804f2f361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7813a73d80057255ef78a69804f2f361">&#9670;&nbsp;</a></span>search() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIter1 , class ForwardIter2 , class BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::search </td>
          <td>(</td>
          <td class="paramtype">ForwardIter1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIter1&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIter2&#160;</td>
          <td class="paramname"><em>s_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIter2&#160;</td>
          <td class="paramname"><em>s_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIter1
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches for the first occurrence of the sequence of elements [s_first, s_last) in the range [first, last). Elements are compared using the given binary predicate <code>pred</code>. </p>

</div>
</div>
<a id="af723526a6284b865a1a001958e4f72a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af723526a6284b865a1a001958e4f72a4">&#9670;&nbsp;</a></span>search() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIter1 , class ForwardIter2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::search </td>
          <td>(</td>
          <td class="paramtype">ForwardIter1&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIter1&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIter2&#160;</td>
          <td class="paramname"><em>s_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIter2&#160;</td>
          <td class="paramname"><em>s_last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIter1
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches for the first occurrence of the sequence of elements [s_first, s_last) in the range [first, last). Elements are compared using operator==. </p>

</div>
</div>
<a id="a358e4ef95efe7ae5429eb586dedf290f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a358e4ef95efe7ae5429eb586dedf290f">&#9670;&nbsp;</a></span>search() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIter , class Searcher &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::search </td>
          <td>(</td>
          <td class="paramtype">ForwardIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Searcher const &amp;&#160;</td>
          <td class="paramname"><em>searcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIter
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches the sequence [first, last) for the pattern specified in the constructor of searcher. </p>

</div>
</div>
<a id="af3008e042f920b06e2a67b1aa31a1803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3008e042f920b06e2a67b1aa31a1803">&#9670;&nbsp;</a></span>size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::size </td>
          <td>(</td>
          <td class="paramtype">C const &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt; decltype(c.size())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the given container c or array array. Returns <a class="el" href="namespaceetl.html#ac88d35eb701e83ae17b613e3041ef063" title="Returns the size of the given container c or array array. Returns N. ">c.size()</a>, converted to the return type if necessary. </p>

</div>
</div>
<a id="ac88d35eb701e83ae17b613e3041ef063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac88d35eb701e83ae17b613e3041ef063">&#9670;&nbsp;</a></span>size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , etl::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::size </td>
          <td>(</td>
          <td class="paramtype">const T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">etl::size_t</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the given container c or array array. Returns N. </p>

</div>
</div>
<a id="adda62f64ad31faeb43dab1bbe8b2a664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda62f64ad31faeb43dab1bbe8b2a664">&#9670;&nbsp;</a></span>sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt , typename Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::sort </td>
          <td>(</td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the elements in the range [first, last) in non-descending order. The order of equal elements is not guaranteed to be preserved. </p>
<p>A sequence is sorted with respect to a comparator comp if for any iterator it pointing to the sequence and any non-negative integer n such that it + n is a valid iterator pointing to an element of the sequence, comp(*(it + n), *it) (or *(it + n) &lt; *it) evaluates to false. Bubble sort implementation.</p>
<p>https://en.cppreference.com/w/cpp/algorithm/sort </p>

</div>
</div>
<a id="a29031b0fee25653ff42e6fab29670267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29031b0fee25653ff42e6fab29670267">&#9670;&nbsp;</a></span>sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::sort </td>
          <td>(</td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the elements in the range [first, last) in non-descending order. The order of equal elements is not guaranteed to be preserved. Elements are compared using operator&lt;. </p>
<p>A sequence is sorted with respect to a comparator comp if for any iterator it pointing to the sequence and any non-negative integer n such that it + n is a valid iterator pointing to an element of the sequence, comp(*(it + n), *it) (or *(it + n) &lt; *it) evaluates to false. Bubble sort implementation.</p>
<p>https://en.cppreference.com/w/cpp/algorithm/sort </p>

</div>
</div>
<a id="a0da3a02a79034271cbc560bc94dbe2cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da3a02a79034271cbc560bc94dbe2cd">&#9670;&nbsp;</a></span>span() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , etl::size_t Extent&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classetl_1_1span.html">etl::span</a> </td>
          <td>(</td>
          <td class="paramtype">Type(&amp;)&#160;</td>
          <td class="paramname">[Extent]</td><td>)</td>
          <td> -&gt;  <a class="el" href="classetl_1_1span.html">span</a>&lt; Type, Extent &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction Guides. From raw array. </p>

</div>
</div>
<a id="ac6ab2c6a5bc678d0ca3f5137c4004543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ab2c6a5bc678d0ca3f5137c4004543">&#9670;&nbsp;</a></span>span() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , etl::size_t Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classetl_1_1span.html">etl::span</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">etl::array</a>&lt; Type, Size &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="classetl_1_1span.html">span</a>&lt; Type, Size &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction Guides. From <a class="el" href="namespaceetl.html#ae5a13233ebf471c62f35f40b21128884" title="Deduction guide. ">etl::array&lt;Type, Size&gt;</a>. </p>

</div>
</div>
<a id="aa5667307c6ae6ae51fa6d1488fbab93b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5667307c6ae6ae51fa6d1488fbab93b">&#9670;&nbsp;</a></span>span() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , etl::size_t Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classetl_1_1span.html">etl::span</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">etl::array</a>&lt; Type, Size &gt; const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="classetl_1_1span.html">span</a>&lt; Type const, Size &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction Guides. From <a class="el" href="namespaceetl.html#ae5a13233ebf471c62f35f40b21128884" title="Deduction guide. ">etl::array&lt;Type const, Size&gt;</a>. </p>

</div>
</div>
<a id="a9e186959b2d5132ab142843576d30048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e186959b2d5132ab142843576d30048">&#9670;&nbsp;</a></span>span() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , class Element  = etl::remove_pointer_t&lt;decltype(etl::declval&lt;Container&amp;&gt;().data())&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classetl_1_1span.html">etl::span</a> </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="classetl_1_1span.html">span</a>&lt; Element &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction Guides. From Container. </p>

</div>
</div>
<a id="adc55cb127ec094c3dbdec3ed03452ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc55cb127ec094c3dbdec3ed03452ebc">&#9670;&nbsp;</a></span>span() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , class Element  = etl::remove_pointer_t&lt;decltype(etl::declval&lt;Container const&amp;&gt;().data())&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classetl_1_1span.html">etl::span</a> </td>
          <td>(</td>
          <td class="paramtype">Container const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="classetl_1_1span.html">span</a>&lt; Element &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction Guides. From Container const. </p>

</div>
</div>
<a id="a120f5d964cae523ab637a2ec068011e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a120f5d964cae523ab637a2ec068011e4">&#9670;&nbsp;</a></span>stable_partition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BidirIt , typename UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::stable_partition </td>
          <td>(</td>
          <td class="paramtype">BidirIt&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirIt&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; BidirIt
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorders the elements in the range [first, last) in such a way that all elements for which the predicate p returns true precede the elements for which predicate p returns false. Relative order of the elements is preserved. </p>

</div>
</div>
<a id="ab5f8423cdd9669ce22e5b258d0755687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f8423cdd9669ce22e5b258d0755687">&#9670;&nbsp;</a></span>strcmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::strcmp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; int
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the C string lhs to the C string rhs. </p>
<p>This function starts comparing the first character of each string. If they are equal to each other, it continues with the following pairs until the characters differ or until a terminating null-character is reached. </p>

</div>
</div>
<a id="add013e52c2672440c53a8d2c82d4c63a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add013e52c2672440c53a8d2c82d4c63a">&#9670;&nbsp;</a></span>strlen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::strlen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">etl::size_t</a>
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length of the C string str. </p>

</div>
</div>
<a id="a0a1c3baeebc248b3f787a308af595c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1c3baeebc248b3f787a308af595c6a">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::swap </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  void</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the given values. Swaps the values a and b. This overload does not participate in overload resolution unless <a class="el" href="namespaceetl.html#a82b776d5da5e25514489bfd330d7940d">etl::is_move_constructible_v&lt;T&gt;</a> &amp;&amp; <a class="el" href="namespaceetl.html#ad208b3b6c99d59cdc5d698310e59143e">etl::is_move_assignable_v&lt;T&gt;</a> is true. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Fix noexcept specifier. https://en.cppreference.com/w/cpp/algorithm/swap </dd></dl>

</div>
</div>
<a id="a0f31d2c1983d613a5b1be68a431cfd13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f31d2c1983d613a5b1be68a431cfd13">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , etl::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">etl::array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structetl_1_1array.html">etl::array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specializes the <a class="el" href="namespaceetl.html#a0a1c3baeebc248b3f787a308af595c6a" title="Exchanges the given values. Swaps the values a and b. This overload does not participate in overload ...">etl::swap</a> algorithm for <a class="el" href="structetl_1_1array.html" title="etl::array is a container that encapsulates fixed size arrays. ">etl::array</a>. Swaps the contents of lhs and rhs. </p>

</div>
</div>
<a id="aaa84e096751094f12fc96460addc2483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa84e096751094f12fc96460addc2483">&#9670;&nbsp;</a></span>to_integer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::to_integer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceetl.html#a3fe360a11ae9b0c5886f80ce2ff28a9d">etl::byte</a>&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a>&lt;<a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a>&lt;Integer&gt;, Integer&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to: return Integer(b); This overload only participates in overload resolution if <a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v&lt;Integer&gt;</a> is true. </p>

</div>
</div>
<a id="a32dd2ffddadb248b341e42879a9e9951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32dd2ffddadb248b341e42879a9e9951">&#9670;&nbsp;</a></span>transform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIter , typename OutputIter , typename UnaryOperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::transform </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIter&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryOperation&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIter
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the given function to a range and stores the result in another range, beginning at <code>destination</code>. The unary operation unary_op is applied to the range defined by [ <code>first</code>, <code>last</code> ). </p>
<p>https://en.cppreference.com/w/cpp/algorithm/transform </p>

</div>
</div>
<a id="a85f81702ed6fdeecec082a39e50e4e2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f81702ed6fdeecec082a39e50e4e2a">&#9670;&nbsp;</a></span>transform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIter1 , typename InputIter2 , typename OutputIter , typename BinaryOperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::transform </td>
          <td>(</td>
          <td class="paramtype">InputIter1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIter&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOperation&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIter
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the given function to a range and stores the result in another range, beginning at destination. The binary operation binary_op is applied to pairs of elements from two ranges: one defined by [first1, last1) and the other beginning at first2. </p>
<p>https://en.cppreference.com/w/cpp/algorithm/transform </p>

</div>
</div>
<a id="a9b71bc0359b4e8144996d1a1ea271d46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b71bc0359b4e8144996d1a1ea271d46">&#9670;&nbsp;</a></span>unique() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIter , class BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::unique </td>
          <td>(</td>
          <td class="paramtype">ForwardIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIter
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eliminates all except the first element from every consecutive group of equivalent elements from the range [first, last) and returns a past-the-end iterator for the new logical end of the range. </p>

</div>
</div>
<a id="a825f3aafcdce4f906287730fe3a44709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a825f3aafcdce4f906287730fe3a44709">&#9670;&nbsp;</a></span>unique() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::unique </td>
          <td>(</td>
          <td class="paramtype">ForwardIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIter&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; ForwardIter
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eliminates all except the first element from every consecutive group of equivalent elements from the range [first, last) and returns a past-the-end iterator for the new logical end of the range. </p>

</div>
</div>
<a id="ad7c85c3f38fdc2e8f49bdb6c5e5dea43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7c85c3f38fdc2e8f49bdb6c5e5dea43">&#9670;&nbsp;</a></span>unique_copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIter , typename OutputIter , typename BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::unique_copy </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIter&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIter
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the elements from the range [first, last), to another range beginning at d_first in such a way that there are no consecutive equal elements. Only the first element of each group of equal elements is copied. </p>
<p>Elements are compared using the given binary predicate <code>pred</code>. The behavior is undefined if it is not an equivalence relation. </p>

</div>
</div>
<a id="a75adac4ca1890a2c3dee203f76fee1bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75adac4ca1890a2c3dee203f76fee1bf">&#9670;&nbsp;</a></span>unique_copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIter , class OutputIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::unique_copy </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIter&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; OutputIter
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the elements from the range [first, last), to another range beginning at d_first in such a way that there are no consecutive equal elements. Only the first element of each group of equal elements is copied. </p>
<p>Elements are compared using operator==. The behavior is undefined if it is not an equivalence relation. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a03ee00292ff760cd8ecf8b41bb4de696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03ee00292ff760cd8ecf8b41bb4de696">&#9670;&nbsp;</a></span>adopt_lock</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structetl_1_1adopt__lock__t.html">adopt_lock_t</a> etl::adopt_lock {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instances of empty struct tag types. See <a class="el" href="structetl_1_1adopt__lock__t.html" title="Empty class tag types used to specify locking strategy for etl::lock_guard, etl::scoped_lock, etl::unique_lock, and etl::shared_lock. ">adopt_lock_t</a>. </p>

</div>
</div>
<a id="af0d9f32a20bf813fd8ce025d0aebbff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0d9f32a20bf813fd8ce025d0aebbff5">&#9670;&nbsp;</a></span>conjunction_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... B&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::conjunction_v = <a class="el" href="structetl_1_1conjunction.html">conjunction</a>&lt;B...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e9e177fde5dc55ea58bb3771c37051a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e9e177fde5dc55ea58bb3771c37051a">&#9670;&nbsp;</a></span>defer_lock</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structetl_1_1defer__lock__t.html">defer_lock_t</a> etl::defer_lock {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instances of empty struct tag types. See <a class="el" href="structetl_1_1defer__lock__t.html" title="Empty class tag types used to specify locking strategy for etl::lock_guard, etl::scoped_lock, etl::unique_lock, and etl::shared_lock. ">defer_lock_t</a>. </p>

</div>
</div>
<a id="a29f460d9cd9dc39f08fc926828d8b442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f460d9cd9dc39f08fc926828d8b442">&#9670;&nbsp;</a></span>disjunction_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... B&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::disjunction_v = <a class="el" href="structetl_1_1disjunction.html">disjunction</a>&lt;B...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae174223df490e6263d4648a86326c902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae174223df490e6263d4648a86326c902">&#9670;&nbsp;</a></span>dynamic_extent</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::dynamic_extent = <a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">size_t</a>(-1)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespaceetl.html#ae174223df490e6263d4648a86326c902" title="etl::dynamic_extent is a constant of type etl::size_t that is used to differentiate etl::span of stat...">etl::dynamic_extent</a> is a constant of type <a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">etl::size_t</a> that is used to differentiate <a class="el" href="classetl_1_1span.html" title="A non-owning view over a contiguous sequence of objects. ">etl::span</a> of static and dynamic extent. </p>

</div>
</div>
<a id="a46f3f4c2468d1d1f33a449bf167efbbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46f3f4c2468d1d1f33a449bf167efbbc">&#9670;&nbsp;</a></span>has_virtual_destructor_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::has_virtual_destructor_v = <a class="el" href="structetl_1_1has__virtual__destructor.html">has_virtual_destructor</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a href="https://en.cppreference.com/w/cpp/types/has_virtual_destructor">https://en.cppreference.com/w/cpp/types/has_virtual_destructor</a> </p>

</div>
</div>
<a id="a4e2e748d9aa9eee89e9ae27c1783dbea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e2e748d9aa9eee89e9ae27c1783dbea">&#9670;&nbsp;</a></span>in_place</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::in_place = <a class="el" href="structetl_1_1in__place__t.html">in_place_t</a> {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c179dea2a5063201728cd0823d49e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c179dea2a5063201728cd0823d49e4f">&#9670;&nbsp;</a></span>in_place_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::in_place_index = <a class="el" href="structetl_1_1in__place__index__t.html">in_place_index_t</a>&lt;I&gt; {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e9c16f25058085d7b41037104bfea25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e9c16f25058085d7b41037104bfea25">&#9670;&nbsp;</a></span>in_place_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::in_place_type = <a class="el" href="structetl_1_1in__place__type__t.html">in_place_type_t</a>&lt;T&gt; {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a105e2a5ac8fc634dcc71675e27e3f95e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105e2a5ac8fc634dcc71675e27e3f95e">&#9670;&nbsp;</a></span>is_arithmetic_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_arithmetic_v = <a class="el" href="structetl_1_1is__arithmetic.html">is_arithmetic</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afaa46050181985a6156a6c800c86a7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa46050181985a6156a6c800c86a7d8">&#9670;&nbsp;</a></span>is_array_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_array_v = <a class="el" href="structetl_1_1is__array.html">is_array</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae630f4cbcf30c3c7912d50547711e86d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae630f4cbcf30c3c7912d50547711e86d">&#9670;&nbsp;</a></span>is_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_assignable_v = <a class="el" href="structetl_1_1is__assignable.html">is_assignable</a>&lt;T, U&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af00bab8d0b02bcb2974969b9d69639bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00bab8d0b02bcb2974969b9d69639bb">&#9670;&nbsp;</a></span>is_base_of_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Base , class Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_base_of_v = <a class="el" href="structetl_1_1is__base__of.html">is_base_of</a>&lt;Base, Derived&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6d2eef20a4d7f2fcfb333c7e5c23444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d2eef20a4d7f2fcfb333c7e5c23444">&#9670;&nbsp;</a></span>is_bounded_array_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_bounded_array_v = <a class="el" href="structetl_1_1is__bounded__array.html">is_bounded_array</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af8d441fab48eb459b77f6f5829f7fc75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d441fab48eb459b77f6f5829f7fc75">&#9670;&nbsp;</a></span>is_class_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_class_v = <a class="el" href="structetl_1_1is__class.html">is_class</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab45e49677aea4d7ed533e7c73ea7f2b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab45e49677aea4d7ed533e7c73ea7f2b6">&#9670;&nbsp;</a></span>is_compound_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_compound_v = <a class="el" href="structetl_1_1is__compound.html">is_compound</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a40862de0c689f5281b8d680741bc7cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40862de0c689f5281b8d680741bc7cf9">&#9670;&nbsp;</a></span>is_const_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_const_v = <a class="el" href="structetl_1_1is__const.html">is_const</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ab616d6855ca5fc60968a153587b2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab616d6855ca5fc60968a153587b2b4">&#9670;&nbsp;</a></span>is_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_constructible_v = <a class="el" href="namespaceetl.html#a55bc1fa71ef93a7cd65389359e61683c">is_constructible</a>&lt;T, Args...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa15279e84c7ec40ef8a2d460b81b7fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa15279e84c7ec40ef8a2d460b81b7fb7">&#9670;&nbsp;</a></span>is_convertible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class From , class To &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_convertible_v = <a class="el" href="structetl_1_1is__convertible.html">is_convertible</a>&lt;From, To&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a17e13a2d8cce95954bee3d62ec059851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17e13a2d8cce95954bee3d62ec059851">&#9670;&nbsp;</a></span>is_copy_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_copy_assignable_v = <a class="el" href="structetl_1_1is__copy__assignable.html">is_copy_assignable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a045ef39158833b2ba6592fa8a1d0ebc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a045ef39158833b2ba6592fa8a1d0ebc1">&#9670;&nbsp;</a></span>is_copy_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_copy_constructible_v = <a class="el" href="structetl_1_1is__copy__constructible.html">is_copy_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0093a625b8acbeac1878b9a9668a2563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0093a625b8acbeac1878b9a9668a2563">&#9670;&nbsp;</a></span>is_default_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_default_constructible_v = <a class="el" href="structetl_1_1is__default__constructible.html">is_default_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a34ff2b6f5e9a98730031297120e28af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34ff2b6f5e9a98730031297120e28af4">&#9670;&nbsp;</a></span>is_destructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::is_destructible_v = <a class="el" href="structetl_1_1is__destructible.html">is_destructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a258143fbbaaef57434ff042f35db08a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258143fbbaaef57434ff042f35db08a6">&#9670;&nbsp;</a></span>is_empty_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_empty_v = <a class="el" href="structetl_1_1is__empty.html">is_empty</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4784b73e6d758a37358b62211a308ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4784b73e6d758a37358b62211a308ef">&#9670;&nbsp;</a></span>is_enum_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_enum_v = <a class="el" href="structetl_1_1is__enum.html">is_enum</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5cf273d19443134cffcd66310d027ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf273d19443134cffcd66310d027ae4">&#9670;&nbsp;</a></span>is_floating_point_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_floating_point_v = <a class="el" href="structetl_1_1is__floating__point.html">is_floating_point</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aec3b44fa05f956c1efc4f34af98bd1f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec3b44fa05f956c1efc4f34af98bd1f0">&#9670;&nbsp;</a></span>is_function_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_function_v = <a class="el" href="structetl_1_1is__function.html">is_function</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af6b1115f04c131e47ab31a50aa2194b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b1115f04c131e47ab31a50aa2194b2">&#9670;&nbsp;</a></span>is_fundamental_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_fundamental_v = <a class="el" href="structetl_1_1is__fundamental.html">is_fundamental</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ef2a50a29c8803d461abedd7437effd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ef2a50a29c8803d461abedd7437effd">&#9670;&nbsp;</a></span>is_integral_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_integral_v = <a class="el" href="structetl_1_1is__integral.html">is_integral</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abdf67506d7e83cba3f386c212a824e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf67506d7e83cba3f386c212a824e9c">&#9670;&nbsp;</a></span>is_lvalue_reference_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_lvalue_reference_v = <a class="el" href="structetl_1_1is__lvalue__reference.html">is_lvalue_reference</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a690a598d20472c340a3e6969d5fe58af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a690a598d20472c340a3e6969d5fe58af">&#9670;&nbsp;</a></span>is_member_function_pointer_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_member_function_pointer_v = <a class="el" href="structetl_1_1is__member__function__pointer.html">is_member_function_pointer</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a05fe5ff6b0b6727ff7c98a53e5eb1c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05fe5ff6b0b6727ff7c98a53e5eb1c80">&#9670;&nbsp;</a></span>is_member_object_pointer_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_member_object_pointer_v = <a class="el" href="structetl_1_1is__member__object__pointer.html">is_member_object_pointer</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adbaaa5057d498812ee848f491a20649a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbaaa5057d498812ee848f491a20649a">&#9670;&nbsp;</a></span>is_member_pointer_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_member_pointer_v = <a class="el" href="structetl_1_1is__member__pointer.html">is_member_pointer</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad208b3b6c99d59cdc5d698310e59143e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad208b3b6c99d59cdc5d698310e59143e">&#9670;&nbsp;</a></span>is_move_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_move_assignable_v = <a class="el" href="structetl_1_1is__move__assignable.html">is_move_assignable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a82b776d5da5e25514489bfd330d7940d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b776d5da5e25514489bfd330d7940d">&#9670;&nbsp;</a></span>is_move_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_move_constructible_v = <a class="el" href="structetl_1_1is__move__constructible.html">is_move_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a865b2c54ee24d227ee6f222e49fd076c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865b2c54ee24d227ee6f222e49fd076c">&#9670;&nbsp;</a></span>is_nothrow_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_nothrow_assignable_v = <a class="el" href="structetl_1_1is__nothrow__assignable.html">is_nothrow_assignable</a>&lt;T, U&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ff5fc00d3b16aa2421ea49dae4e864e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff5fc00d3b16aa2421ea49dae4e864e">&#9670;&nbsp;</a></span>is_nothrow_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_nothrow_constructible_v = <a class="el" href="structetl_1_1is__nothrow__constructible.html">is_nothrow_constructible</a>&lt;T, Args...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5684c28598fd5bde573fccdf36cccda9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5684c28598fd5bde573fccdf36cccda9">&#9670;&nbsp;</a></span>is_nothrow_copy_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_nothrow_copy_assignable_v = <a class="el" href="structetl_1_1is__nothrow__copy__assignable.html">is_nothrow_copy_assignable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab05ca75073ae3731fef7c09200d9f693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab05ca75073ae3731fef7c09200d9f693">&#9670;&nbsp;</a></span>is_nothrow_copy_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_nothrow_copy_constructible_v = <a class="el" href="structetl_1_1is__nothrow__copy__constructible.html">is_nothrow_copy_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a12e312d7578609fe1f21277a6d7a1606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e312d7578609fe1f21277a6d7a1606">&#9670;&nbsp;</a></span>is_nothrow_default_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_nothrow_default_constructible_v = <a class="el" href="structetl_1_1is__nothrow__default__constructible.html">is_nothrow_default_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a92bb068a979f4237eb8c218d4f0112f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92bb068a979f4237eb8c218d4f0112f2">&#9670;&nbsp;</a></span>is_nothrow_destructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_nothrow_destructible_v = <a class="el" href="structetl_1_1is__nothrow__destructible.html">is_nothrow_destructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5d18b577003e8d090a82e4c6d497cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d18b577003e8d090a82e4c6d497cdd">&#9670;&nbsp;</a></span>is_nothrow_move_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_nothrow_move_assignable_v = <a class="el" href="structetl_1_1is__nothrow__move__assignable.html">is_nothrow_move_assignable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac00f5b3ced7a1f4ebd3e7b1119a4c12a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac00f5b3ced7a1f4ebd3e7b1119a4c12a">&#9670;&nbsp;</a></span>is_nothrow_move_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_nothrow_move_constructible_v = <a class="el" href="structetl_1_1is__nothrow__move__constructible.html">is_nothrow_move_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4fe0a7655d7b161139e48f8eb34838ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe0a7655d7b161139e48f8eb34838ac">&#9670;&nbsp;</a></span>is_nothrow_swappable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_nothrow_swappable_v = <a class="el" href="structetl_1_1is__nothrow__swappable.html">is_nothrow_swappable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a016c8419365e8e3697a56040d335bca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a016c8419365e8e3697a56040d335bca4">&#9670;&nbsp;</a></span>is_null_pointer_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_null_pointer_v = <a class="el" href="structetl_1_1is__null__pointer.html">is_null_pointer</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a63efd09c0ee7195824be65423adadedc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63efd09c0ee7195824be65423adadedc">&#9670;&nbsp;</a></span>is_object_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_object_v = <a class="el" href="structetl_1_1is__object.html">is_object</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac00eca7d51c4d2c1021402ee9a70f03c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac00eca7d51c4d2c1021402ee9a70f03c">&#9670;&nbsp;</a></span>is_pointer_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_pointer_v = <a class="el" href="structetl_1_1is__pointer.html">is_pointer</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a22294e9170ea0547c68724eabe0c8c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22294e9170ea0547c68724eabe0c8c5a">&#9670;&nbsp;</a></span>is_reference_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_reference_v = <a class="el" href="structetl_1_1is__reference.html">is_reference</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af2cba0c4e29fbd91ba77cbf6b9744ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2cba0c4e29fbd91ba77cbf6b9744ebc">&#9670;&nbsp;</a></span>is_rvalue_reference_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_rvalue_reference_v = <a class="el" href="structetl_1_1is__rvalue__reference.html">is_rvalue_reference</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f74da2365a9a6f68d472686fd0f1666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f74da2365a9a6f68d472686fd0f1666">&#9670;&nbsp;</a></span>is_same_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_same_v = <a class="el" href="structetl_1_1is__same.html">is_same</a>&lt;T, U&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab43d223a689de0810df63d7c223d4228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43d223a689de0810df63d7c223d4228">&#9670;&nbsp;</a></span>is_scalar_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_scalar_v = <a class="el" href="structetl_1_1is__scalar.html">is_scalar</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aff3fadd2a1e349c45f524ab5444220ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff3fadd2a1e349c45f524ab5444220ff">&#9670;&nbsp;</a></span>is_signed_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_signed_v = <a class="el" href="structetl_1_1is__signed.html">is_signed</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a46cb1671f31576cce07cf1bac1e99f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46cb1671f31576cce07cf1bac1e99f7c">&#9670;&nbsp;</a></span>is_swappable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_swappable_v = <a class="el" href="structetl_1_1is__swappable.html">is_swappable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1dc5a4c4924b529a3f8760925c283ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc5a4c4924b529a3f8760925c283ce6">&#9670;&nbsp;</a></span>is_trivial_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_trivial_v = <a class="el" href="structetl_1_1is__trivial.html">is_trivial</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad2cfce5bc9de7ea45285ad503a807a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2cfce5bc9de7ea45285ad503a807a9b">&#9670;&nbsp;</a></span>is_trivially_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_trivially_assignable_v = <a class="el" href="structetl_1_1is__trivially__assignable.html">is_trivially_assignable</a>&lt;T, U&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a74c34b46b65c2b8fa633d1e6211b25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a74c34b46b65c2b8fa633d1e6211b25">&#9670;&nbsp;</a></span>is_trivially_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_trivially_constructible_v = <a class="el" href="structetl_1_1is__trivially__constructible.html">is_trivially_constructible</a>&lt;T, Args...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4028d9154b8d629e56fd488b33587786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4028d9154b8d629e56fd488b33587786">&#9670;&nbsp;</a></span>is_trivially_copy_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_trivially_copy_assignable_v = <a class="el" href="structetl_1_1is__trivially__copy__assignable.html">is_trivially_copy_assignable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac56b91d45ec88c108b77f55e9f6bc187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac56b91d45ec88c108b77f55e9f6bc187">&#9670;&nbsp;</a></span>is_trivially_copy_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_trivially_copy_constructible_v = <a class="el" href="structetl_1_1is__trivially__copy__constructible.html">is_trivially_copy_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b3b937c99443cbaf5f1817d061261bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b3b937c99443cbaf5f1817d061261bd">&#9670;&nbsp;</a></span>is_trivially_copyable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_trivially_copyable_v = <a class="el" href="classetl_1_1is__trivially__copyable.html">is_trivially_copyable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f37ab88cda78781a7aca13f18adac97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f37ab88cda78781a7aca13f18adac97">&#9670;&nbsp;</a></span>is_trivially_default_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_trivially_default_constructible_v = <a class="el" href="structetl_1_1is__trivially__default__constructible.html">is_trivially_default_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4bab71f6cd300d48e15293f0f45eed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4bab71f6cd300d48e15293f0f45eed0">&#9670;&nbsp;</a></span>is_trivially_destructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::is_trivially_destructible_v = <a class="el" href="structetl_1_1is__trivially__destructible.html">is_trivially_destructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3673480825caede3c2d5095f8a39fe0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3673480825caede3c2d5095f8a39fe0d">&#9670;&nbsp;</a></span>is_trivially_move_assignable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_trivially_move_assignable_v = <a class="el" href="structetl_1_1is__trivially__move__assignable.html">is_trivially_move_assignable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a74767dc0b6e2022826126e3581d7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a74767dc0b6e2022826126e3581d7ed">&#9670;&nbsp;</a></span>is_trivially_move_constructible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_trivially_move_constructible_v = <a class="el" href="structetl_1_1is__trivially__move__constructible.html">is_trivially_move_constructible</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a00c65af89fc55014250b54559626d075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c65af89fc55014250b54559626d075">&#9670;&nbsp;</a></span>is_unbounded_array_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_unbounded_array_v = <a class="el" href="structetl_1_1is__unbounded__array.html">is_unbounded_array</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a51d4c31d288adf2cb4c5d7fd14c32f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d4c31d288adf2cb4c5d7fd14c32f00">&#9670;&nbsp;</a></span>is_union_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_union_v = <a class="el" href="structetl_1_1is__union.html">is_union</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3bbd05dc09b68b19c63d7b4fbf6f1108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bbd05dc09b68b19c63d7b4fbf6f1108">&#9670;&nbsp;</a></span>is_unsigned_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_unsigned_v = <a class="el" href="structetl_1_1is__unsigned.html">is_unsigned</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a149f8ba4063995f2c8ed7248d93a4d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a149f8ba4063995f2c8ed7248d93a4d9e">&#9670;&nbsp;</a></span>is_void_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_void_v = <a class="el" href="structetl_1_1is__void.html">is_void</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa76b943cef158f554f60c8d61b6835bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76b943cef158f554f60c8d61b6835bc">&#9670;&nbsp;</a></span>is_volatile_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::is_volatile_v = <a class="el" href="structetl_1_1is__volatile.html">is_volatile</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e0422e10e238c05956150aa5f4ed77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e0422e10e238c05956150aa5f4ed77e">&#9670;&nbsp;</a></span>negation_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::negation_v = <a class="el" href="structetl_1_1negation.html">negation</a>&lt;B&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93d7a7601aedf2ce125a34a9d83b80a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d7a7601aedf2ce125a34a9d83b80a7">&#9670;&nbsp;</a></span>nullopt</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::nullopt = <a class="el" href="structetl_1_1nullopt__t.html">etl::nullopt_t</a> {{}}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespaceetl.html#a93d7a7601aedf2ce125a34a9d83b80a7" title="etl::nullopt is a constant of type etl::nullopt_t that is used to indicate optional type with uniniti...">etl::nullopt</a> is a constant of type <a class="el" href="structetl_1_1nullopt__t.html" title="etl::nullopt_t is an empty class type used to indicate optional type with uninitialized state...">etl::nullopt_t</a> that is used to indicate optional type with uninitialized state. </p>

</div>
</div>
<a id="a69282b501974163cc5557d48739f21c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69282b501974163cc5557d48739f21c4">&#9670;&nbsp;</a></span>piecewise_construct</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structetl_1_1piecewise__construct__t.html">piecewise_construct_t</a> etl::piecewise_construct {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The constant <a class="el" href="namespaceetl.html#a69282b501974163cc5557d48739f21c4" title="The constant etl::piecewise_construct is an instance of an empty struct tag type etl::piecewise_const...">etl::piecewise_construct</a> is an instance of an empty struct tag type <a class="el" href="structetl_1_1piecewise__construct__t.html" title="etl::piecewise_construct_t is an empty class tag type used to disambiguate between different function...">etl::piecewise_construct_t</a>. </p>

</div>
</div>
<a id="a56baa007c444a18e18b603a55d9957bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56baa007c444a18e18b603a55d9957bf">&#9670;&nbsp;</a></span>rank_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">etl::size_t</a> etl::rank_v = <a class="el" href="structetl_1_1rank.html">rank</a>&lt;Type&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a717a065b4d593697dc186ca84f51ffb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a717a065b4d593697dc186ca84f51ffb8">&#9670;&nbsp;</a></span>ratio_equal_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R1 , class R2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::ratio_equal_v = <a class="el" href="structetl_1_1ratio__equal.html">ratio_equal</a>&lt;R1, R2&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ed208c9b18aabc1288d0721225be488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ed208c9b18aabc1288d0721225be488">&#9670;&nbsp;</a></span>ratio_greater_equal_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R1 , class R2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::ratio_greater_equal_v = <a class="el" href="structetl_1_1ratio__greater__equal.html">ratio_greater_equal</a>&lt;R1, R2&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abce653ddb9ec91f96bda7e292725dc0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce653ddb9ec91f96bda7e292725dc0e">&#9670;&nbsp;</a></span>ratio_greater_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R1 , class R2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::ratio_greater_v = <a class="el" href="structetl_1_1ratio__greater.html">ratio_greater</a>&lt;R1, R2&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a31e01f9b1a6c95f6f7b793bdfb54755d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31e01f9b1a6c95f6f7b793bdfb54755d">&#9670;&nbsp;</a></span>ratio_less_equal_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R1 , class R2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::ratio_less_equal_v = <a class="el" href="structetl_1_1ratio__less__equal.html">ratio_less_equal</a>&lt;R1, R2&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8d7dd3cfa6494a27aaf40f11ec60b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8d7dd3cfa6494a27aaf40f11ec60b62">&#9670;&nbsp;</a></span>ratio_less_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R1 , class R2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::ratio_less_v = <a class="el" href="structetl_1_1ratio__less.html">ratio_less</a>&lt;R1, R2&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adf88cdc68bd2c8d7aa353d030c3c1e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf88cdc68bd2c8d7aa353d030c3c1e6c">&#9670;&nbsp;</a></span>ratio_not_equal_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R1 , class R2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool etl::ratio_not_equal_v = <a class="el" href="structetl_1_1ratio__not__equal.html">ratio_not_equal</a>&lt;R1, R2&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a086e79db17e8b72ae86d834fad514b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a086e79db17e8b72ae86d834fad514b2e">&#9670;&nbsp;</a></span>try_to_lock</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structetl_1_1try__to__lock__t.html">try_to_lock_t</a> etl::try_to_lock {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instances of empty struct tag types. See <a class="el" href="structetl_1_1try__to__lock__t.html" title="Empty class tag types used to specify locking strategy for etl::lock_guard, etl::scoped_lock, etl::unique_lock, and etl::shared_lock. ">try_to_lock_t</a>. </p>

</div>
</div>
<a id="abf153d087d14c7ed7794a0a7d4f5d08d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf153d087d14c7ed7794a0a7d4f5d08d">&#9670;&nbsp;</a></span>tuple_size_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">etl::size_t</a> etl::tuple_size_v = <a class="el" href="structetl_1_1tuple__size.html">tuple_size</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a28d369052fc23b452882a9fd514abb87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d369052fc23b452882a9fd514abb87">&#9670;&nbsp;</a></span>variant_npos</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto etl::variant_npos = static_cast&lt;<a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">etl::size_t</a>&gt;(-1)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a special value equal to the largest value representable by the type <a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">etl::size_t</a>, used as the return value of index() when valueless_by_exception() is true. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
