<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>taetl: etl/type_traits.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">taetl
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_6adb7a8b31c129f1821662822662f63e.html">etl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">type_traits.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="type__traits__decl_8hpp_source.html">detail/type_traits_decl.hpp</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for type_traits.hpp:</div>
<div class="dyncontent">
<div class="center"><img src="type__traits_8hpp__incl.png" border="0" usemap="#etl_2type__traits_8hpp" alt=""/></div>
<map name="etl_2type__traits_8hpp" id="etl_2type__traits_8hpp">
<area shape="rect" id="node2" href="type__traits__decl_8hpp.html" title="detail/type_traits\l_decl.hpp" alt="" coords="188,80,321,121"/>
<area shape="rect" id="node3" href="definitions_8hpp.html" title="etl/definitions.hpp" alt="" coords="96,169,235,196"/>
<area shape="rect" id="node7" href="intrinsics_8hpp.html" title="etl/detail/intrinsics.hpp" alt="" coords="259,169,429,196"/>
<area shape="rect" id="node4" href="version_8hpp.html" title="version.hpp" alt="" coords="5,244,104,271"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="type__traits_8hpp__dep__incl.png" border="0" usemap="#etl_2type__traits_8hppdep" alt=""/></div>
<map name="etl_2type__traits_8hppdep" id="etl_2type__traits_8hppdep">
<area shape="rect" id="node2" href="byte_8hpp.html" title="etl/byte.hpp" alt="" coords="307,80,407,107"/>
<area shape="rect" id="node9" href="utility_8hpp.html" title="etl/utility.hpp" alt="" coords="803,80,910,107"/>
<area shape="rect" id="node10" href="numeric_8hpp.html" title="etl/numeric.hpp" alt="" coords="1197,162,1321,189"/>
<area shape="rect" id="node11" href="ratio_8hpp.html" title="etl/ratio.hpp" alt="" coords="1309,244,1410,271"/>
<area shape="rect" id="node12" href="chrono_8hpp.html" title="etl/chrono.hpp" alt="" coords="1503,319,1618,345"/>
<area shape="rect" id="node17" href="bit_8hpp.html" title="etl/bit.hpp" alt="" coords="1347,80,1435,107"/>
<area shape="rect" id="node18" href="cmath_8hpp.html" title="etl/cmath.hpp" alt="" coords="1459,80,1571,107"/>
<area shape="rect" id="node19" href="concepts_8hpp.html" title="etl/concepts.hpp" alt="" coords="1595,80,1724,107"/>
<area shape="rect" id="node20" href="memory_8hpp.html" title="etl/memory.hpp" alt="" coords="5,244,129,271"/>
<area shape="rect" id="node21" href="span_8hpp.html" title="etl/span.hpp" alt="" coords="1800,80,1903,107"/>
<area shape="rect" id="node22" href="system__error_8hpp.html" title="etl/system_error.hpp" alt="" coords="1927,80,2083,107"/>
<area shape="rect" id="node3" href="functional_8hpp.html" title="etl/functional.hpp" alt="" coords="289,162,425,189"/>
<area shape="rect" id="node7" href="cstring_8hpp.html" title="etl/cstring.hpp" alt="" coords="150,162,265,189"/>
<area shape="rect" id="node4" href="algorithm_8hpp.html" title="etl/algorithm.hpp" alt="" coords="285,244,420,271"/>
<area shape="rect" id="node6" href="map_8hpp.html" title="etl/map.hpp" alt="" coords="444,244,544,271"/>
<area shape="rect" id="node5" href="string__view_8hpp.html" title="etl/string_view.hpp" alt="" coords="135,319,280,345"/>
<area shape="rect" id="node8" href="string_8hpp.html" title="etl/string.hpp" alt="" coords="153,244,261,271"/>
<area shape="rect" id="node13" href="dsp_8hpp.html" title="etl/experimental/dsp\l/dsp.hpp" alt="" coords="499,155,657,196"/>
<area shape="rect" id="node14" href="queue_8hpp.html" title="etl/experimental/rtos\l/queue.hpp" alt="" coords="681,155,840,196"/>
<area shape="rect" id="node15" href="strong__type_8hpp.html" title="etl/experimental/strong\l_type/strong_type.hpp" alt="" coords="864,155,1039,196"/>
<area shape="rect" id="node16" href="vector_8hpp.html" title="etl/vector.hpp" alt="" coords="1063,162,1173,189"/>
</map>
</div>
</div>
<p><a href="type__traits_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1integral__constant.html">etl::integral_constant&lt; Type, val &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1type__identity.html">etl::type_identity&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__lvalue__reference.html">etl::add_lvalue_reference&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__rvalue__reference.html">etl::add_rvalue_reference&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__extent.html">etl::remove_extent&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an array of some type X, provides the member typedef type equal to X, otherwise type is T. Note that if T is a multidimensional array, only the first dimension is removed. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1remove__extent.html" title="If T is an array of some type X, provides the member typedef type equal to X, otherwise type is T...">remove_extent</a> is undefined.  <a href="structetl_1_1remove__extent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__extent_3_01T[]_4.html">etl::remove_extent&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__extent_3_01T[N]_4.html">etl::remove_extent&lt; T[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__const.html">etl::remove_const&lt; Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except that its topmost cv-qualifiers are removed. Removes the topmost const.  <a href="structetl_1_1remove__const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__const_3_01Type_01const_01_4.html">etl::remove_const&lt; Type const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__volatile.html">etl::remove_volatile&lt; Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except that its topmost cv-qualifiers are removed. Removes the topmost volatile.  <a href="structetl_1_1remove__volatile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__volatile_3_01Type_01volatile_01_4.html">etl::remove_volatile&lt; Type volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__cv.html">etl::remove_cv&lt; Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except that its topmost cv-qualifiers are removed. Removes the topmost const, or the topmost volatile, or both, if present.  <a href="structetl_1_1remove__cv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__reference.html">etl::remove_reference&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__reference_3_01T_01_6_01_4.html">etl::remove_reference&lt; T &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__reference_3_01T_01_6_6_01_4.html">etl::remove_reference&lt; T &amp;&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__pointer.html">etl::add_pointer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a reference type, then provides the member typedef type which is a pointer to the referred type. Otherwise, if T names an object type, a function type that is not cv- or ref-qualified, or a (possibly cv-qualified) void type, provides the member typedef type which is the type T*. Otherwise (if T is a cv- or ref-qualified function type), provides the member typedef type which is the type T. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1add__pointer.html" title="If T is a reference type, then provides the member typedef type which is a pointer to the referred ty...">add_pointer</a> is undefined.  <a href="structetl_1_1add__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__same.html">etl::is_same&lt; T, U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T and U name the same type (taking into account const/volatile qualifications), provides the member constant value equal to true. Otherwise value is false.  <a href="structetl_1_1is__same.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__same_3_01T_00_01T_01_4.html">etl::is_same&lt; T, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__void.html">etl::is_void&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a member typedef only if a boolean constant is true.  <a href="structetl_1_1is__void.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__integral.html">etl::is_integral&lt; Type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1make__unsigned.html">etl::make_unsigned&lt; typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an integral (except bool) or enumeration type, provides the member typedef type which is the unsigned integer type corresponding to T, with the same cv-qualifiers. If T is signed or unsigned char, short, int, long, long long; the unsigned type from this list corresponding to T is provided. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1make__unsigned.html" title="If T is an integral (except bool) or enumeration type, provides the member typedef type which is the ...">make_unsigned</a> is undefined.  <a href="structetl_1_1make__unsigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1make__unsigned_3_01signed_01char_01_4.html">etl::make_unsigned&lt; signed char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1make__unsigned_3_01signed_01short_01_4.html">etl::make_unsigned&lt; signed short &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1make__unsigned_3_01signed_01int_01_4.html">etl::make_unsigned&lt; signed int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1make__unsigned_3_01signed_01long_01_4.html">etl::make_unsigned&lt; signed long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1make__unsigned_3_01signed_01long_01long_01_4.html">etl::make_unsigned&lt; signed long long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1make__unsigned_3_01unsigned_01char_01_4.html">etl::make_unsigned&lt; unsigned char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1make__unsigned_3_01unsigned_01short_01_4.html">etl::make_unsigned&lt; unsigned short &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1make__unsigned_3_01unsigned_01int_01_4.html">etl::make_unsigned&lt; unsigned int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1make__unsigned_3_01unsigned_01long_01_4.html">etl::make_unsigned&lt; unsigned long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1make__unsigned_3_01unsigned_01long_01long_01_4.html">etl::make_unsigned&lt; unsigned long long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__floating__point.html">etl::is_floating_point&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__const.html">etl::is_const&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__const_3_01const_01T_01_4.html">etl::is_const&lt; const T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__reference.html">etl::is_reference&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__reference_3_01T_01_6_01_4.html">etl::is_reference&lt; T &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__reference_3_01T_01_6_6_01_4.html">etl::is_reference&lt; T &amp;&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__null__pointer.html">etl::is_null_pointer&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__array.html">etl::is_array&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is an array type. Provides the member constant value which is equal to true, if T is an array type. Otherwise, value is equal to false.  <a href="structetl_1_1is__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__array_3_01T[]_4.html">etl::is_array&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__array_3_01T[N]_4.html">etl::is_array&lt; T[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__function.html">etl::is_function&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1detail_1_1is__pointer__helper.html">etl::detail::is_pointer_helper&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1detail_1_1is__pointer__helper_3_01T_01_5_01_4.html">etl::detail::is_pointer_helper&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__pointer.html">etl::is_pointer&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__class.html">etl::is_class&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__enum.html">etl::is_enum&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__union.html">etl::is_union&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1detail_1_1is__member__pointer__helper.html">etl::detail::is_member_pointer_helper&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1detail_1_1is__member__pointer__helper_3_01T_01U_1_1_5_01_4.html">etl::detail::is_member_pointer_helper&lt; T U::* &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__member__pointer.html">etl::is_member_pointer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is pointer to non-static member object or a pointer to non-static member function, provides the member constant value equal true. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__member__pointer.html" title="If T is pointer to non-static member object or a pointer to non-static member function, provides the member constant value equal true. For any other type, value is false. The behavior of a program that adds specializations for is_member_pointer or is_member_pointer_v (since C++17) is undefined. ">is_member_pointer</a> or is_member_pointer_v (since C++17) is undefined.  <a href="structetl_1_1is__member__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__arithmetic.html">etl::is_arithmetic&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an arithmetic type (that is, an integral type or a floating-point type) or a cv-qualified version thereof, provides the member constant value equal true. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__arithmetic.html" title="If T is an arithmetic type (that is, an integral type or a floating-point type) or a cv-qualified ver...">is_arithmetic</a> or is_arithmetic_v (since C++17) is undefined.  <a href="structetl_1_1is__arithmetic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__scalar.html">etl::is_scalar&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__object.html">etl::is_object&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1detail_1_1is__constructible__helper.html">etl::detail::is_constructible_helper&lt; class, T, Args &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1detail_1_1is__constructible__helper_3_01void__t_3_01decltype_07T_07declval_3_01Argsa80037a39bb9e756040a068d64e78d77.html">etl::detail::is_constructible_helper&lt; void_t&lt; decltype(T(declval&lt; Args &gt;()...))&gt;, T, Args... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__unsigned.html">etl::is_unsigned&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an arithmetic type, provides the member constant value equal to true if T(0) &lt; T(-1): this results in true for the unsigned integer types and the type bool and in false for the signed integer types and the floating-point types. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__unsigned.html" title="If T is an arithmetic type, provides the member constant value equal to true if T(0) &lt; T(-1): this re...">is_unsigned</a> or is_unsigned_v (since C++17) is undefined.  <a href="structetl_1_1is__unsigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1conditional.html">etl::conditional&lt; B, T, F &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides member typedef type, which is defined as T if B is true at compile time, or as F if B is false.  <a href="structetl_1_1conditional.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1conditional_3_01false_00_01T_00_01F_01_4.html">etl::conditional&lt; false, T, F &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1enable__if.html">etl::enable_if&lt; bool, Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a member typedef only if a boolean constant is true.  <a href="structetl_1_1enable__if.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1enable__if_3_01true_00_01Type_01_4.html">etl::enable_if&lt; true, Type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1rank.html">etl::rank&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Type is an array type, provides the member constant value equal to the number of dimensions of the array. For any other type, value is 0. The behavior of a program that adds specializations for rank or rank_v is undefined.  <a href="structetl_1_1rank.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1rank_3_01T[]_4.html">etl::rank&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1rank_3_01T[N]_4.html">etl::rank&lt; T[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1decay.html">etl::decay&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type.html">etl::common_type&lt;... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the common type among all types T..., that is the type all T... can be implicitly converted to. If such a type exists (as determined according to the rules below), the member type names that type. Otherwise, there is no member type. https://en.cppreference.com/w/cpp/types/common_type.  <a href="structetl_1_1common__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type_3_01T_01_4.html">etl::common_type&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1detail_1_1common__type__2__impl.html">etl::detail::common_type_2_impl&lt; T1, T2, class &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1detail_1_1common__type__2__impl_3_01T1_00_01T2_00_01void__t_3_01cond__t_3_01T1_00_01T2_01_4_01_4_01_4.html">etl::detail::common_type_2_impl&lt; T1, T2, void_t&lt; cond_t&lt; T1, T2 &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1detail_1_1common__type__multi__impl.html">etl::detail::common_type_multi_impl&lt; AlwaysVoid, T1, T2, R &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1detail_1_1common__type__multi__impl_3_01void__t_3_01typename_01common__type_3_01T1_c112970aa4406b128acca994532075af.html">etl::detail::common_type_multi_impl&lt; void_t&lt; typename common_type&lt; T1, T2 &gt;::type &gt;, T1, T2, R... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type_3_01T1_00_01T2_01_4.html">etl::common_type&lt; T1, T2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type_3_01T1_00_01T2_00_01R_8_8_8_01_4.html">etl::common_type&lt; T1, T2, R... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__convertible.html">etl::is_convertible&lt; From, To &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the imaginary function definition To test() { return <a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292">etl::declval&lt;From&gt;()</a>; } is well-formed, (that is, either <a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292">etl::declval&lt;From&gt;()</a> can be converted to To using implicit conversions, or both From and To are possibly cv-qualified void), provides the member constant value equal to true. Otherwise value is false. For the purposes of this check, the use of <a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292">etl::declval</a> in the return statement is not considered an odr-use. Access checks are performed as if from a context unrelated to either type. Only the validity of the immediate context of the expression in the return statement (including conversions to the return type) is considered.  <a href="structetl_1_1is__convertible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceetl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html">etl</a></td></tr>
<tr class="memdesc:namespaceetl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for the etl library. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceetl_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1detail.html">etl::detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa19ff9e7939158584698cee4260e4471"><td class="memTemplParams" colspan="2">template&lt;bool B&gt; </td></tr>
<tr class="memitem:aa19ff9e7939158584698cee4260e4471"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa19ff9e7939158584698cee4260e4471">etl::bool_constant</a> = integral_constant&lt; bool, B &gt;</td></tr>
<tr class="separator:aa19ff9e7939158584698cee4260e4471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b54646ef5937839803117924c49d01"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac5b54646ef5937839803117924c49d01">etl::true_type</a> = integral_constant&lt; bool, true &gt;</td></tr>
<tr class="separator:ac5b54646ef5937839803117924c49d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0917d3f5e85877c283c4f04e327fd973"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0917d3f5e85877c283c4f04e327fd973">etl::false_type</a> = integral_constant&lt; bool, false &gt;</td></tr>
<tr class="separator:a0917d3f5e85877c283c4f04e327fd973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f76cc2621d7373b79e2fc034f160ee0"><td class="memTemplParams" colspan="2">template&lt;class... &gt; </td></tr>
<tr class="memitem:a8f76cc2621d7373b79e2fc034f160ee0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8f76cc2621d7373b79e2fc034f160ee0">etl::void_t</a> = void</td></tr>
<tr class="separator:a8f76cc2621d7373b79e2fc034f160ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662329de2bc2a83d5e45d1ccad797f17"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a662329de2bc2a83d5e45d1ccad797f17"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a662329de2bc2a83d5e45d1ccad797f17">etl::add_lvalue_reference_t</a> = typename add_lvalue_reference&lt; T &gt;::type</td></tr>
<tr class="separator:a662329de2bc2a83d5e45d1ccad797f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c37a443b0cb66dc9b3c4374967b68f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a17c37a443b0cb66dc9b3c4374967b68f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a17c37a443b0cb66dc9b3c4374967b68f">etl::add_rvalue_reference_t</a> = typename add_rvalue_reference&lt; T &gt;::type</td></tr>
<tr class="separator:a17c37a443b0cb66dc9b3c4374967b68f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2368185596474aaf04490908f75e3a18"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2368185596474aaf04490908f75e3a18"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2368185596474aaf04490908f75e3a18">etl::remove_extent_t</a> = typename remove_extent&lt; T &gt;::type</td></tr>
<tr class="separator:a2368185596474aaf04490908f75e3a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e058aba499e52cc4ed554dd7d65332"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a87e058aba499e52cc4ed554dd7d65332"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a87e058aba499e52cc4ed554dd7d65332">etl::remove_const_t</a> = typename remove_const&lt; T &gt;::type</td></tr>
<tr class="separator:a87e058aba499e52cc4ed554dd7d65332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4593c7817c464ffa0d88cc07eb35e83"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af4593c7817c464ffa0d88cc07eb35e83"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af4593c7817c464ffa0d88cc07eb35e83">etl::remove_volatile_t</a> = typename remove_volatile&lt; T &gt;::type</td></tr>
<tr class="separator:af4593c7817c464ffa0d88cc07eb35e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70fb46b3c4c98f5f23b76cb25f343373"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a70fb46b3c4c98f5f23b76cb25f343373"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a70fb46b3c4c98f5f23b76cb25f343373">etl::remove_cv_t</a> = typename remove_cv&lt; T &gt;::type</td></tr>
<tr class="separator:a70fb46b3c4c98f5f23b76cb25f343373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ceb8de4fe37ef6a14f78dd10d95bb6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a26ceb8de4fe37ef6a14f78dd10d95bb6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a26ceb8de4fe37ef6a14f78dd10d95bb6">etl::remove_reference_t</a> = typename remove_reference&lt; T &gt;::type</td></tr>
<tr class="separator:a26ceb8de4fe37ef6a14f78dd10d95bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd20d67cb221212f49a97e02a7c1ca25"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:afd20d67cb221212f49a97e02a7c1ca25"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afd20d67cb221212f49a97e02a7c1ca25">etl::add_pointer_t</a> = typename add_pointer&lt; T &gt;::type</td></tr>
<tr class="separator:afd20d67cb221212f49a97e02a7c1ca25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2df53f4e399975501cf8300d451814"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:acb2df53f4e399975501cf8300d451814"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#acb2df53f4e399975501cf8300d451814">etl::make_unsigned_t</a> = typename make_unsigned&lt; T &gt;::type</td></tr>
<tr class="separator:acb2df53f4e399975501cf8300d451814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55bc1fa71ef93a7cd65389359e61683c"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:a55bc1fa71ef93a7cd65389359e61683c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a55bc1fa71ef93a7cd65389359e61683c">etl::is_constructible</a> = detail::is_constructible_helper&lt; void_t&lt;&gt;, T, Args... &gt;</td></tr>
<tr class="separator:a55bc1fa71ef93a7cd65389359e61683c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa508ba172c61957cf6c18357210f08f6"><td class="memTemplParams" colspan="2">template&lt;bool B, class T , class F &gt; </td></tr>
<tr class="memitem:aa508ba172c61957cf6c18357210f08f6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa508ba172c61957cf6c18357210f08f6">etl::conditional_t</a> = typename conditional&lt; B, T, F &gt;::type</td></tr>
<tr class="separator:aa508ba172c61957cf6c18357210f08f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2df4ab89284c8c5866afea3100f290"><td class="memTemplParams" colspan="2">template&lt;bool B, class T  = void&gt; </td></tr>
<tr class="memitem:a2a2df4ab89284c8c5866afea3100f290"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a> = typename enable_if&lt; B, T &gt;::type</td></tr>
<tr class="separator:a2a2df4ab89284c8c5866afea3100f290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad602447fa93ad71f4db547fa0ae92883"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad602447fa93ad71f4db547fa0ae92883"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad602447fa93ad71f4db547fa0ae92883">etl::decay_t</a> = typename decay&lt; T &gt;::type</td></tr>
<tr class="separator:ad602447fa93ad71f4db547fa0ae92883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5fb714218ae063870f7447fa845775"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a3f5fb714218ae063870f7447fa845775"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1detail.html#a3f5fb714218ae063870f7447fa845775">etl::detail::cond_t</a> = decltype(false ? <a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292">etl::declval</a>&lt; T1 &gt;() :<a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292">etl::declval</a>&lt; T2 &gt;())</td></tr>
<tr class="separator:a3f5fb714218ae063870f7447fa845775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80571ce0a1bbafdb4d8e153ceade9e3"><td class="memTemplParams" colspan="2">template&lt;class... T&gt; </td></tr>
<tr class="memitem:ac80571ce0a1bbafdb4d8e153ceade9e3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac80571ce0a1bbafdb4d8e153ceade9e3">etl::common_type_t</a> = typename common_type&lt; T... &gt;::type</td></tr>
<tr class="separator:ac80571ce0a1bbafdb4d8e153ceade9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4cc1f25c4439f63a860dc44358f5a5d"><td class="memTemplParams" colspan="2">template&lt;class &gt; </td></tr>
<tr class="memitem:af4cc1f25c4439f63a860dc44358f5a5d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1detail.html#af4cc1f25c4439f63a860dc44358f5a5d">etl::detail::true_type_for</a> = <a class="el" href="namespaceetl.html#ac5b54646ef5937839803117924c49d01">etl::true_type</a></td></tr>
<tr class="separator:af4cc1f25c4439f63a860dc44358f5a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a20925760992400af1add7c4aefcc1594"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a20925760992400af1add7c4aefcc1594"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1detail.html#a20925760992400af1add7c4aefcc1594">etl::detail::try_add_lvalue_reference</a> (int) -&gt; <a class="el" href="structetl_1_1type__identity.html">etl::type_identity</a>&lt; T &amp;&gt;</td></tr>
<tr class="separator:a20925760992400af1add7c4aefcc1594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91478ab6afd6aff813026f685090e1bc"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a91478ab6afd6aff813026f685090e1bc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1detail.html#a91478ab6afd6aff813026f685090e1bc">etl::detail::try_add_lvalue_reference</a> (...) -&gt; <a class="el" href="structetl_1_1type__identity.html">etl::type_identity</a>&lt; T &gt;</td></tr>
<tr class="separator:a91478ab6afd6aff813026f685090e1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398d1018579d999240bd8b9c196825bb"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a398d1018579d999240bd8b9c196825bb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1detail.html#a398d1018579d999240bd8b9c196825bb">etl::detail::try_add_rvalue_reference</a> (int) -&gt; <a class="el" href="structetl_1_1type__identity.html">etl::type_identity</a>&lt; T &amp;&amp;&gt;</td></tr>
<tr class="separator:a398d1018579d999240bd8b9c196825bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad68d8b46d3730e92536507812d6ab6f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aad68d8b46d3730e92536507812d6ab6f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1detail.html#aad68d8b46d3730e92536507812d6ab6f">etl::detail::try_add_rvalue_reference</a> (...) -&gt; <a class="el" href="structetl_1_1type__identity.html">etl::type_identity</a>&lt; T &gt;</td></tr>
<tr class="separator:aad68d8b46d3730e92536507812d6ab6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4147daa38c6c4c1e59540fa0fa27a292"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4147daa38c6c4c1e59540fa0fa27a292"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292">etl::declval</a> () noexcept -&gt; typename <a class="el" href="structetl_1_1add__rvalue__reference.html">etl::add_rvalue_reference</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a4147daa38c6c4c1e59540fa0fa27a292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf50ac295ca995606cb5bf055f2c267c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aaf50ac295ca995606cb5bf055f2c267c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1detail.html#aaf50ac295ca995606cb5bf055f2c267c">etl::detail::try_add_pointer</a> (int) -&gt; <a class="el" href="structetl_1_1type__identity.html">etl::type_identity</a>&lt; typename <a class="el" href="structetl_1_1remove__reference.html">etl::remove_reference</a>&lt; T &gt;::type *&gt;</td></tr>
<tr class="separator:aaf50ac295ca995606cb5bf055f2c267c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e8d828da790a56eaa4e9d62e347835"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a62e8d828da790a56eaa4e9d62e347835"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1detail.html#a62e8d828da790a56eaa4e9d62e347835">etl::detail::try_add_pointer</a> (...) -&gt; <a class="el" href="structetl_1_1type__identity.html">etl::type_identity</a>&lt; T &gt;</td></tr>
<tr class="separator:a62e8d828da790a56eaa4e9d62e347835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a9d942fca78e6480545f590e71fa0c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a24a9d942fca78e6480545f590e71fa0c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1detail.html#a24a9d942fca78e6480545f590e71fa0c">etl::detail::test_returnable</a> (int) -&gt; true_type_for&lt; T()&gt;</td></tr>
<tr class="separator:a24a9d942fca78e6480545f590e71fa0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addcc617420e36cad147efda37f49e9dd"><td class="memTemplParams" colspan="2">template&lt;class &gt; </td></tr>
<tr class="memitem:addcc617420e36cad147efda37f49e9dd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1detail.html#addcc617420e36cad147efda37f49e9dd">etl::detail::test_returnable</a> (...) -&gt; <a class="el" href="namespaceetl.html#a0917d3f5e85877c283c4f04e327fd973">etl::false_type</a></td></tr>
<tr class="separator:addcc617420e36cad147efda37f49e9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdeb6355bdbbc7f2e0c03f8a6b8dd85"><td class="memTemplParams" colspan="2">template&lt;class From , class To &gt; </td></tr>
<tr class="memitem:aacdeb6355bdbbc7f2e0c03f8a6b8dd85"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1detail.html#aacdeb6355bdbbc7f2e0c03f8a6b8dd85">etl::detail::test_nonvoid_convertible</a> (int) -&gt; true_type_for&lt; decltype(<a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292">etl::declval</a>&lt; void(&amp;)(To)&gt;()(<a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292">etl::declval</a>&lt; From &gt;()))&gt;</td></tr>
<tr class="separator:aacdeb6355bdbbc7f2e0c03f8a6b8dd85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f169d072f3290564c45be092d5b352"><td class="memTemplParams" colspan="2">template&lt;class , class &gt; </td></tr>
<tr class="memitem:a68f169d072f3290564c45be092d5b352"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl_1_1detail.html#a68f169d072f3290564c45be092d5b352">etl::detail::test_nonvoid_convertible</a> (...) -&gt; <a class="el" href="namespaceetl.html#a0917d3f5e85877c283c4f04e327fd973">etl::false_type</a></td></tr>
<tr class="separator:a68f169d072f3290564c45be092d5b352"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3f74da2365a9a6f68d472686fd0f1666"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a3f74da2365a9a6f68d472686fd0f1666"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3f74da2365a9a6f68d472686fd0f1666">etl::is_same_v</a> = is_same&lt;T, U&gt;::value</td></tr>
<tr class="separator:a3f74da2365a9a6f68d472686fd0f1666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149f8ba4063995f2c8ed7248d93a4d9e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a149f8ba4063995f2c8ed7248d93a4d9e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a149f8ba4063995f2c8ed7248d93a4d9e">etl::is_void_v</a> = is_void&lt;T&gt;::value</td></tr>
<tr class="separator:a149f8ba4063995f2c8ed7248d93a4d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef2a50a29c8803d461abedd7437effd"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0ef2a50a29c8803d461abedd7437effd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a> = is_integral&lt;T&gt;::value</td></tr>
<tr class="separator:a0ef2a50a29c8803d461abedd7437effd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf273d19443134cffcd66310d027ae4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5cf273d19443134cffcd66310d027ae4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5cf273d19443134cffcd66310d027ae4">etl::is_floating_point_v</a> = is_floating_point&lt;T&gt;::value</td></tr>
<tr class="separator:a5cf273d19443134cffcd66310d027ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40862de0c689f5281b8d680741bc7cf9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a40862de0c689f5281b8d680741bc7cf9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a40862de0c689f5281b8d680741bc7cf9">etl::is_const_v</a> = is_const&lt;T&gt;::value</td></tr>
<tr class="separator:a40862de0c689f5281b8d680741bc7cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22294e9170ea0547c68724eabe0c8c5a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a22294e9170ea0547c68724eabe0c8c5a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a22294e9170ea0547c68724eabe0c8c5a">etl::is_reference_v</a> = is_reference&lt;T&gt;::value</td></tr>
<tr class="separator:a22294e9170ea0547c68724eabe0c8c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016c8419365e8e3697a56040d335bca4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a016c8419365e8e3697a56040d335bca4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a016c8419365e8e3697a56040d335bca4">etl::is_null_pointer_v</a> = is_null_pointer&lt;T&gt;::value</td></tr>
<tr class="separator:a016c8419365e8e3697a56040d335bca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa46050181985a6156a6c800c86a7d8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:afaa46050181985a6156a6c800c86a7d8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afaa46050181985a6156a6c800c86a7d8">etl::is_array_v</a> = is_array&lt;T&gt;::value</td></tr>
<tr class="separator:afaa46050181985a6156a6c800c86a7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00eca7d51c4d2c1021402ee9a70f03c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac00eca7d51c4d2c1021402ee9a70f03c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac00eca7d51c4d2c1021402ee9a70f03c">etl::is_pointer_v</a> = is_pointer&lt;T&gt;::value</td></tr>
<tr class="separator:ac00eca7d51c4d2c1021402ee9a70f03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d441fab48eb459b77f6f5829f7fc75"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af8d441fab48eb459b77f6f5829f7fc75"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af8d441fab48eb459b77f6f5829f7fc75">etl::is_class_v</a> = is_class&lt;T&gt;::value</td></tr>
<tr class="separator:af8d441fab48eb459b77f6f5829f7fc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4784b73e6d758a37358b62211a308ef"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa4784b73e6d758a37358b62211a308ef"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa4784b73e6d758a37358b62211a308ef">etl::is_enum_v</a> = is_enum&lt;T&gt;::value</td></tr>
<tr class="separator:aa4784b73e6d758a37358b62211a308ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d4c31d288adf2cb4c5d7fd14c32f00"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a51d4c31d288adf2cb4c5d7fd14c32f00"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a51d4c31d288adf2cb4c5d7fd14c32f00">etl::is_union_v</a> = is_union&lt;T&gt;::value</td></tr>
<tr class="separator:a51d4c31d288adf2cb4c5d7fd14c32f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbaaa5057d498812ee848f491a20649a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:adbaaa5057d498812ee848f491a20649a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adbaaa5057d498812ee848f491a20649a">etl::is_member_pointer_v</a> = is_member_pointer&lt;T&gt;::value</td></tr>
<tr class="separator:adbaaa5057d498812ee848f491a20649a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105e2a5ac8fc634dcc71675e27e3f95e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a105e2a5ac8fc634dcc71675e27e3f95e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a105e2a5ac8fc634dcc71675e27e3f95e">etl::is_arithmetic_v</a> = is_arithmetic&lt;T&gt;::value</td></tr>
<tr class="separator:a105e2a5ac8fc634dcc71675e27e3f95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43d223a689de0810df63d7c223d4228"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab43d223a689de0810df63d7c223d4228"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab43d223a689de0810df63d7c223d4228">etl::is_scalar_v</a> = is_scalar&lt;T&gt;::value</td></tr>
<tr class="separator:ab43d223a689de0810df63d7c223d4228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63efd09c0ee7195824be65423adadedc"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a63efd09c0ee7195824be65423adadedc"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a63efd09c0ee7195824be65423adadedc">etl::is_object_v</a> = is_object&lt;T&gt;::value</td></tr>
<tr class="separator:a63efd09c0ee7195824be65423adadedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab616d6855ca5fc60968a153587b2b4"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:a1ab616d6855ca5fc60968a153587b2b4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1ab616d6855ca5fc60968a153587b2b4">etl::is_constructible_v</a> = is_constructible&lt;T, Args...&gt;::value</td></tr>
<tr class="separator:a1ab616d6855ca5fc60968a153587b2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbd05dc09b68b19c63d7b4fbf6f1108"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3bbd05dc09b68b19c63d7b4fbf6f1108"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3bbd05dc09b68b19c63d7b4fbf6f1108">etl::is_unsigned_v</a> = is_unsigned&lt;T&gt;::value</td></tr>
<tr class="separator:a3bbd05dc09b68b19c63d7b4fbf6f1108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56baa007c444a18e18b603a55d9957bf"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a56baa007c444a18e18b603a55d9957bf"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">etl::size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a56baa007c444a18e18b603a55d9957bf">etl::rank_v</a> = rank&lt;Type&gt;::value</td></tr>
<tr class="separator:a56baa007c444a18e18b603a55d9957bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15279e84c7ec40ef8a2d460b81b7fb7"><td class="memTemplParams" colspan="2">template&lt;class From , class To &gt; </td></tr>
<tr class="memitem:aa15279e84c7ec40ef8a2d460b81b7fb7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa15279e84c7ec40ef8a2d460b81b7fb7">etl::is_convertible_v</a> = is_convertible&lt;From, To&gt;::value</td></tr>
<tr class="separator:aa15279e84c7ec40ef8a2d460b81b7fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
