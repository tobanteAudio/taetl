<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>taetl: etl/type_traits.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">taetl
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_6adb7a8b31c129f1821662822662f63e.html">etl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">type_traits.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="type__traits__decl_8hpp_source.html">detail/type_traits_decl.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="definitions_8hpp_source.html">etl/definitions.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="intrinsics_8hpp_source.html">etl/detail/intrinsics.hpp</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for type_traits.hpp:</div>
<div class="dyncontent">
<div class="center"><img src="type__traits_8hpp__incl.png" border="0" usemap="#etl_2type__traits_8hpp" alt=""/></div>
<map name="etl_2type__traits_8hpp" id="etl_2type__traits_8hpp">
<area shape="rect" id="node2" href="type__traits__decl_8hpp.html" title="detail/type_traits\l_decl.hpp" alt="" coords="188,80,321,121"/>
<area shape="rect" id="node3" href="definitions_8hpp.html" title="etl/definitions.hpp" alt="" coords="96,169,235,196"/>
<area shape="rect" id="node7" href="intrinsics_8hpp.html" title="etl/detail/intrinsics.hpp" alt="" coords="265,169,436,196"/>
<area shape="rect" id="node4" href="version_8hpp.html" title="version.hpp" alt="" coords="5,244,104,271"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="type__traits_8hpp__dep__incl.png" border="0" usemap="#etl_2type__traits_8hppdep" alt=""/></div>
<map name="etl_2type__traits_8hppdep" id="etl_2type__traits_8hppdep">
<area shape="rect" id="node2" href="byte_8hpp.html" title="etl/byte.hpp" alt="" coords="324,80,424,107"/>
<area shape="rect" id="node5" href="map_8hpp.html" title="etl/map.hpp" alt="" coords="667,319,767,345"/>
<area shape="rect" id="node10" href="utility_8hpp.html" title="etl/utility.hpp" alt="" coords="792,80,898,107"/>
<area shape="rect" id="node11" href="numeric_8hpp.html" title="etl/numeric.hpp" alt="" coords="1134,162,1258,189"/>
<area shape="rect" id="node12" href="ratio_8hpp.html" title="etl/ratio.hpp" alt="" coords="1333,244,1434,271"/>
<area shape="rect" id="node13" href="chrono_8hpp.html" title="etl/chrono.hpp" alt="" coords="1533,319,1648,345"/>
<area shape="rect" id="node17" href="iterator_8hpp.html" title="etl/iterator.hpp" alt="" coords="24,162,143,189"/>
<area shape="rect" id="node18" href="bit_8hpp.html" title="etl/bit.hpp" alt="" coords="1384,80,1472,107"/>
<area shape="rect" id="node19" href="cmath_8hpp.html" title="etl/cmath.hpp" alt="" coords="1496,80,1608,107"/>
<area shape="rect" id="node20" href="concepts_8hpp.html" title="etl/concepts.hpp" alt="" coords="1631,80,1760,107"/>
<area shape="rect" id="node21" href="memory_8hpp.html" title="etl/memory.hpp" alt="" coords="22,80,146,107"/>
<area shape="rect" id="node22" href="span_8hpp.html" title="etl/span.hpp" alt="" coords="1836,80,1939,107"/>
<area shape="rect" id="node23" href="system__error_8hpp.html" title="etl/system_error.hpp" alt="" coords="1963,80,2119,107"/>
<area shape="rect" id="node3" href="functional_8hpp.html" title="etl/functional.hpp" alt="" coords="306,162,442,189"/>
<area shape="rect" id="node8" href="cstring_8hpp.html" title="etl/cstring.hpp" alt="" coords="168,162,282,189"/>
<area shape="rect" id="node4" href="algorithm_8hpp.html" title="etl/algorithm.hpp" alt="" coords="411,244,546,271"/>
<area shape="rect" id="node6" href="string__view_8hpp.html" title="etl/string_view.hpp" alt="" coords="152,319,298,345"/>
<area shape="rect" id="node7" href="vector_8hpp.html" title="etl/vector.hpp" alt="" coords="460,319,571,345"/>
<area shape="rect" id="node9" href="string_8hpp.html" title="etl/string.hpp" alt="" coords="171,244,279,271"/>
<area shape="rect" id="node14" href="dsp_8hpp.html" title="etl/experimental/dsp\l/dsp.hpp" alt="" coords="466,155,624,196"/>
<area shape="rect" id="node15" href="queue_8hpp.html" title="etl/experimental/rtos\l/queue.hpp" alt="" coords="648,155,807,196"/>
<area shape="rect" id="node16" href="strong__type_8hpp.html" title="etl/experimental/strong\l_type/strong_type.hpp" alt="" coords="883,155,1058,196"/>
</map>
</div>
</div>
<p><a href="type__traits_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1integral__constant.html">etl::integral_constant&lt; Type, val &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1type__identity.html">etl::type_identity&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__lvalue__reference.html">etl::add_lvalue_reference&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__rvalue__reference.html">etl::add_rvalue_reference&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__extent.html">etl::remove_extent&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an array of some type X, provides the member typedef type equal to X, otherwise type is T. Note that if T is a multidimensional array, only the first dimension is removed. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1remove__extent.html" title="If T is an array of some type X, provides the member typedef type equal to X, otherwise type is T...">remove_extent</a> is undefined.  <a href="structetl_1_1remove__extent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__extent_3_01T[]_4.html">etl::remove_extent&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__extent_3_01T[N]_4.html">etl::remove_extent&lt; T[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__const.html">etl::remove_const&lt; Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except that its topmost cv-qualifiers are removed. Removes the topmost const.  <a href="structetl_1_1remove__const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__const_3_01Type_01const_01_4.html">etl::remove_const&lt; Type const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__volatile.html">etl::remove_volatile&lt; Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except that its topmost cv-qualifiers are removed. Removes the topmost volatile.  <a href="structetl_1_1remove__volatile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__volatile_3_01Type_01volatile_01_4.html">etl::remove_volatile&lt; Type volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__cv.html">etl::remove_cv&lt; Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except that its topmost cv-qualifiers are removed. Removes the topmost const, or the topmost volatile, or both, if present.  <a href="structetl_1_1remove__cv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__reference.html">etl::remove_reference&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__reference_3_01T_01_6_01_4.html">etl::remove_reference&lt; T &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1remove__reference_3_01T_01_6_6_01_4.html">etl::remove_reference&lt; T &amp;&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__pointer.html">etl::add_pointer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a reference type, then provides the member typedef type which is a pointer to the referred type. Otherwise, if T names an object type, a function type that is not cv- or ref-qualified, or a (possibly cv-qualified) void type, provides the member typedef type which is the type T*. Otherwise (if T is a cv- or ref-qualified function type), provides the member typedef type which is the type T. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1add__pointer.html" title="If T is a reference type, then provides the member typedef type which is a pointer to the referred ty...">add_pointer</a> is undefined.  <a href="structetl_1_1add__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__cv.html">etl::add_cv&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except it has a cv-qualifier added (unless T is a function, a reference, or already has this cv-qualifier). Adds both const and volatile.  <a href="structetl_1_1add__cv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__const.html">etl::add_const&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except it has a cv-qualifier added (unless T is a function, a reference, or already has this cv-qualifier). Adds const.  <a href="structetl_1_1add__const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1add__volatile.html">etl::add_volatile&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the member typedef type which is the same as T, except it has a cv-qualifier added (unless T is a function, a reference, or already has this cv-qualifier). Adds volatile.  <a href="structetl_1_1add__volatile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__same.html">etl::is_same&lt; T, U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T and U name the same type (taking into account const/volatile qualifications), provides the member constant value equal to true. Otherwise value is false.  <a href="structetl_1_1is__same.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__same_3_01T_00_01T_01_4.html">etl::is_same&lt; T, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__void.html">etl::is_void&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a member typedef only if a boolean constant is true.  <a href="structetl_1_1is__void.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__integral.html">etl::is_integral&lt; Type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1make__unsigned.html">etl::make_unsigned&lt; Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an integral (except bool) or enumeration type, provides the member typedef type which is the unsigned integer type corresponding to T, with the same cv-qualifiers. If T is signed or unsigned char, short, int, long, long long; the unsigned type from this list corresponding to T is provided. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1make__unsigned.html" title="If T is an integral (except bool) or enumeration type, provides the member typedef type which is the ...">make_unsigned</a> is undefined.  <a href="structetl_1_1make__unsigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__floating__point.html">etl::is_floating_point&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a floating-point type. Provides the member constant value which is equal to true, if T is the type float, double, long double, including any cv-qualified variants. Otherwise, value is equal to false.  <a href="structetl_1_1is__floating__point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__const.html">etl::is_const&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__const_3_01const_01T_01_4.html">etl::is_const&lt; const T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__reference.html">etl::is_reference&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__reference_3_01T_01_6_01_4.html">etl::is_reference&lt; T &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__reference_3_01T_01_6_6_01_4.html">etl::is_reference&lt; T &amp;&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__null__pointer.html">etl::is_null_pointer&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__array.html">etl::is_array&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is an array type. Provides the member constant value which is equal to true, if T is an array type. Otherwise, value is equal to false.  <a href="structetl_1_1is__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__array_3_01T[]_4.html">etl::is_array&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__array_3_01T[N]_4.html">etl::is_array&lt; T[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__function.html">etl::is_function&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a function type. Types like <a class="el" href="classetl_1_1function.html">etl::function</a>, lambdas, classes with overloaded operator() and pointers to functions don't count as function types. Provides the member constant value which is equal to true, if T is a function type. Otherwise, value is equal to false.  <a href="structetl_1_1is__function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__pointer.html">etl::is_pointer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a pointer to object or a pointer to function (but not a pointer to member/member function). Provides the member constant value which is equal to true, if T is a object/function pointer type. Otherwise, value is equal to false.  <a href="structetl_1_1is__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__class.html">etl::is_class&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__enum.html">etl::is_enum&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__union.html">etl::is_union&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__member__pointer.html">etl::is_member_pointer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is pointer to non-static member object or a pointer to non-static member function, provides the member constant value equal true. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__member__pointer.html" title="If T is pointer to non-static member object or a pointer to non-static member function, provides the member constant value equal true. For any other type, value is false. The behavior of a program that adds specializations for is_member_pointer or is_member_pointer_v (since C++17) is undefined. ">is_member_pointer</a> or is_member_pointer_v (since C++17) is undefined.  <a href="structetl_1_1is__member__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__member__function__pointer.html">etl::is_member_function_pointer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a non-static member function pointer. Provides the member constant value which is equal to true, if T is a non-static member function pointer type. Otherwise, value is equal to false.  <a href="structetl_1_1is__member__function__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__member__object__pointer.html">etl::is_member_object_pointer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether T is a non-static member object pointer. Provides the member constant value which is equal to true, if T is a non-static member object pointer type. Otherwise, value is equal to false.  <a href="structetl_1_1is__member__object__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__arithmetic.html">etl::is_arithmetic&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an arithmetic type (that is, an integral type or a floating-point type) or a cv-qualified version thereof, provides the member constant value equal true. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__arithmetic.html" title="If T is an arithmetic type (that is, an integral type or a floating-point type) or a cv-qualified ver...">is_arithmetic</a> or is_arithmetic_v (since C++17) is undefined.  <a href="structetl_1_1is__arithmetic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__scalar.html">etl::is_scalar&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a scalar type (that is a possibly cv-qualified arithmetic, pointer, pointer to member, enumeration, or <a class="el" href="namespaceetl.html#adf4272f3f16bf2234ac8248db615f133">etl::nullptr_t</a> type), provides the member constant value equal true. For any other type, value is false.  <a href="structetl_1_1is__scalar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__object.html">etl::is_object&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an object type (that is any possibly cv-qualified type other than function, reference, or void types), provides the member constant value equal true. For any other type, value is false.  <a href="structetl_1_1is__object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__compound.html">etl::is_compound&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a compound type (that is, array, function, object pointer, function pointer, member object pointer, member function pointer, reference, class, union, or enumeration, including any cv-qualified variants), provides the member constant value equal true. For any other type, value is false.  <a href="structetl_1_1is__compound.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__constructible.html">etl::is_trivially_constructible&lt; T, Args &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variable definition does not call any operation that is not trivial. For the purposes of this check, the call to <a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292" title="Converts any type T to a reference type, making it possible to use member functions in decltype expre...">etl::declval</a> is considered trivial.  <a href="structetl_1_1is__trivially__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__constructible.html">etl::is_nothrow_constructible&lt; T, Args &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variable definition does not call any operation that is not trivial. For the purposes of this check, the call to <a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292" title="Converts any type T to a reference type, making it possible to use member functions in decltype expre...">etl::declval</a> is considered trivial.  <a href="structetl_1_1is__nothrow__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__default__constructible.html">etl::is_default_constructible&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If etl::is_constructible&lt;T&gt;::value is true, provides the member constant value equal to true, otherwise value is false.  <a href="structetl_1_1is__default__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__default__constructible.html">etl::is_trivially_default_constructible&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="structetl_1_1integral__constant.html#ac6a0d38654d5eeea44e25fea4eae7a55">etl::is_trivially_constructible&lt;T&gt;::value</a> is true, provides the member constant value equal to true, otherwise value is false.  <a href="structetl_1_1is__trivially__default__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__default__constructible.html">etl::is_nothrow_default_constructible&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="structetl_1_1integral__constant.html#ac6a0d38654d5eeea44e25fea4eae7a55">etl::is_nothrow_constructible&lt;T&gt;::value</a> is true, provides the member constant value equal to true, otherwise value is false.  <a href="structetl_1_1is__nothrow__default__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__copy__constructible.html">etl::is_copy_constructible&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to etl::is_constructible&lt;T, const T&amp;&gt;::value.  <a href="structetl_1_1is__copy__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__copy__constructible.html">etl::is_trivially_copy_constructible&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as copy, but uses etl::is_trivially_constructible&lt;T, const T&amp;&gt;.  <a href="structetl_1_1is__trivially__copy__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__copy__constructible.html">etl::is_nothrow_copy_constructible&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as copy, but uses etl::is_nothrow_constructible&lt;T, const T&amp;&gt;.  <a href="structetl_1_1is__nothrow__copy__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__move__constructible.html">etl::is_move_constructible&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to etl::is_constructible&lt;T, T&amp;&amp;&gt;::value.  <a href="structetl_1_1is__move__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__trivially__move__constructible.html">etl::is_trivially_move_constructible&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#ac6a0d38654d5eeea44e25fea4eae7a55">etl::is_trivially_constructible&lt;T, T&amp;&amp;&gt;::value</a>.  <a href="structetl_1_1is__trivially__move__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__nothrow__move__constructible.html">etl::is_nothrow_move_constructible&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is not a referenceable type (i.e., possibly cv-qualified void or a function type with a cv-qualifier-seq or a ref-qualifier), provides a member constant value equal to false. Otherwise, provides a member constant value equal to <a class="el" href="structetl_1_1integral__constant.html#ac6a0d38654d5eeea44e25fea4eae7a55">etl::is_nothrow_constructible&lt;T, T&amp;&amp;&gt;::value</a>.  <a href="structetl_1_1is__nothrow__move__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__unsigned.html">etl::is_unsigned&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an arithmetic type, provides the member constant value equal to true if T(0) &lt; T(-1): this results in true for the unsigned integer types and the type bool and in false for the signed integer types and the floating-point types. For any other type, value is false. The behavior of a program that adds specializations for <a class="el" href="structetl_1_1is__unsigned.html" title="If T is an arithmetic type, provides the member constant value equal to true if T(0) &lt; T(-1): this re...">is_unsigned</a> or is_unsigned_v (since C++17) is undefined.  <a href="structetl_1_1is__unsigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__signed.html">etl::is_signed&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is an arithmetic type, provides the member constant value equal to true if T(-1) &lt; T(0): this results in true for the floating-point types and the signed integer types, and in false for the unsigned integer types and the type bool. For any other type, value is false.  <a href="structetl_1_1is__signed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__base__of.html">etl::is_base_of&lt; Base, Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Derived is derived from Base or if both are the same non-union class (in both cases ignoring cv-qualification), provides the member constant value equal to true. Otherwise value is false.  <a href="structetl_1_1is__base__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1conditional.html">etl::conditional&lt; B, T, F &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides member typedef type, which is defined as T if B is true at compile time, or as F if B is false.  <a href="structetl_1_1conditional.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1conditional_3_01false_00_01T_00_01F_01_4.html">etl::conditional&lt; false, T, F &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1enable__if.html">etl::enable_if&lt; bool, Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a member typedef only if a boolean constant is true.  <a href="structetl_1_1enable__if.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1enable__if_3_01true_00_01Type_01_4.html">etl::enable_if&lt; true, Type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1rank.html">etl::rank&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Type is an array type, provides the member constant value equal to the number of dimensions of the array. For any other type, value is 0. The behavior of a program that adds specializations for rank or rank_v is undefined.  <a href="structetl_1_1rank.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1rank_3_01T[]_4.html">etl::rank&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1rank_3_01T[N]_4.html">etl::rank&lt; T[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1decay.html">etl::decay&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type.html">etl::common_type&lt;... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the common type among all types T..., that is the type all T... can be implicitly converted to. If such a type exists (as determined according to the rules below), the member type names that type. Otherwise, there is no member type. https://en.cppreference.com/w/cpp/types/common_type.  <a href="structetl_1_1common__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type_3_01T_01_4.html">etl::common_type&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type_3_01T1_00_01T2_01_4.html">etl::common_type&lt; T1, T2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1common__type_3_01T1_00_01T2_00_01R_8_8_8_01_4.html">etl::common_type&lt; T1, T2, R... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1is__convertible.html">etl::is_convertible&lt; From, To &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the imaginary function definition To test() { return <a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292" title="Converts any type T to a reference type, making it possible to use member functions in decltype expre...">etl::declval&lt;From&gt;()</a>; } is well-formed, (that is, either <a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292" title="Converts any type T to a reference type, making it possible to use member functions in decltype expre...">etl::declval&lt;From&gt;()</a> can be converted to To using implicit conversions, or both From and To are possibly cv-qualified void), provides the member constant value equal to true. Otherwise value is false. For the purposes of this check, the use of <a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292" title="Converts any type T to a reference type, making it possible to use member functions in decltype expre...">etl::declval</a> in the return statement is not considered an odr-use. Access checks are performed as if from a context unrelated to either type. Only the validity of the immediate context of the expression in the return statement (including conversions to the return type) is considered.  <a href="structetl_1_1is__convertible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1aligned__storage.html">etl::aligned_storage&lt; Len, Align &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the nested type type, which is a trivial standard-layout type suitable for use as uninitialized storage for any object whose size is at most Len and whose alignment requirement is a divisor of Align.  <a href="structetl_1_1aligned__storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structetl_1_1aligned__storage_1_1type.html">etl::aligned_storage&lt; Len, Align &gt;::type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceetl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html">etl</a></td></tr>
<tr class="memdesc:namespaceetl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for the etl library. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa19ff9e7939158584698cee4260e4471"><td class="memTemplParams" colspan="2">template&lt;bool B&gt; </td></tr>
<tr class="memitem:aa19ff9e7939158584698cee4260e4471"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa19ff9e7939158584698cee4260e4471">etl::bool_constant</a> = integral_constant&lt; bool, B &gt;</td></tr>
<tr class="separator:aa19ff9e7939158584698cee4260e4471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b54646ef5937839803117924c49d01"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac5b54646ef5937839803117924c49d01">etl::true_type</a> = integral_constant&lt; bool, true &gt;</td></tr>
<tr class="separator:ac5b54646ef5937839803117924c49d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0917d3f5e85877c283c4f04e327fd973"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0917d3f5e85877c283c4f04e327fd973">etl::false_type</a> = integral_constant&lt; bool, false &gt;</td></tr>
<tr class="separator:a0917d3f5e85877c283c4f04e327fd973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f76cc2621d7373b79e2fc034f160ee0"><td class="memTemplParams" colspan="2">template&lt;class... &gt; </td></tr>
<tr class="memitem:a8f76cc2621d7373b79e2fc034f160ee0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a8f76cc2621d7373b79e2fc034f160ee0">etl::void_t</a> = void</td></tr>
<tr class="separator:a8f76cc2621d7373b79e2fc034f160ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662329de2bc2a83d5e45d1ccad797f17"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a662329de2bc2a83d5e45d1ccad797f17"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a662329de2bc2a83d5e45d1ccad797f17">etl::add_lvalue_reference_t</a> = typename add_lvalue_reference&lt; T &gt;::type</td></tr>
<tr class="separator:a662329de2bc2a83d5e45d1ccad797f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c37a443b0cb66dc9b3c4374967b68f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a17c37a443b0cb66dc9b3c4374967b68f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a17c37a443b0cb66dc9b3c4374967b68f">etl::add_rvalue_reference_t</a> = typename add_rvalue_reference&lt; T &gt;::type</td></tr>
<tr class="separator:a17c37a443b0cb66dc9b3c4374967b68f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2368185596474aaf04490908f75e3a18"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2368185596474aaf04490908f75e3a18"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2368185596474aaf04490908f75e3a18">etl::remove_extent_t</a> = typename remove_extent&lt; T &gt;::type</td></tr>
<tr class="separator:a2368185596474aaf04490908f75e3a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e058aba499e52cc4ed554dd7d65332"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a87e058aba499e52cc4ed554dd7d65332"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a87e058aba499e52cc4ed554dd7d65332">etl::remove_const_t</a> = typename remove_const&lt; T &gt;::type</td></tr>
<tr class="separator:a87e058aba499e52cc4ed554dd7d65332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4593c7817c464ffa0d88cc07eb35e83"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af4593c7817c464ffa0d88cc07eb35e83"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af4593c7817c464ffa0d88cc07eb35e83">etl::remove_volatile_t</a> = typename remove_volatile&lt; T &gt;::type</td></tr>
<tr class="separator:af4593c7817c464ffa0d88cc07eb35e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70fb46b3c4c98f5f23b76cb25f343373"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a70fb46b3c4c98f5f23b76cb25f343373"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a70fb46b3c4c98f5f23b76cb25f343373">etl::remove_cv_t</a> = typename remove_cv&lt; T &gt;::type</td></tr>
<tr class="separator:a70fb46b3c4c98f5f23b76cb25f343373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ceb8de4fe37ef6a14f78dd10d95bb6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a26ceb8de4fe37ef6a14f78dd10d95bb6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a26ceb8de4fe37ef6a14f78dd10d95bb6">etl::remove_reference_t</a> = typename remove_reference&lt; T &gt;::type</td></tr>
<tr class="separator:a26ceb8de4fe37ef6a14f78dd10d95bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd20d67cb221212f49a97e02a7c1ca25"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:afd20d67cb221212f49a97e02a7c1ca25"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afd20d67cb221212f49a97e02a7c1ca25">etl::add_pointer_t</a> = typename add_pointer&lt; T &gt;::type</td></tr>
<tr class="separator:afd20d67cb221212f49a97e02a7c1ca25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40eedf5bef2e5ff8e5c7ca337cdc3ee1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a40eedf5bef2e5ff8e5c7ca337cdc3ee1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a40eedf5bef2e5ff8e5c7ca337cdc3ee1">etl::add_cv_t</a> = typename add_cv&lt; T &gt;::type</td></tr>
<tr class="separator:a40eedf5bef2e5ff8e5c7ca337cdc3ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20607674e1e3cd49d5f0b815b33b2c1d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a20607674e1e3cd49d5f0b815b33b2c1d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a20607674e1e3cd49d5f0b815b33b2c1d">etl::add_const_t</a> = typename add_const&lt; T &gt;::type</td></tr>
<tr class="separator:a20607674e1e3cd49d5f0b815b33b2c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3ae65a8164f8204c7f0ab6076b2cbc"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4e3ae65a8164f8204c7f0ab6076b2cbc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4e3ae65a8164f8204c7f0ab6076b2cbc">etl::add_volatile_t</a> = typename add_volatile&lt; T &gt;::type</td></tr>
<tr class="separator:a4e3ae65a8164f8204c7f0ab6076b2cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2df53f4e399975501cf8300d451814"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:acb2df53f4e399975501cf8300d451814"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#acb2df53f4e399975501cf8300d451814">etl::make_unsigned_t</a> = typename make_unsigned&lt; T &gt;::type</td></tr>
<tr class="separator:acb2df53f4e399975501cf8300d451814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55bc1fa71ef93a7cd65389359e61683c"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:a55bc1fa71ef93a7cd65389359e61683c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a55bc1fa71ef93a7cd65389359e61683c">etl::is_constructible</a> = detail::is_constructible_helper&lt; void_t&lt;&gt;, T, Args... &gt;</td></tr>
<tr class="separator:a55bc1fa71ef93a7cd65389359e61683c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa508ba172c61957cf6c18357210f08f6"><td class="memTemplParams" colspan="2">template&lt;bool B, class T , class F &gt; </td></tr>
<tr class="memitem:aa508ba172c61957cf6c18357210f08f6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa508ba172c61957cf6c18357210f08f6">etl::conditional_t</a> = typename conditional&lt; B, T, F &gt;::type</td></tr>
<tr class="separator:aa508ba172c61957cf6c18357210f08f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2df4ab89284c8c5866afea3100f290"><td class="memTemplParams" colspan="2">template&lt;bool B, class T  = void&gt; </td></tr>
<tr class="memitem:a2a2df4ab89284c8c5866afea3100f290"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a2a2df4ab89284c8c5866afea3100f290">etl::enable_if_t</a> = typename enable_if&lt; B, T &gt;::type</td></tr>
<tr class="separator:a2a2df4ab89284c8c5866afea3100f290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad602447fa93ad71f4db547fa0ae92883"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad602447fa93ad71f4db547fa0ae92883"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ad602447fa93ad71f4db547fa0ae92883">etl::decay_t</a> = typename decay&lt; T &gt;::type</td></tr>
<tr class="separator:ad602447fa93ad71f4db547fa0ae92883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80571ce0a1bbafdb4d8e153ceade9e3"><td class="memTemplParams" colspan="2">template&lt;class... T&gt; </td></tr>
<tr class="memitem:ac80571ce0a1bbafdb4d8e153ceade9e3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac80571ce0a1bbafdb4d8e153ceade9e3">etl::common_type_t</a> = typename common_type&lt; T... &gt;::type</td></tr>
<tr class="separator:ac80571ce0a1bbafdb4d8e153ceade9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ded42403ee495bd465c070c0262b8a"><td class="memTemplParams" colspan="2">template&lt;etl::size_t Len, etl::size_t Align = alignof(etl::max_align_t)&gt; </td></tr>
<tr class="memitem:a16ded42403ee495bd465c070c0262b8a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a16ded42403ee495bd465c070c0262b8a">etl::aligned_storage_t</a> = typename aligned_storage&lt; Len, Align &gt;::type</td></tr>
<tr class="separator:a16ded42403ee495bd465c070c0262b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4147daa38c6c4c1e59540fa0fa27a292"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4147daa38c6c4c1e59540fa0fa27a292"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292">etl::declval</a> () noexcept -&gt; typename <a class="el" href="structetl_1_1add__rvalue__reference.html">etl::add_rvalue_reference</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a4147daa38c6c4c1e59540fa0fa27a292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts any type T to a reference type, making it possible to use member functions in decltype expressions without the need to go through constructors.  <a href="namespaceetl.html#a4147daa38c6c4c1e59540fa0fa27a292">More...</a><br /></td></tr>
<tr class="separator:a4147daa38c6c4c1e59540fa0fa27a292"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3f74da2365a9a6f68d472686fd0f1666"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a3f74da2365a9a6f68d472686fd0f1666"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3f74da2365a9a6f68d472686fd0f1666">etl::is_same_v</a> = is_same&lt;T, U&gt;::value</td></tr>
<tr class="separator:a3f74da2365a9a6f68d472686fd0f1666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149f8ba4063995f2c8ed7248d93a4d9e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a149f8ba4063995f2c8ed7248d93a4d9e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a149f8ba4063995f2c8ed7248d93a4d9e">etl::is_void_v</a> = is_void&lt;T&gt;::value</td></tr>
<tr class="separator:a149f8ba4063995f2c8ed7248d93a4d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef2a50a29c8803d461abedd7437effd"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0ef2a50a29c8803d461abedd7437effd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0ef2a50a29c8803d461abedd7437effd">etl::is_integral_v</a> = is_integral&lt;T&gt;::value</td></tr>
<tr class="separator:a0ef2a50a29c8803d461abedd7437effd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf273d19443134cffcd66310d027ae4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5cf273d19443134cffcd66310d027ae4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a5cf273d19443134cffcd66310d027ae4">etl::is_floating_point_v</a> = is_floating_point&lt;T&gt;::value</td></tr>
<tr class="separator:a5cf273d19443134cffcd66310d027ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40862de0c689f5281b8d680741bc7cf9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a40862de0c689f5281b8d680741bc7cf9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a40862de0c689f5281b8d680741bc7cf9">etl::is_const_v</a> = is_const&lt;T&gt;::value</td></tr>
<tr class="separator:a40862de0c689f5281b8d680741bc7cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22294e9170ea0547c68724eabe0c8c5a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a22294e9170ea0547c68724eabe0c8c5a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a22294e9170ea0547c68724eabe0c8c5a">etl::is_reference_v</a> = is_reference&lt;T&gt;::value</td></tr>
<tr class="separator:a22294e9170ea0547c68724eabe0c8c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016c8419365e8e3697a56040d335bca4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a016c8419365e8e3697a56040d335bca4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a016c8419365e8e3697a56040d335bca4">etl::is_null_pointer_v</a> = is_null_pointer&lt;T&gt;::value</td></tr>
<tr class="separator:a016c8419365e8e3697a56040d335bca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa46050181985a6156a6c800c86a7d8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:afaa46050181985a6156a6c800c86a7d8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#afaa46050181985a6156a6c800c86a7d8">etl::is_array_v</a> = is_array&lt;T&gt;::value</td></tr>
<tr class="separator:afaa46050181985a6156a6c800c86a7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3b44fa05f956c1efc4f34af98bd1f0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aec3b44fa05f956c1efc4f34af98bd1f0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aec3b44fa05f956c1efc4f34af98bd1f0">etl::is_function_v</a> = is_function&lt;T&gt;::value</td></tr>
<tr class="separator:aec3b44fa05f956c1efc4f34af98bd1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00eca7d51c4d2c1021402ee9a70f03c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac00eca7d51c4d2c1021402ee9a70f03c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac00eca7d51c4d2c1021402ee9a70f03c">etl::is_pointer_v</a> = is_pointer&lt;T&gt;::value</td></tr>
<tr class="separator:ac00eca7d51c4d2c1021402ee9a70f03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d441fab48eb459b77f6f5829f7fc75"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af8d441fab48eb459b77f6f5829f7fc75"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af8d441fab48eb459b77f6f5829f7fc75">etl::is_class_v</a> = is_class&lt;T&gt;::value</td></tr>
<tr class="separator:af8d441fab48eb459b77f6f5829f7fc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4784b73e6d758a37358b62211a308ef"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa4784b73e6d758a37358b62211a308ef"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa4784b73e6d758a37358b62211a308ef">etl::is_enum_v</a> = is_enum&lt;T&gt;::value</td></tr>
<tr class="separator:aa4784b73e6d758a37358b62211a308ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d4c31d288adf2cb4c5d7fd14c32f00"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a51d4c31d288adf2cb4c5d7fd14c32f00"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a51d4c31d288adf2cb4c5d7fd14c32f00">etl::is_union_v</a> = is_union&lt;T&gt;::value</td></tr>
<tr class="separator:a51d4c31d288adf2cb4c5d7fd14c32f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbaaa5057d498812ee848f491a20649a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:adbaaa5057d498812ee848f491a20649a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#adbaaa5057d498812ee848f491a20649a">etl::is_member_pointer_v</a> = is_member_pointer&lt;T&gt;::value</td></tr>
<tr class="separator:adbaaa5057d498812ee848f491a20649a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690a598d20472c340a3e6969d5fe58af"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a690a598d20472c340a3e6969d5fe58af"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a690a598d20472c340a3e6969d5fe58af">etl::is_member_function_pointer_v</a> = is_member_function_pointer&lt;T&gt;::value</td></tr>
<tr class="separator:a690a598d20472c340a3e6969d5fe58af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05fe5ff6b0b6727ff7c98a53e5eb1c80"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a05fe5ff6b0b6727ff7c98a53e5eb1c80"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a05fe5ff6b0b6727ff7c98a53e5eb1c80">etl::is_member_object_pointer_v</a> = is_member_object_pointer&lt;T&gt;::value</td></tr>
<tr class="separator:a05fe5ff6b0b6727ff7c98a53e5eb1c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105e2a5ac8fc634dcc71675e27e3f95e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a105e2a5ac8fc634dcc71675e27e3f95e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a105e2a5ac8fc634dcc71675e27e3f95e">etl::is_arithmetic_v</a> = is_arithmetic&lt;T&gt;::value</td></tr>
<tr class="separator:a105e2a5ac8fc634dcc71675e27e3f95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43d223a689de0810df63d7c223d4228"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab43d223a689de0810df63d7c223d4228"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab43d223a689de0810df63d7c223d4228">etl::is_scalar_v</a> = is_scalar&lt;T&gt;::value</td></tr>
<tr class="separator:ab43d223a689de0810df63d7c223d4228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63efd09c0ee7195824be65423adadedc"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a63efd09c0ee7195824be65423adadedc"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a63efd09c0ee7195824be65423adadedc">etl::is_object_v</a> = is_object&lt;T&gt;::value</td></tr>
<tr class="separator:a63efd09c0ee7195824be65423adadedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45e49677aea4d7ed533e7c73ea7f2b6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab45e49677aea4d7ed533e7c73ea7f2b6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab45e49677aea4d7ed533e7c73ea7f2b6">etl::is_compound_v</a> = is_compound&lt;T&gt;::value</td></tr>
<tr class="separator:ab45e49677aea4d7ed533e7c73ea7f2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab616d6855ca5fc60968a153587b2b4"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:a1ab616d6855ca5fc60968a153587b2b4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a1ab616d6855ca5fc60968a153587b2b4">etl::is_constructible_v</a> = is_constructible&lt;T, Args...&gt;::value</td></tr>
<tr class="separator:a1ab616d6855ca5fc60968a153587b2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a74c34b46b65c2b8fa633d1e6211b25"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:a0a74c34b46b65c2b8fa633d1e6211b25"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0a74c34b46b65c2b8fa633d1e6211b25">etl::is_trivially_constructible_v</a> = is_trivially_constructible&lt;T, Args...&gt;::value</td></tr>
<tr class="separator:a0a74c34b46b65c2b8fa633d1e6211b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff5fc00d3b16aa2421ea49dae4e864e"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:a4ff5fc00d3b16aa2421ea49dae4e864e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a4ff5fc00d3b16aa2421ea49dae4e864e">etl::is_nothrow_constructible_v</a> = is_nothrow_constructible&lt;T, Args...&gt;::value</td></tr>
<tr class="separator:a4ff5fc00d3b16aa2421ea49dae4e864e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0093a625b8acbeac1878b9a9668a2563"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0093a625b8acbeac1878b9a9668a2563"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a0093a625b8acbeac1878b9a9668a2563">etl::is_default_constructible_v</a> = is_default_constructible&lt;T&gt;::value</td></tr>
<tr class="separator:a0093a625b8acbeac1878b9a9668a2563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f37ab88cda78781a7aca13f18adac97"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6f37ab88cda78781a7aca13f18adac97"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6f37ab88cda78781a7aca13f18adac97">etl::is_trivially_default_constructible_v</a> = is_trivially_default_constructible&lt;T&gt;::value</td></tr>
<tr class="separator:a6f37ab88cda78781a7aca13f18adac97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e312d7578609fe1f21277a6d7a1606"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a12e312d7578609fe1f21277a6d7a1606"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a12e312d7578609fe1f21277a6d7a1606">etl::is_nothrow_default_constructible_v</a> = is_nothrow_default_constructible&lt;T&gt;::value</td></tr>
<tr class="separator:a12e312d7578609fe1f21277a6d7a1606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045ef39158833b2ba6592fa8a1d0ebc1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a045ef39158833b2ba6592fa8a1d0ebc1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a045ef39158833b2ba6592fa8a1d0ebc1">etl::is_copy_constructible_v</a> = is_copy_constructible&lt;T&gt;::value</td></tr>
<tr class="separator:a045ef39158833b2ba6592fa8a1d0ebc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56b91d45ec88c108b77f55e9f6bc187"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac56b91d45ec88c108b77f55e9f6bc187"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac56b91d45ec88c108b77f55e9f6bc187">etl::is_trivially_copy_constructible_v</a> = is_trivially_copy_constructible&lt;T&gt;::value</td></tr>
<tr class="separator:ac56b91d45ec88c108b77f55e9f6bc187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05ca75073ae3731fef7c09200d9f693"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab05ca75073ae3731fef7c09200d9f693"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ab05ca75073ae3731fef7c09200d9f693">etl::is_nothrow_copy_constructible_v</a> = is_nothrow_copy_constructible&lt;T&gt;::value</td></tr>
<tr class="separator:ab05ca75073ae3731fef7c09200d9f693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b776d5da5e25514489bfd330d7940d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a82b776d5da5e25514489bfd330d7940d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a82b776d5da5e25514489bfd330d7940d">etl::is_move_constructible_v</a> = is_move_constructible&lt;T&gt;::value</td></tr>
<tr class="separator:a82b776d5da5e25514489bfd330d7940d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a74767dc0b6e2022826126e3581d7ed"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6a74767dc0b6e2022826126e3581d7ed"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a6a74767dc0b6e2022826126e3581d7ed">etl::is_trivially_move_constructible_v</a> = is_trivially_move_constructible&lt;T&gt;::value</td></tr>
<tr class="separator:a6a74767dc0b6e2022826126e3581d7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00f5b3ced7a1f4ebd3e7b1119a4c12a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac00f5b3ced7a1f4ebd3e7b1119a4c12a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#ac00f5b3ced7a1f4ebd3e7b1119a4c12a">etl::is_nothrow_move_constructible_v</a> = is_nothrow_move_constructible&lt;T&gt;::value</td></tr>
<tr class="separator:ac00f5b3ced7a1f4ebd3e7b1119a4c12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbd05dc09b68b19c63d7b4fbf6f1108"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3bbd05dc09b68b19c63d7b4fbf6f1108"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a3bbd05dc09b68b19c63d7b4fbf6f1108">etl::is_unsigned_v</a> = is_unsigned&lt;T&gt;::value</td></tr>
<tr class="separator:a3bbd05dc09b68b19c63d7b4fbf6f1108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3fadd2a1e349c45f524ab5444220ff"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aff3fadd2a1e349c45f524ab5444220ff"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aff3fadd2a1e349c45f524ab5444220ff">etl::is_signed_v</a> = is_signed&lt;T&gt;::value</td></tr>
<tr class="separator:aff3fadd2a1e349c45f524ab5444220ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00bab8d0b02bcb2974969b9d69639bb"><td class="memTemplParams" colspan="2">template&lt;class Base , class Derived &gt; </td></tr>
<tr class="memitem:af00bab8d0b02bcb2974969b9d69639bb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#af00bab8d0b02bcb2974969b9d69639bb">etl::is_base_of_v</a> = is_base_of&lt;Base, Derived&gt;::value</td></tr>
<tr class="separator:af00bab8d0b02bcb2974969b9d69639bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56baa007c444a18e18b603a55d9957bf"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:a56baa007c444a18e18b603a55d9957bf"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceetl.html#ac853a6316b146d25fdfbb5865821cedd">etl::size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#a56baa007c444a18e18b603a55d9957bf">etl::rank_v</a> = rank&lt;Type&gt;::value</td></tr>
<tr class="separator:a56baa007c444a18e18b603a55d9957bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15279e84c7ec40ef8a2d460b81b7fb7"><td class="memTemplParams" colspan="2">template&lt;class From , class To &gt; </td></tr>
<tr class="memitem:aa15279e84c7ec40ef8a2d460b81b7fb7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceetl.html#aa15279e84c7ec40ef8a2d460b81b7fb7">etl::is_convertible_v</a> = is_convertible&lt;From, To&gt;::value</td></tr>
<tr class="separator:aa15279e84c7ec40ef8a2d460b81b7fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
